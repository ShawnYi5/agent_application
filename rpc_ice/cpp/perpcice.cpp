// **********************************************************************
//
// Copyright (c) 2003-2015 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.6.1
//
// <auto-generated>
//
// Generated from file `perpcice.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <perpcice.h>
#include <IceUtil/PushDisableWarnings.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/BasicStream.h>
#include <IceUtil/Iterator.h>
#include <IceUtil/PopDisableWarnings.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 306
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace
{

const ::std::string __PerpcIce__PeGuestReceiver__ReadDisk_name = "ReadDisk";

const ::std::string __PerpcIce__PeGuestReceiver__WriteDisk_name = "WriteDisk";

const ::std::string __PerpcIce__PeGuestReceiver__SetRestoreExcludeInfo_name = "SetRestoreExcludeInfo";

const ::std::string __PerpcIce__PeGuestReceiver__KvmEnd_name = "KvmEnd";

const ::std::string __PerpcIce__PeGuestReceiver__GetClassHWInfo_name = "GetClassHWInfo";

const ::std::string __PerpcIce__PeGuestReceiver__GetNetAdapterInfo_name = "GetNetAdapterInfo";

const ::std::string __PerpcIce__PeGuestReceiver__SetRestoreInfo_name = "SetRestoreInfo";

const ::std::string __PerpcIce__PeGuestReceiver__JsonFunc_name = "JsonFunc";

const ::std::string __PerpcIce__PeSession__InitiatePeReceiver_name = "InitiatePeReceiver";

const ::std::string __PerpcIce__PeSession__GetPeHostIdent_name = "GetPeHostIdent";

const ::std::string __PerpcIce__PeSession__UnInit_name = "UnInit";

const ::std::string __PerpcIce__PeSession__GetBootList_name = "GetBootList";

const ::std::string __PerpcIce__PeSession__GetKvmBitmapFile_name = "GetKvmBitmapFile";

const ::std::string __PerpcIce__PeSession__ReadDiskData_name = "ReadDiskData";

const ::std::string __PerpcIce__PeSession__ReadKvmBootData_name = "ReadKvmBootData";

const ::std::string __PerpcIce__PeSession__getUesdBlockBitmap_name = "getUesdBlockBitmap";

const ::std::string __PerpcIce__PeSession__Refresh_name = "Refresh";

const ::std::string __PerpcIce__PeSession__StartKvm_name = "StartKvm";

const ::std::string __PerpcIce__PeSession__destroy_name = "destroy";

const ::std::string __PerpcIce__PeSessionFactory__CreateSession_name = "CreateSession";

}

namespace Ice
{
}
::IceProxy::Ice::Object* ::IceProxy::PerpcIce::upCast(::IceProxy::PerpcIce::PeGuestReceiver* p) { return p; }

void
::IceProxy::PerpcIce::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::PerpcIce::PeGuestReceiver>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::PerpcIce::PeGuestReceiver;
        v->__copyFrom(proxy);
    }
}

::Ice::Int
IceProxy::PerpcIce::PeGuestReceiver::ReadDisk(const ::std::string& __p_token, ::Ice::Long __p_LBA, ::Ice::Int __p_dwSectorCount, ::PerpcIce::BinaryStream& __p_pBuf, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__PerpcIce__PeGuestReceiver__ReadDisk_name);
    ::IceInternal::Outgoing __og(this, __PerpcIce__PeGuestReceiver__ReadDisk_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_token);
        __os->write(__p_LBA);
        __os->write(__p_dwSectorCount);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_pBuf);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeGuestReceiver::begin_ReadDisk(const ::std::string& __p_token, ::Ice::Long __p_LBA, ::Ice::Int __p_dwSectorCount, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__PerpcIce__PeGuestReceiver__ReadDisk_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeGuestReceiver__ReadDisk_name, __del, __cookie);
    try
    {
        __result->prepare(__PerpcIce__PeGuestReceiver__ReadDisk_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_token);
        __os->write(__p_LBA);
        __os->write(__p_dwSectorCount);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeGuestReceiver::__begin_ReadDisk(const ::std::string& __p_token, ::Ice::Long __p_LBA, ::Ice::Int __p_dwSectorCount, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int, const ::PerpcIce::BinaryStream&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int, const ::PerpcIce::BinaryStream&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::PerpcIce::PeGuestReceiverPrx __proxy = ::PerpcIce::PeGuestReceiverPrx::uncheckedCast(__result->getProxy());
            ::PerpcIce::BinaryStream __p_pBuf;
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_ReadDisk(__p_pBuf, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_pBuf);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int, const ::PerpcIce::BinaryStream&)> _response;
    };
    return begin_ReadDisk(__p_token, __p_LBA, __p_dwSectorCount, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::PerpcIce::PeGuestReceiver::end_ReadDisk(::PerpcIce::BinaryStream& __p_pBuf, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __PerpcIce__PeGuestReceiver__ReadDisk_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_pBuf);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::Ice::Int
IceProxy::PerpcIce::PeGuestReceiver::WriteDisk(const ::std::string& __p_token, ::Ice::Long __p_LBA, ::Ice::Int __p_dwSectorCount, const ::PerpcIce::BinaryStream& __p_pBuf, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__PerpcIce__PeGuestReceiver__WriteDisk_name);
    ::IceInternal::Outgoing __og(this, __PerpcIce__PeGuestReceiver__WriteDisk_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_token);
        __os->write(__p_LBA);
        __os->write(__p_dwSectorCount);
        __os->write(__p_pBuf);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeGuestReceiver::begin_WriteDisk(const ::std::string& __p_token, ::Ice::Long __p_LBA, ::Ice::Int __p_dwSectorCount, const ::PerpcIce::BinaryStream& __p_pBuf, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__PerpcIce__PeGuestReceiver__WriteDisk_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeGuestReceiver__WriteDisk_name, __del, __cookie);
    try
    {
        __result->prepare(__PerpcIce__PeGuestReceiver__WriteDisk_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_token);
        __os->write(__p_LBA);
        __os->write(__p_dwSectorCount);
        __os->write(__p_pBuf);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeGuestReceiver::__begin_WriteDisk(const ::std::string& __p_token, ::Ice::Long __p_LBA, ::Ice::Int __p_dwSectorCount, const ::PerpcIce::BinaryStream& __p_pBuf, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::PerpcIce::PeGuestReceiverPrx __proxy = ::PerpcIce::PeGuestReceiverPrx::uncheckedCast(__result->getProxy());
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_WriteDisk(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int)> _response;
    };
    return begin_WriteDisk(__p_token, __p_LBA, __p_dwSectorCount, __p_pBuf, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::PerpcIce::PeGuestReceiver::end_WriteDisk(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __PerpcIce__PeGuestReceiver__WriteDisk_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::PerpcIce::PeGuestReceiver::SetRestoreExcludeInfo(const ::PerpcIce::ExcludeBrokenBlocks& __p_brokenBlocks, const ::PerpcIce::ExcludeBlockRuns& __p_blockRuns, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__PerpcIce__PeGuestReceiver__SetRestoreExcludeInfo_name);
    ::IceInternal::Outgoing __og(this, __PerpcIce__PeGuestReceiver__SetRestoreExcludeInfo_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_brokenBlocks);
        __os->write(__p_blockRuns);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeGuestReceiver::begin_SetRestoreExcludeInfo(const ::PerpcIce::ExcludeBrokenBlocks& __p_brokenBlocks, const ::PerpcIce::ExcludeBlockRuns& __p_blockRuns, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__PerpcIce__PeGuestReceiver__SetRestoreExcludeInfo_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeGuestReceiver__SetRestoreExcludeInfo_name, __del, __cookie);
    try
    {
        __result->prepare(__PerpcIce__PeGuestReceiver__SetRestoreExcludeInfo_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_brokenBlocks);
        __os->write(__p_blockRuns);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeGuestReceiver::__begin_SetRestoreExcludeInfo(const ::PerpcIce::ExcludeBrokenBlocks& __p_brokenBlocks, const ::PerpcIce::ExcludeBlockRuns& __p_blockRuns, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::PerpcIce::PeGuestReceiverPrx __proxy = ::PerpcIce::PeGuestReceiverPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_SetRestoreExcludeInfo(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_SetRestoreExcludeInfo(__p_brokenBlocks, __p_blockRuns, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::PerpcIce::PeGuestReceiver::end_SetRestoreExcludeInfo(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __PerpcIce__PeGuestReceiver__SetRestoreExcludeInfo_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::PerpcIce::PeGuestReceiver::KvmEnd(const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__PerpcIce__PeGuestReceiver__KvmEnd_name);
    ::IceInternal::Outgoing __og(this, __PerpcIce__PeGuestReceiver__KvmEnd_name, ::Ice::Idempotent, __ctx);
    __og.writeEmptyParams();
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeGuestReceiver::begin_KvmEnd(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__PerpcIce__PeGuestReceiver__KvmEnd_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeGuestReceiver__KvmEnd_name, __del, __cookie);
    try
    {
        __result->prepare(__PerpcIce__PeGuestReceiver__KvmEnd_name, ::Ice::Idempotent, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeGuestReceiver::__begin_KvmEnd(const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::PerpcIce::PeGuestReceiverPrx __proxy = ::PerpcIce::PeGuestReceiverPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_KvmEnd(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_KvmEnd(__ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::PerpcIce::PeGuestReceiver::end_KvmEnd(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __PerpcIce__PeGuestReceiver__KvmEnd_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

::Ice::Int
IceProxy::PerpcIce::PeGuestReceiver::GetClassHWInfo(const ::std::string& __p_classname, ::Ice::Int __p_requestParentLevel, ::PerpcIce::HWInfos& __p_hwinfo, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__PerpcIce__PeGuestReceiver__GetClassHWInfo_name);
    ::IceInternal::Outgoing __og(this, __PerpcIce__PeGuestReceiver__GetClassHWInfo_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_classname);
        __os->write(__p_requestParentLevel);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_hwinfo);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeGuestReceiver::begin_GetClassHWInfo(const ::std::string& __p_classname, ::Ice::Int __p_requestParentLevel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__PerpcIce__PeGuestReceiver__GetClassHWInfo_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeGuestReceiver__GetClassHWInfo_name, __del, __cookie);
    try
    {
        __result->prepare(__PerpcIce__PeGuestReceiver__GetClassHWInfo_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_classname);
        __os->write(__p_requestParentLevel);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeGuestReceiver::__begin_GetClassHWInfo(const ::std::string& __p_classname, ::Ice::Int __p_requestParentLevel, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int, const ::PerpcIce::HWInfos&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int, const ::PerpcIce::HWInfos&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::PerpcIce::PeGuestReceiverPrx __proxy = ::PerpcIce::PeGuestReceiverPrx::uncheckedCast(__result->getProxy());
            ::PerpcIce::HWInfos __p_hwinfo;
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_GetClassHWInfo(__p_hwinfo, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_hwinfo);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int, const ::PerpcIce::HWInfos&)> _response;
    };
    return begin_GetClassHWInfo(__p_classname, __p_requestParentLevel, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::PerpcIce::PeGuestReceiver::end_GetClassHWInfo(::PerpcIce::HWInfos& __p_hwinfo, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __PerpcIce__PeGuestReceiver__GetClassHWInfo_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_hwinfo);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::Ice::Int
IceProxy::PerpcIce::PeGuestReceiver::GetNetAdapterInfo(::PerpcIce::NetAdapterInfos& __p_adapterInfos, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__PerpcIce__PeGuestReceiver__GetNetAdapterInfo_name);
    ::IceInternal::Outgoing __og(this, __PerpcIce__PeGuestReceiver__GetNetAdapterInfo_name, ::Ice::Idempotent, __ctx);
    __og.writeEmptyParams();
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_adapterInfos);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeGuestReceiver::begin_GetNetAdapterInfo(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__PerpcIce__PeGuestReceiver__GetNetAdapterInfo_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeGuestReceiver__GetNetAdapterInfo_name, __del, __cookie);
    try
    {
        __result->prepare(__PerpcIce__PeGuestReceiver__GetNetAdapterInfo_name, ::Ice::Idempotent, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeGuestReceiver::__begin_GetNetAdapterInfo(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int, const ::PerpcIce::NetAdapterInfos&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int, const ::PerpcIce::NetAdapterInfos&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::PerpcIce::PeGuestReceiverPrx __proxy = ::PerpcIce::PeGuestReceiverPrx::uncheckedCast(__result->getProxy());
            ::PerpcIce::NetAdapterInfos __p_adapterInfos;
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_GetNetAdapterInfo(__p_adapterInfos, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_adapterInfos);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int, const ::PerpcIce::NetAdapterInfos&)> _response;
    };
    return begin_GetNetAdapterInfo(__ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::PerpcIce::PeGuestReceiver::end_GetNetAdapterInfo(::PerpcIce::NetAdapterInfos& __p_adapterInfos, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __PerpcIce__PeGuestReceiver__GetNetAdapterInfo_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_adapterInfos);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::PerpcIce::PeGuestReceiver::SetRestoreInfo(const ::PerpcIce::PeRestoreInfo& __p_restoreInfo, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__PerpcIce__PeGuestReceiver__SetRestoreInfo_name);
    ::IceInternal::Outgoing __og(this, __PerpcIce__PeGuestReceiver__SetRestoreInfo_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_restoreInfo);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeGuestReceiver::begin_SetRestoreInfo(const ::PerpcIce::PeRestoreInfo& __p_restoreInfo, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__PerpcIce__PeGuestReceiver__SetRestoreInfo_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeGuestReceiver__SetRestoreInfo_name, __del, __cookie);
    try
    {
        __result->prepare(__PerpcIce__PeGuestReceiver__SetRestoreInfo_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_restoreInfo);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeGuestReceiver::__begin_SetRestoreInfo(const ::PerpcIce::PeRestoreInfo& __p_restoreInfo, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::PerpcIce::PeGuestReceiverPrx __proxy = ::PerpcIce::PeGuestReceiverPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_SetRestoreInfo(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_SetRestoreInfo(__p_restoreInfo, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::PerpcIce::PeGuestReceiver::end_SetRestoreInfo(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __PerpcIce__PeGuestReceiver__SetRestoreInfo_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

::std::string
IceProxy::PerpcIce::PeGuestReceiver::JsonFunc(const ::std::string& __p_inputJson, const ::PerpcIce::BinaryStream& __p_inputBs, ::PerpcIce::BinaryStream& __p_outputBs, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__PerpcIce__PeGuestReceiver__JsonFunc_name);
    ::IceInternal::Outgoing __og(this, __PerpcIce__PeGuestReceiver__JsonFunc_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_inputJson);
        __os->write(__p_inputBs);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_outputBs);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeGuestReceiver::begin_JsonFunc(const ::std::string& __p_inputJson, const ::PerpcIce::BinaryStream& __p_inputBs, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__PerpcIce__PeGuestReceiver__JsonFunc_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeGuestReceiver__JsonFunc_name, __del, __cookie);
    try
    {
        __result->prepare(__PerpcIce__PeGuestReceiver__JsonFunc_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_inputJson);
        __os->write(__p_inputBs);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeGuestReceiver::__begin_JsonFunc(const ::std::string& __p_inputJson, const ::PerpcIce::BinaryStream& __p_inputBs, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&, const ::PerpcIce::BinaryStream&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&, const ::PerpcIce::BinaryStream&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::PerpcIce::PeGuestReceiverPrx __proxy = ::PerpcIce::PeGuestReceiverPrx::uncheckedCast(__result->getProxy());
            ::PerpcIce::BinaryStream __p_outputBs;
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_JsonFunc(__p_outputBs, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_outputBs);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&, const ::PerpcIce::BinaryStream&)> _response;
    };
    return begin_JsonFunc(__p_inputJson, __p_inputBs, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::PerpcIce::PeGuestReceiver::end_JsonFunc(::PerpcIce::BinaryStream& __p_outputBs, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __PerpcIce__PeGuestReceiver__JsonFunc_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_outputBs);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

const ::std::string&
IceProxy::PerpcIce::PeGuestReceiver::ice_staticId()
{
    return ::PerpcIce::PeGuestReceiver::ice_staticId();
}

::IceProxy::Ice::Object*
IceProxy::PerpcIce::PeGuestReceiver::__newInstance() const
{
    return new PeGuestReceiver;
}
::IceProxy::Ice::Object* ::IceProxy::PerpcIce::upCast(::IceProxy::PerpcIce::PeSession* p) { return p; }

void
::IceProxy::PerpcIce::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::PerpcIce::PeSession>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::PerpcIce::PeSession;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::PerpcIce::PeSession::InitiatePeReceiver(const ::Ice::Identity& __p_ident, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__PerpcIce__PeSession__InitiatePeReceiver_name);
    ::IceInternal::Outgoing __og(this, __PerpcIce__PeSession__InitiatePeReceiver_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_ident);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeSession::begin_InitiatePeReceiver(const ::Ice::Identity& __p_ident, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__PerpcIce__PeSession__InitiatePeReceiver_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeSession__InitiatePeReceiver_name, __del, __cookie);
    try
    {
        __result->prepare(__PerpcIce__PeSession__InitiatePeReceiver_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_ident);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeSession::__begin_InitiatePeReceiver(const ::Ice::Identity& __p_ident, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::PerpcIce::PeSessionPrx __proxy = ::PerpcIce::PeSessionPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_InitiatePeReceiver(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_InitiatePeReceiver(__p_ident, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::PerpcIce::PeSession::end_InitiatePeReceiver(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __PerpcIce__PeSession__InitiatePeReceiver_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::PerpcIce::PeSession::GetPeHostIdent(::std::string& __p_peHostIdent, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__PerpcIce__PeSession__GetPeHostIdent_name);
    ::IceInternal::Outgoing __og(this, __PerpcIce__PeSession__GetPeHostIdent_name, ::Ice::Idempotent, __ctx);
    __og.writeEmptyParams();
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_peHostIdent);
    __og.endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeSession::begin_GetPeHostIdent(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__PerpcIce__PeSession__GetPeHostIdent_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeSession__GetPeHostIdent_name, __del, __cookie);
    try
    {
        __result->prepare(__PerpcIce__PeSession__GetPeHostIdent_name, ::Ice::Idempotent, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeSession::__begin_GetPeHostIdent(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::PerpcIce::PeSessionPrx __proxy = ::PerpcIce::PeSessionPrx::uncheckedCast(__result->getProxy());
            ::std::string __p_peHostIdent;
            try
            {
                __proxy->end_GetPeHostIdent(__p_peHostIdent, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__p_peHostIdent);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_GetPeHostIdent(__ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::PerpcIce::PeSession::end_GetPeHostIdent(::std::string& __p_peHostIdent, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __PerpcIce__PeSession__GetPeHostIdent_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_peHostIdent);
    __result->__endReadParams();
}

void
IceProxy::PerpcIce::PeSession::UnInit(::Ice::Int __p_dwStatus, const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __PerpcIce__PeSession__UnInit_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_dwStatus);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeSession::begin_UnInit(::Ice::Int __p_dwStatus, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeSession__UnInit_name, __del, __cookie);
    try
    {
        __result->prepare(__PerpcIce__PeSession__UnInit_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_dwStatus);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::PerpcIce::PeSession::end_UnInit(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __PerpcIce__PeSession__UnInit_name);
}

::Ice::Int
IceProxy::PerpcIce::PeSession::GetBootList(::Ice::Int __p_index, ::std::string& __p_bootlist, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__PerpcIce__PeSession__GetBootList_name);
    ::IceInternal::Outgoing __og(this, __PerpcIce__PeSession__GetBootList_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_index);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::NeedRetryLaterError&)
        {
            throw;
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_bootlist);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeSession::begin_GetBootList(::Ice::Int __p_index, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__PerpcIce__PeSession__GetBootList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeSession__GetBootList_name, __del, __cookie);
    try
    {
        __result->prepare(__PerpcIce__PeSession__GetBootList_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_index);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeSession::__begin_GetBootList(::Ice::Int __p_index, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int, const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int, const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::PerpcIce::PeSessionPrx __proxy = ::PerpcIce::PeSessionPrx::uncheckedCast(__result->getProxy());
            ::std::string __p_bootlist;
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_GetBootList(__p_bootlist, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_bootlist);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int, const ::std::string&)> _response;
    };
    return begin_GetBootList(__p_index, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::PerpcIce::PeSession::end_GetBootList(::std::string& __p_bootlist, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __PerpcIce__PeSession__GetBootList_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::NeedRetryLaterError&)
        {
            throw;
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_bootlist);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::Ice::Int
IceProxy::PerpcIce::PeSession::GetKvmBitmapFile(::Ice::Int __p_index, ::PerpcIce::BinaryStream& __p_data, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__PerpcIce__PeSession__GetKvmBitmapFile_name);
    ::IceInternal::Outgoing __og(this, __PerpcIce__PeSession__GetKvmBitmapFile_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_index);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::NeedRetryLaterError&)
        {
            throw;
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_data);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeSession::begin_GetKvmBitmapFile(::Ice::Int __p_index, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__PerpcIce__PeSession__GetKvmBitmapFile_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeSession__GetKvmBitmapFile_name, __del, __cookie);
    try
    {
        __result->prepare(__PerpcIce__PeSession__GetKvmBitmapFile_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_index);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeSession::__begin_GetKvmBitmapFile(::Ice::Int __p_index, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int, const ::PerpcIce::BinaryStream&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int, const ::PerpcIce::BinaryStream&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::PerpcIce::PeSessionPrx __proxy = ::PerpcIce::PeSessionPrx::uncheckedCast(__result->getProxy());
            ::PerpcIce::BinaryStream __p_data;
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_GetKvmBitmapFile(__p_data, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_data);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int, const ::PerpcIce::BinaryStream&)> _response;
    };
    return begin_GetKvmBitmapFile(__p_index, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::PerpcIce::PeSession::end_GetKvmBitmapFile(::PerpcIce::BinaryStream& __p_data, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __PerpcIce__PeSession__GetKvmBitmapFile_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::NeedRetryLaterError&)
        {
            throw;
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_data);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::Ice::Int
IceProxy::PerpcIce::PeSession::ReadDiskData(const ::std::string& __p_token, ::Ice::Long __p_LBA, ::Ice::Int __p_dwSectorCount, ::PerpcIce::BinaryStream& __p_pBuf, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__PerpcIce__PeSession__ReadDiskData_name);
    ::IceInternal::Outgoing __og(this, __PerpcIce__PeSession__ReadDiskData_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_token);
        __os->write(__p_LBA);
        __os->write(__p_dwSectorCount);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_pBuf);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeSession::begin_ReadDiskData(const ::std::string& __p_token, ::Ice::Long __p_LBA, ::Ice::Int __p_dwSectorCount, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__PerpcIce__PeSession__ReadDiskData_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeSession__ReadDiskData_name, __del, __cookie);
    try
    {
        __result->prepare(__PerpcIce__PeSession__ReadDiskData_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_token);
        __os->write(__p_LBA);
        __os->write(__p_dwSectorCount);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeSession::__begin_ReadDiskData(const ::std::string& __p_token, ::Ice::Long __p_LBA, ::Ice::Int __p_dwSectorCount, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int, const ::PerpcIce::BinaryStream&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int, const ::PerpcIce::BinaryStream&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::PerpcIce::PeSessionPrx __proxy = ::PerpcIce::PeSessionPrx::uncheckedCast(__result->getProxy());
            ::PerpcIce::BinaryStream __p_pBuf;
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_ReadDiskData(__p_pBuf, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_pBuf);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int, const ::PerpcIce::BinaryStream&)> _response;
    };
    return begin_ReadDiskData(__p_token, __p_LBA, __p_dwSectorCount, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::PerpcIce::PeSession::end_ReadDiskData(::PerpcIce::BinaryStream& __p_pBuf, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __PerpcIce__PeSession__ReadDiskData_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_pBuf);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::Ice::Int
IceProxy::PerpcIce::PeSession::ReadKvmBootData(::Ice::Int __p_threadIndex, ::Ice::Int __p_blockIndex, bool& __p_isEnd, bool& __p_isSkip, ::std::string& __p_diskToken, ::Ice::Long& __p_LBA, ::Ice::Int& __p_dwSectorCount, ::PerpcIce::BinaryStream& __p_data, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__PerpcIce__PeSession__ReadKvmBootData_name);
    ::IceInternal::Outgoing __og(this, __PerpcIce__PeSession__ReadKvmBootData_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_threadIndex);
        __os->write(__p_blockIndex);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_isEnd);
    __is->read(__p_isSkip);
    __is->read(__p_diskToken);
    __is->read(__p_LBA);
    __is->read(__p_dwSectorCount);
    __is->read(__p_data);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeSession::begin_ReadKvmBootData(::Ice::Int __p_threadIndex, ::Ice::Int __p_blockIndex, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__PerpcIce__PeSession__ReadKvmBootData_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeSession__ReadKvmBootData_name, __del, __cookie);
    try
    {
        __result->prepare(__PerpcIce__PeSession__ReadKvmBootData_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_threadIndex);
        __os->write(__p_blockIndex);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeSession::__begin_ReadKvmBootData(::Ice::Int __p_threadIndex, ::Ice::Int __p_blockIndex, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int, bool, bool, const ::std::string&, ::Ice::Long, ::Ice::Int, const ::PerpcIce::BinaryStream&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int, bool, bool, const ::std::string&, ::Ice::Long, ::Ice::Int, const ::PerpcIce::BinaryStream&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::PerpcIce::PeSessionPrx __proxy = ::PerpcIce::PeSessionPrx::uncheckedCast(__result->getProxy());
            bool __p_isEnd;
            bool __p_isSkip;
            ::std::string __p_diskToken;
            ::Ice::Long __p_LBA;
            ::Ice::Int __p_dwSectorCount;
            ::PerpcIce::BinaryStream __p_data;
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_ReadKvmBootData(__p_isEnd, __p_isSkip, __p_diskToken, __p_LBA, __p_dwSectorCount, __p_data, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_isEnd, __p_isSkip, __p_diskToken, __p_LBA, __p_dwSectorCount, __p_data);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int, bool, bool, const ::std::string&, ::Ice::Long, ::Ice::Int, const ::PerpcIce::BinaryStream&)> _response;
    };
    return begin_ReadKvmBootData(__p_threadIndex, __p_blockIndex, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::PerpcIce::PeSession::end_ReadKvmBootData(bool& __p_isEnd, bool& __p_isSkip, ::std::string& __p_diskToken, ::Ice::Long& __p_LBA, ::Ice::Int& __p_dwSectorCount, ::PerpcIce::BinaryStream& __p_data, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __PerpcIce__PeSession__ReadKvmBootData_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_isEnd);
    __is->read(__p_isSkip);
    __is->read(__p_diskToken);
    __is->read(__p_LBA);
    __is->read(__p_dwSectorCount);
    __is->read(__p_data);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::Ice::Int
IceProxy::PerpcIce::PeSession::getUesdBlockBitmap(const ::std::string& __p_token, ::Ice::Int __p_index, ::PerpcIce::BinaryStream& __p_bitmap, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__PerpcIce__PeSession__getUesdBlockBitmap_name);
    ::IceInternal::Outgoing __og(this, __PerpcIce__PeSession__getUesdBlockBitmap_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_token);
        __os->write(__p_index);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_bitmap);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeSession::begin_getUesdBlockBitmap(const ::std::string& __p_token, ::Ice::Int __p_index, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__PerpcIce__PeSession__getUesdBlockBitmap_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeSession__getUesdBlockBitmap_name, __del, __cookie);
    try
    {
        __result->prepare(__PerpcIce__PeSession__getUesdBlockBitmap_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_token);
        __os->write(__p_index);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeSession::__begin_getUesdBlockBitmap(const ::std::string& __p_token, ::Ice::Int __p_index, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int, const ::PerpcIce::BinaryStream&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int, const ::PerpcIce::BinaryStream&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::PerpcIce::PeSessionPrx __proxy = ::PerpcIce::PeSessionPrx::uncheckedCast(__result->getProxy());
            ::PerpcIce::BinaryStream __p_bitmap;
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_getUesdBlockBitmap(__p_bitmap, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_bitmap);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int, const ::PerpcIce::BinaryStream&)> _response;
    };
    return begin_getUesdBlockBitmap(__p_token, __p_index, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::PerpcIce::PeSession::end_getUesdBlockBitmap(::PerpcIce::BinaryStream& __p_bitmap, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __PerpcIce__PeSession__getUesdBlockBitmap_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_bitmap);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::PerpcIce::PeSession::Refresh(const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __PerpcIce__PeSession__Refresh_name, ::Ice::Idempotent, __ctx);
    __og.writeEmptyParams();
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeSession::begin_Refresh(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeSession__Refresh_name, __del, __cookie);
    try
    {
        __result->prepare(__PerpcIce__PeSession__Refresh_name, ::Ice::Idempotent, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::PerpcIce::PeSession::end_Refresh(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __PerpcIce__PeSession__Refresh_name);
}

void
IceProxy::PerpcIce::PeSession::StartKvm(const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __PerpcIce__PeSession__StartKvm_name, ::Ice::Normal, __ctx);
    __og.writeEmptyParams();
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeSession::begin_StartKvm(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeSession__StartKvm_name, __del, __cookie);
    try
    {
        __result->prepare(__PerpcIce__PeSession__StartKvm_name, ::Ice::Normal, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::PerpcIce::PeSession::end_StartKvm(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __PerpcIce__PeSession__StartKvm_name);
}

void
IceProxy::PerpcIce::PeSession::destroy(const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __PerpcIce__PeSession__destroy_name, ::Ice::Normal, __ctx);
    __og.writeEmptyParams();
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeSession::begin_destroy(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeSession__destroy_name, __del, __cookie);
    try
    {
        __result->prepare(__PerpcIce__PeSession__destroy_name, ::Ice::Normal, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::PerpcIce::PeSession::end_destroy(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __PerpcIce__PeSession__destroy_name);
}

const ::std::string&
IceProxy::PerpcIce::PeSession::ice_staticId()
{
    return ::PerpcIce::PeSession::ice_staticId();
}

::IceProxy::Ice::Object*
IceProxy::PerpcIce::PeSession::__newInstance() const
{
    return new PeSession;
}
::IceProxy::Ice::Object* ::IceProxy::PerpcIce::upCast(::IceProxy::PerpcIce::PeSessionFactory* p) { return p; }

void
::IceProxy::PerpcIce::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::PerpcIce::PeSessionFactory>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::PerpcIce::PeSessionFactory;
        v->__copyFrom(proxy);
    }
}

::PerpcIce::PeSessionPrx
IceProxy::PerpcIce::PeSessionFactory::CreateSession(const ::PerpcIce::PeGuestInfo& __p_guestInfo, ::Ice::Int __p_kvmSocketCount, const IceUtil::Optional< ::std::string>& __p_moreInfo, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__PerpcIce__PeSessionFactory__CreateSession_name);
    ::IceInternal::Outgoing __og(this, __PerpcIce__PeSessionFactory__CreateSession_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_guestInfo);
        __os->write(__p_kvmSocketCount);
        __os->write(1, __p_moreInfo);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::PerpcIce::PeSessionPrx __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeSessionFactory::begin_CreateSession(const ::PerpcIce::PeGuestInfo& __p_guestInfo, ::Ice::Int __p_kvmSocketCount, const IceUtil::Optional< ::std::string>& __p_moreInfo, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__PerpcIce__PeSessionFactory__CreateSession_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeSessionFactory__CreateSession_name, __del, __cookie);
    try
    {
        __result->prepare(__PerpcIce__PeSessionFactory__CreateSession_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_guestInfo);
        __os->write(__p_kvmSocketCount);
        __os->write(1, __p_moreInfo);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeSessionFactory::__begin_CreateSession(const ::PerpcIce::PeGuestInfo& __p_guestInfo, ::Ice::Int __p_kvmSocketCount, const IceUtil::Optional< ::std::string>& __p_moreInfo, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::PerpcIce::PeSessionPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::PerpcIce::PeSessionPrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::PerpcIce::PeSessionFactoryPrx __proxy = ::PerpcIce::PeSessionFactoryPrx::uncheckedCast(__result->getProxy());
            ::PerpcIce::PeSessionPrx __ret;
            try
            {
                __ret = __proxy->end_CreateSession(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::PerpcIce::PeSessionPrx&)> _response;
    };
    return begin_CreateSession(__p_guestInfo, __p_kvmSocketCount, __p_moreInfo, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::PerpcIce::PeSessionPrx
IceProxy::PerpcIce::PeSessionFactory::end_CreateSession(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __PerpcIce__PeSessionFactory__CreateSession_name);
    ::PerpcIce::PeSessionPrx __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

const ::std::string&
IceProxy::PerpcIce::PeSessionFactory::ice_staticId()
{
    return ::PerpcIce::PeSessionFactory::ice_staticId();
}

::IceProxy::Ice::Object*
IceProxy::PerpcIce::PeSessionFactory::__newInstance() const
{
    return new PeSessionFactory;
}

::Ice::Object* PerpcIce::upCast(::PerpcIce::PeGuestReceiver* p) { return p; }

namespace
{
const ::std::string __PerpcIce__PeGuestReceiver_ids[2] =
{
    "::Ice::Object",
    "::PerpcIce::PeGuestReceiver"
};

}

bool
PerpcIce::PeGuestReceiver::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__PerpcIce__PeGuestReceiver_ids, __PerpcIce__PeGuestReceiver_ids + 2, _s);
}

::std::vector< ::std::string>
PerpcIce::PeGuestReceiver::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__PerpcIce__PeGuestReceiver_ids[0], &__PerpcIce__PeGuestReceiver_ids[2]);
}

const ::std::string&
PerpcIce::PeGuestReceiver::ice_id(const ::Ice::Current&) const
{
    return __PerpcIce__PeGuestReceiver_ids[1];
}

const ::std::string&
PerpcIce::PeGuestReceiver::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::PerpcIce::PeGuestReceiver";
    return typeId;
#else
    return __PerpcIce__PeGuestReceiver_ids[1];
#endif
}

::Ice::DispatchStatus
PerpcIce::PeGuestReceiver::___ReadDisk(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_token;
    ::Ice::Long __p_LBA;
    ::Ice::Int __p_dwSectorCount;
    __is->read(__p_token);
    __is->read(__p_LBA);
    __is->read(__p_dwSectorCount);
    __inS.endReadParams();
    ::PerpcIce::BinaryStream __p_pBuf;
    try
    {
        ::Ice::Int __ret = ReadDisk(__p_token, __p_LBA, __p_dwSectorCount, __p_pBuf, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_pBuf);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
PerpcIce::PeGuestReceiver::___WriteDisk(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_token;
    ::Ice::Long __p_LBA;
    ::Ice::Int __p_dwSectorCount;
    ::PerpcIce::BinaryStream __p_pBuf;
    __is->read(__p_token);
    __is->read(__p_LBA);
    __is->read(__p_dwSectorCount);
    __is->read(__p_pBuf);
    __inS.endReadParams();
    try
    {
        ::Ice::Int __ret = WriteDisk(__p_token, __p_LBA, __p_dwSectorCount, __p_pBuf, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
PerpcIce::PeGuestReceiver::___SetRestoreExcludeInfo(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::PerpcIce::ExcludeBrokenBlocks __p_brokenBlocks;
    ::PerpcIce::ExcludeBlockRuns __p_blockRuns;
    __is->read(__p_brokenBlocks);
    __is->read(__p_blockRuns);
    __inS.endReadParams();
    try
    {
        SetRestoreExcludeInfo(__p_brokenBlocks, __p_blockRuns, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
PerpcIce::PeGuestReceiver::___KvmEnd(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    try
    {
        KvmEnd(__current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
PerpcIce::PeGuestReceiver::___GetClassHWInfo(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_classname;
    ::Ice::Int __p_requestParentLevel;
    __is->read(__p_classname);
    __is->read(__p_requestParentLevel);
    __inS.endReadParams();
    ::PerpcIce::HWInfos __p_hwinfo;
    try
    {
        ::Ice::Int __ret = GetClassHWInfo(__p_classname, __p_requestParentLevel, __p_hwinfo, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hwinfo);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
PerpcIce::PeGuestReceiver::___GetNetAdapterInfo(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::PerpcIce::NetAdapterInfos __p_adapterInfos;
    try
    {
        ::Ice::Int __ret = GetNetAdapterInfo(__p_adapterInfos, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_adapterInfos);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
PerpcIce::PeGuestReceiver::___SetRestoreInfo(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::PerpcIce::PeRestoreInfo __p_restoreInfo;
    __is->read(__p_restoreInfo);
    __inS.endReadParams();
    try
    {
        SetRestoreInfo(__p_restoreInfo, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
PerpcIce::PeGuestReceiver::___JsonFunc(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_inputJson;
    ::PerpcIce::BinaryStream __p_inputBs;
    __is->read(__p_inputJson);
    __is->read(__p_inputBs);
    __inS.endReadParams();
    ::PerpcIce::BinaryStream __p_outputBs;
    try
    {
        ::std::string __ret = JsonFunc(__p_inputJson, __p_inputBs, __p_outputBs, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_outputBs);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __PerpcIce__PeGuestReceiver_all[] =
{
    "GetClassHWInfo",
    "GetNetAdapterInfo",
    "JsonFunc",
    "KvmEnd",
    "ReadDisk",
    "SetRestoreExcludeInfo",
    "SetRestoreInfo",
    "WriteDisk",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
PerpcIce::PeGuestReceiver::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__PerpcIce__PeGuestReceiver_all, __PerpcIce__PeGuestReceiver_all + 12, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __PerpcIce__PeGuestReceiver_all)
    {
        case 0:
        {
            return ___GetClassHWInfo(in, current);
        }
        case 1:
        {
            return ___GetNetAdapterInfo(in, current);
        }
        case 2:
        {
            return ___JsonFunc(in, current);
        }
        case 3:
        {
            return ___KvmEnd(in, current);
        }
        case 4:
        {
            return ___ReadDisk(in, current);
        }
        case 5:
        {
            return ___SetRestoreExcludeInfo(in, current);
        }
        case 6:
        {
            return ___SetRestoreInfo(in, current);
        }
        case 7:
        {
            return ___WriteDisk(in, current);
        }
        case 8:
        {
            return ___ice_id(in, current);
        }
        case 9:
        {
            return ___ice_ids(in, current);
        }
        case 10:
        {
            return ___ice_isA(in, current);
        }
        case 11:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
PerpcIce::PeGuestReceiver::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
PerpcIce::PeGuestReceiver::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
PerpcIce::__patch(PeGuestReceiverPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::PerpcIce::PeGuestReceiverPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::PerpcIce::PeGuestReceiver::ice_staticId(), v);
    }
}

::Ice::Object* PerpcIce::upCast(::PerpcIce::PeSession* p) { return p; }

namespace
{
const ::std::string __PerpcIce__PeSession_ids[2] =
{
    "::Ice::Object",
    "::PerpcIce::PeSession"
};

}

bool
PerpcIce::PeSession::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__PerpcIce__PeSession_ids, __PerpcIce__PeSession_ids + 2, _s);
}

::std::vector< ::std::string>
PerpcIce::PeSession::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__PerpcIce__PeSession_ids[0], &__PerpcIce__PeSession_ids[2]);
}

const ::std::string&
PerpcIce::PeSession::ice_id(const ::Ice::Current&) const
{
    return __PerpcIce__PeSession_ids[1];
}

const ::std::string&
PerpcIce::PeSession::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::PerpcIce::PeSession";
    return typeId;
#else
    return __PerpcIce__PeSession_ids[1];
#endif
}

::Ice::DispatchStatus
PerpcIce::PeSession::___InitiatePeReceiver(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Identity __p_ident;
    __is->read(__p_ident);
    __inS.endReadParams();
    try
    {
        InitiatePeReceiver(__p_ident, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
PerpcIce::PeSession::___GetPeHostIdent(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::std::string __p_peHostIdent;
    GetPeHostIdent(__p_peHostIdent, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__p_peHostIdent);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
PerpcIce::PeSession::___UnInit(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int __p_dwStatus;
    __is->read(__p_dwStatus);
    __inS.endReadParams();
    UnInit(__p_dwStatus, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
PerpcIce::PeSession::___GetBootList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int __p_index;
    __is->read(__p_index);
    __inS.endReadParams();
    ::std::string __p_bootlist;
    try
    {
        ::Ice::Int __ret = GetBootList(__p_index, __p_bootlist, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_bootlist);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::NeedRetryLaterError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
PerpcIce::PeSession::___GetKvmBitmapFile(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int __p_index;
    __is->read(__p_index);
    __inS.endReadParams();
    ::PerpcIce::BinaryStream __p_data;
    try
    {
        ::Ice::Int __ret = GetKvmBitmapFile(__p_index, __p_data, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_data);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::NeedRetryLaterError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
PerpcIce::PeSession::___ReadDiskData(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_token;
    ::Ice::Long __p_LBA;
    ::Ice::Int __p_dwSectorCount;
    __is->read(__p_token);
    __is->read(__p_LBA);
    __is->read(__p_dwSectorCount);
    __inS.endReadParams();
    ::PerpcIce::BinaryStream __p_pBuf;
    try
    {
        ::Ice::Int __ret = ReadDiskData(__p_token, __p_LBA, __p_dwSectorCount, __p_pBuf, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_pBuf);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
PerpcIce::PeSession::___ReadKvmBootData(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int __p_threadIndex;
    ::Ice::Int __p_blockIndex;
    __is->read(__p_threadIndex);
    __is->read(__p_blockIndex);
    __inS.endReadParams();
    bool __p_isEnd;
    bool __p_isSkip;
    ::std::string __p_diskToken;
    ::Ice::Long __p_LBA;
    ::Ice::Int __p_dwSectorCount;
    ::PerpcIce::BinaryStream __p_data;
    try
    {
        ::Ice::Int __ret = ReadKvmBootData(__p_threadIndex, __p_blockIndex, __p_isEnd, __p_isSkip, __p_diskToken, __p_LBA, __p_dwSectorCount, __p_data, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_isEnd);
        __os->write(__p_isSkip);
        __os->write(__p_diskToken);
        __os->write(__p_LBA);
        __os->write(__p_dwSectorCount);
        __os->write(__p_data);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
PerpcIce::PeSession::___getUesdBlockBitmap(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_token;
    ::Ice::Int __p_index;
    __is->read(__p_token);
    __is->read(__p_index);
    __inS.endReadParams();
    ::PerpcIce::BinaryStream __p_bitmap;
    try
    {
        ::Ice::Int __ret = getUesdBlockBitmap(__p_token, __p_index, __p_bitmap, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_bitmap);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
PerpcIce::PeSession::___Refresh(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    Refresh(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
PerpcIce::PeSession::___StartKvm(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    StartKvm(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
PerpcIce::PeSession::___destroy(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    destroy(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __PerpcIce__PeSession_all[] =
{
    "GetBootList",
    "GetKvmBitmapFile",
    "GetPeHostIdent",
    "InitiatePeReceiver",
    "ReadDiskData",
    "ReadKvmBootData",
    "Refresh",
    "StartKvm",
    "UnInit",
    "destroy",
    "getUesdBlockBitmap",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
PerpcIce::PeSession::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__PerpcIce__PeSession_all, __PerpcIce__PeSession_all + 15, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __PerpcIce__PeSession_all)
    {
        case 0:
        {
            return ___GetBootList(in, current);
        }
        case 1:
        {
            return ___GetKvmBitmapFile(in, current);
        }
        case 2:
        {
            return ___GetPeHostIdent(in, current);
        }
        case 3:
        {
            return ___InitiatePeReceiver(in, current);
        }
        case 4:
        {
            return ___ReadDiskData(in, current);
        }
        case 5:
        {
            return ___ReadKvmBootData(in, current);
        }
        case 6:
        {
            return ___Refresh(in, current);
        }
        case 7:
        {
            return ___StartKvm(in, current);
        }
        case 8:
        {
            return ___UnInit(in, current);
        }
        case 9:
        {
            return ___destroy(in, current);
        }
        case 10:
        {
            return ___getUesdBlockBitmap(in, current);
        }
        case 11:
        {
            return ___ice_id(in, current);
        }
        case 12:
        {
            return ___ice_ids(in, current);
        }
        case 13:
        {
            return ___ice_isA(in, current);
        }
        case 14:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
PerpcIce::PeSession::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
PerpcIce::PeSession::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
PerpcIce::__patch(PeSessionPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::PerpcIce::PeSessionPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::PerpcIce::PeSession::ice_staticId(), v);
    }
}

::Ice::Object* PerpcIce::upCast(::PerpcIce::PeSessionFactory* p) { return p; }

namespace
{
const ::std::string __PerpcIce__PeSessionFactory_ids[2] =
{
    "::Ice::Object",
    "::PerpcIce::PeSessionFactory"
};

}

bool
PerpcIce::PeSessionFactory::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__PerpcIce__PeSessionFactory_ids, __PerpcIce__PeSessionFactory_ids + 2, _s);
}

::std::vector< ::std::string>
PerpcIce::PeSessionFactory::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__PerpcIce__PeSessionFactory_ids[0], &__PerpcIce__PeSessionFactory_ids[2]);
}

const ::std::string&
PerpcIce::PeSessionFactory::ice_id(const ::Ice::Current&) const
{
    return __PerpcIce__PeSessionFactory_ids[1];
}

const ::std::string&
PerpcIce::PeSessionFactory::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::PerpcIce::PeSessionFactory";
    return typeId;
#else
    return __PerpcIce__PeSessionFactory_ids[1];
#endif
}

::Ice::DispatchStatus
PerpcIce::PeSessionFactory::___CreateSession(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::PerpcIce::PeGuestInfo __p_guestInfo;
    ::Ice::Int __p_kvmSocketCount;
    IceUtil::Optional< ::std::string> __p_moreInfo;
    __is->read(__p_guestInfo);
    __is->read(__p_kvmSocketCount);
    __is->read(1, __p_moreInfo);
    __inS.endReadParams();
    try
    {
        ::PerpcIce::PeSessionPrx __ret = CreateSession(__p_guestInfo, __p_kvmSocketCount, __p_moreInfo, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __PerpcIce__PeSessionFactory_all[] =
{
    "CreateSession",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
PerpcIce::PeSessionFactory::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__PerpcIce__PeSessionFactory_all, __PerpcIce__PeSessionFactory_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __PerpcIce__PeSessionFactory_all)
    {
        case 0:
        {
            return ___CreateSession(in, current);
        }
        case 1:
        {
            return ___ice_id(in, current);
        }
        case 2:
        {
            return ___ice_ids(in, current);
        }
        case 3:
        {
            return ___ice_isA(in, current);
        }
        case 4:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
PerpcIce::PeSessionFactory::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
PerpcIce::PeSessionFactory::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
PerpcIce::__patch(PeSessionFactoryPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::PerpcIce::PeSessionFactoryPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::PerpcIce::PeSessionFactory::ice_staticId(), v);
    }
}
