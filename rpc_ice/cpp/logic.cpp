// **********************************************************************
//
// Copyright (c) 2003-2015 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.6.1
//
// <auto-generated>
//
// Generated from file `logic.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <logic.h>
#include <IceUtil/PushDisableWarnings.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/BasicStream.h>
#include <IceUtil/Iterator.h>
#include <IceUtil/PopDisableWarnings.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 306
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace
{

const ::std::string __BoxLogic__Logic__ping_name = "ping";

const ::std::string __BoxLogic__Logic__queryHostName_name = "queryHostName";

const ::std::string __BoxLogic__Logic__login_name = "login";

const ::std::string __BoxLogic__Logic__logout_name = "logout";

const ::std::string __BoxLogic__Logic__queryHostSoftIdent_name = "queryHostSoftIdent";

const ::std::string __BoxLogic__Logic__reportAgentModuleError_name = "reportAgentModuleError";

const ::std::string __BoxLogic__Logic__reportBackupProgress_name = "reportBackupProgress";

const ::std::string __BoxLogic__Logic__reportBackupFinish_name = "reportBackupFinish";

const ::std::string __BoxLogic__Logic__reportVolumeRestoreStatus_name = "reportVolumeRestoreStatus";

const ::std::string __BoxLogic__Logic__clearAllHostSession_name = "clearAllHostSession";

const ::std::string __BoxLogic__Logic__peLogin_name = "peLogin";

const ::std::string __BoxLogic__Logic__peLogout_name = "peLogout";

const ::std::string __BoxLogic__Logic__updateCDPToken_name = "updateCDPToken";

const ::std::string __BoxLogic__Logic__updateTrafficControl_name = "updateTrafficControl";

const ::std::string __BoxLogic__Logic__updateRestoreToken_name = "updateRestoreToken";

const ::std::string __BoxLogic__Logic__closeCDPToken_name = "closeCDPToken";

const ::std::string __BoxLogic__Logic__refreshSnapshotToken_name = "refreshSnapshotToken";

const ::std::string __BoxLogic__Logic__reportRestoreStatus_name = "reportRestoreStatus";

const ::std::string __BoxLogic__Logic__QueryJsonData_name = "QueryJsonData";

const ::std::string __BoxLogic__Logic__startKvm_name = "startKvm";

const ::std::string __BoxLogic__Logic__fetchProxyEndPoints_name = "fetchProxyEndPoints";

const ::std::string __BoxLogic__Logic__queryLastCdpDetailByRestoreToken_name = "queryLastCdpDetailByRestoreToken";

const ::std::string __BoxLogic__Logic__queryLastCdpDetailByCdpToken_name = "queryLastCdpDetailByCdpToken";

const ::std::string __BoxLogic__Logic__queryNetworkTransmissionType_name = "queryNetworkTransmissionType";

const ::std::string __BoxLogic__Logic__dataQueuingReport_name = "dataQueuingReport";

const ::std::string __BoxLogic__Logic__getHashFilePathByRestoreToken_name = "getHashFilePathByRestoreToken";

const ::std::string __BoxLogic__Logic__VmwareAgentReport_name = "VmwareAgentReport";

const ::std::string __BoxLogic__LogicInternal__pathJoin_name = "pathJoin";

const ::std::string __BoxLogic__LogicInternal__isFileExist_name = "isFileExist";

const ::std::string __BoxLogic__LogicInternal__AllFilesExist_name = "AllFilesExist";

const ::std::string __BoxLogic__LogicInternal__isFolderExist_name = "isFolderExist";

const ::std::string __BoxLogic__LogicInternal__makeDirs_name = "makeDirs";

const ::std::string __BoxLogic__LogicInternal__remove_name = "remove";

const ::std::string __BoxLogic__LogicInternal__copy_name = "copy";

const ::std::string __BoxLogic__LogicInternal__findFiles_name = "findFiles";

const ::std::string __BoxLogic__LogicInternal__queryCdpTimestampRange_name = "queryCdpTimestampRange";

const ::std::string __BoxLogic__LogicInternal__queryCdpTimestamp_name = "queryCdpTimestamp";

const ::std::string __BoxLogic__LogicInternal__formatCdpTimestamp_name = "formatCdpTimestamp";

const ::std::string __BoxLogic__LogicInternal__mergeCdpFile_name = "mergeCdpFile";

const ::std::string __BoxLogic__LogicInternal__isHardwareDriverExist_name = "isHardwareDriverExist";

const ::std::string __BoxLogic__LogicInternal__GetDriversVersions_name = "GetDriversVersions";

const ::std::string __BoxLogic__LogicInternal__ChkIsSubId_name = "ChkIsSubId";

const ::std::string __BoxLogic__LogicInternal__GetDriversSubList_name = "GetDriversSubList";

const ::std::string __BoxLogic__LogicInternal__generatePeStageIso_name = "generatePeStageIso";

const ::std::string __BoxLogic__LogicInternal__runRestoreKvm_name = "runRestoreKvm";

const ::std::string __BoxLogic__LogicInternal__getCurrentNetworkInfos_name = "getCurrentNetworkInfos";

const ::std::string __BoxLogic__LogicInternal__setNetwork_name = "setNetwork";

const ::std::string __BoxLogic__LogicInternal__enumStorageNodes_name = "enumStorageNodes";

const ::std::string __BoxLogic__LogicInternal__getLocalIqn_name = "getLocalIqn";

const ::std::string __BoxLogic__LogicInternal__setLocalIqn_name = "setLocalIqn";

const ::std::string __BoxLogic__LogicInternal__setGlobalDoubleChap_name = "setGlobalDoubleChap";

const ::std::string __BoxLogic__LogicInternal__getGlobalDoubleChap_name = "getGlobalDoubleChap";

const ::std::string __BoxLogic__LogicInternal__loginExternalDevice_name = "loginExternalDevice";

const ::std::string __BoxLogic__LogicInternal__logoutExternalDevice_name = "logoutExternalDevice";

const ::std::string __BoxLogic__LogicInternal__refreshExternalDevice_name = "refreshExternalDevice";

const ::std::string __BoxLogic__LogicInternal__formatAndInitializeStorageNode_name = "formatAndInitializeStorageNode";

const ::std::string __BoxLogic__LogicInternal__mountStorageNode_name = "mountStorageNode";

const ::std::string __BoxLogic__LogicInternal__unmountStorageNode_name = "unmountStorageNode";

const ::std::string __BoxLogic__LogicInternal__runCmd_name = "runCmd";

const ::std::string __BoxLogic__LogicInternal__CmdCtrl_name = "CmdCtrl";

const ::std::string __BoxLogic__LogicInternal__setPasswd_name = "setPasswd";

const ::std::string __BoxLogic__LogicInternal__getPasswd_name = "getPasswd";

const ::std::string __BoxLogic__LogicInternal__calcClusterTime0Hash_name = "calcClusterTime0Hash";

const ::std::string __BoxLogic__LogicInternal__generateClusterDiffImages_name = "generateClusterDiffImages";

const ::std::string __BoxLogic__LogicInternal__mergeCdpFiles_name = "mergeCdpFiles";

const ::std::string __BoxLogic__LogicInternal__cutCdpFile_name = "cutCdpFile";

const ::std::string __BoxLogic__LogicInternal__getRawDiskFiles_name = "getRawDiskFiles";

const ::std::string __BoxLogic__LogicInternal__NbdFindUnusedReverse_name = "NbdFindUnusedReverse";

const ::std::string __BoxLogic__LogicInternal__NbdSetUnused_name = "NbdSetUnused";

const ::std::string __BoxLogic__LogicInternal__NbdSetUsed_name = "NbdSetUsed";

const ::std::string __BoxLogic__LogicInternal__queryTakeOverHostInfo_name = "queryTakeOverHostInfo";

const ::std::string __BoxLogic__LogicInternal__mergeQcowFile_name = "mergeQcowFile";

const ::std::string __BoxLogic__LogicInternal__startBackupOptimize_name = "startBackupOptimize";

const ::std::string __BoxLogic__LogicInternal__stopBackupOptimize_name = "stopBackupOptimize";

const ::std::string __BoxLogic__LogicInternal__mergeHashFile_name = "mergeHashFile";

const ::std::string __BoxLogic__LogicInternal__generateBitMapFromQcowFile_name = "generateBitMapFromQcowFile";

const ::std::string __BoxLogic__LogicInternal__fromMapGetQcowMaxSize_name = "fromMapGetQcowMaxSize";

const ::std::string __BoxLogic__LogicInternal__reorganizeHashFile_name = "reorganizeHashFile";

const ::std::string __BoxLogic__LogicInternal__reorganizeHashFilev2_name = "reorganizeHashFilev2";

const ::std::string __BoxLogic__LogicInternal__hash2Interval_name = "hash2Interval";

const ::std::string __BoxLogic__LogicInternal__exportSnapshot_name = "exportSnapshot";

const ::std::string __BoxLogic__LogicInternal__getAllTapeJson_name = "getAllTapeJson";

const ::std::string __BoxLogic__LogicInternal__getAllMediumxJson_name = "getAllMediumxJson";

const ::std::string __BoxLogic__LogicInternal__archiveMediaOperation_name = "archiveMediaOperation";

const ::std::string __BoxLogic__LogicInternal__getArchiveFileMetaData_name = "getArchiveFileMetaData";

const ::std::string __BoxLogic__LogicInternal__genArchiveQcowFile_name = "genArchiveQcowFile";

const ::std::string __BoxLogic__LogicInternal__fileBackup_name = "fileBackup";

const ::std::string __BoxLogic__LogicInternal__kvmRpc_name = "kvmRpc";

const ::std::string __BoxLogic__Setup__startSetup_name = "startSetup";

const ::std::string __BoxLogic__Setup__cancelSetup_name = "cancelSetup";

}

namespace Ice
{
}
::IceProxy::Ice::Object* ::IceProxy::BoxLogic::upCast(::IceProxy::BoxLogic::Logic* p) { return p; }

void
::IceProxy::BoxLogic::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::BoxLogic::Logic>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::BoxLogic::Logic;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::BoxLogic::Logic::ping(const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __BoxLogic__Logic__ping_name, ::Ice::Normal, __ctx);
    __og.writeEmptyParams();
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::begin_ping(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__Logic__ping_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__Logic__ping_name, ::Ice::Normal, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::BoxLogic::Logic::end_ping(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BoxLogic__Logic__ping_name);
}

::std::string
IceProxy::BoxLogic::Logic::queryHostName(const ::BoxLogic::AgentIdentification& __p_ident, const ::std::string& __p_info, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__Logic__queryHostName_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__Logic__queryHostName_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_ident);
        __os->write(__p_info);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::begin_queryHostName(const ::BoxLogic::AgentIdentification& __p_ident, const ::std::string& __p_info, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__Logic__queryHostName_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__Logic__queryHostName_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__Logic__queryHostName_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_ident);
        __os->write(__p_info);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::__begin_queryHostName(const ::BoxLogic::AgentIdentification& __p_ident, const ::std::string& __p_info, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_queryHostName(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_queryHostName(__p_ident, __p_info, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::BoxLogic::Logic::end_queryHostName(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__Logic__queryHostName_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

bool
IceProxy::BoxLogic::Logic::login(const ::std::string& __p_hostName, const ::std::string& __p_remoteIp, const ::std::string& __p_localIp, ::Ice::Int __p_tunnelIndex, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__Logic__login_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__Logic__login_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_remoteIp);
        __os->write(__p_localIp);
        __os->write(__p_tunnelIndex);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::begin_login(const ::std::string& __p_hostName, const ::std::string& __p_remoteIp, const ::std::string& __p_localIp, ::Ice::Int __p_tunnelIndex, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__Logic__login_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__Logic__login_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__Logic__login_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_remoteIp);
        __os->write(__p_localIp);
        __os->write(__p_tunnelIndex);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::__begin_login(const ::std::string& __p_hostName, const ::std::string& __p_remoteIp, const ::std::string& __p_localIp, ::Ice::Int __p_tunnelIndex, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
            bool __ret;
            try
            {
                __ret = __proxy->end_login(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (bool)> _response;
    };
    return begin_login(__p_hostName, __p_remoteIp, __p_localIp, __p_tunnelIndex, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::BoxLogic::Logic::end_login(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__Logic__login_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::BoxLogic::Logic::logout(const ::std::string& __p_hostName, const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __BoxLogic__Logic__logout_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::begin_logout(const ::std::string& __p_hostName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__Logic__logout_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__Logic__logout_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::BoxLogic::Logic::end_logout(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BoxLogic__Logic__logout_name);
}

::std::string
IceProxy::BoxLogic::Logic::queryHostSoftIdent(const ::std::string& __p_hostName, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__Logic__queryHostSoftIdent_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__Logic__queryHostSoftIdent_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::begin_queryHostSoftIdent(const ::std::string& __p_hostName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__Logic__queryHostSoftIdent_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__Logic__queryHostSoftIdent_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__Logic__queryHostSoftIdent_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::__begin_queryHostSoftIdent(const ::std::string& __p_hostName, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_queryHostSoftIdent(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_queryHostSoftIdent(__p_hostName, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::BoxLogic::Logic::end_queryHostSoftIdent(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__Logic__queryHostSoftIdent_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::BoxLogic::Logic::reportAgentModuleError(const ::std::string& __p_hostName, const ::BoxLogic::AgentModuleError& __p_error, const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __BoxLogic__Logic__reportAgentModuleError_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_error);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::begin_reportAgentModuleError(const ::std::string& __p_hostName, const ::BoxLogic::AgentModuleError& __p_error, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__Logic__reportAgentModuleError_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__Logic__reportAgentModuleError_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_error);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::BoxLogic::Logic::end_reportAgentModuleError(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BoxLogic__Logic__reportAgentModuleError_name);
}

void
IceProxy::BoxLogic::Logic::reportBackupProgress(const ::std::string& __p_hostName, const ::BoxLogic::BackupProgress& __p_progress, const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __BoxLogic__Logic__reportBackupProgress_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_progress);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::begin_reportBackupProgress(const ::std::string& __p_hostName, const ::BoxLogic::BackupProgress& __p_progress, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__Logic__reportBackupProgress_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__Logic__reportBackupProgress_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_progress);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::BoxLogic::Logic::end_reportBackupProgress(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BoxLogic__Logic__reportBackupProgress_name);
}

void
IceProxy::BoxLogic::Logic::reportBackupFinish(const ::std::string& __p_hostName, ::BoxLogic::BackupFinishCode __p_code, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__Logic__reportBackupFinish_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__Logic__reportBackupFinish_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_code);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::begin_reportBackupFinish(const ::std::string& __p_hostName, ::BoxLogic::BackupFinishCode __p_code, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__Logic__reportBackupFinish_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__Logic__reportBackupFinish_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__Logic__reportBackupFinish_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_code);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::__begin_reportBackupFinish(const ::std::string& __p_hostName, ::BoxLogic::BackupFinishCode __p_code, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_reportBackupFinish(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_reportBackupFinish(__p_hostName, __p_code, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::Logic::end_reportBackupFinish(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__Logic__reportBackupFinish_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::BoxLogic::Logic::reportVolumeRestoreStatus(const ::std::string& __p_peHost, ::BoxLogic::RestoreStageCode __p_code, const ::std::string& __p_msg, const ::std::string& __p_debug, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__Logic__reportVolumeRestoreStatus_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__Logic__reportVolumeRestoreStatus_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_peHost);
        __os->write(__p_code);
        __os->write(__p_msg);
        __os->write(__p_debug);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::begin_reportVolumeRestoreStatus(const ::std::string& __p_peHost, ::BoxLogic::RestoreStageCode __p_code, const ::std::string& __p_msg, const ::std::string& __p_debug, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__Logic__reportVolumeRestoreStatus_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__Logic__reportVolumeRestoreStatus_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__Logic__reportVolumeRestoreStatus_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_peHost);
        __os->write(__p_code);
        __os->write(__p_msg);
        __os->write(__p_debug);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::__begin_reportVolumeRestoreStatus(const ::std::string& __p_peHost, ::BoxLogic::RestoreStageCode __p_code, const ::std::string& __p_msg, const ::std::string& __p_debug, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_reportVolumeRestoreStatus(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_reportVolumeRestoreStatus(__p_peHost, __p_code, __p_msg, __p_debug, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::Logic::end_reportVolumeRestoreStatus(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__Logic__reportVolumeRestoreStatus_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::BoxLogic::Logic::clearAllHostSession(const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __BoxLogic__Logic__clearAllHostSession_name, ::Ice::Normal, __ctx);
    __og.writeEmptyParams();
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::begin_clearAllHostSession(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__Logic__clearAllHostSession_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__Logic__clearAllHostSession_name, ::Ice::Normal, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::BoxLogic::Logic::end_clearAllHostSession(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BoxLogic__Logic__clearAllHostSession_name);
}

::std::string
IceProxy::BoxLogic::Logic::peLogin(const ::PerpcIce::PeGuestInfo& __p_info, const ::std::string& __p_remoteIp, const ::std::string& __p_localIp, ::Ice::Int __p_tunnelIndex, const IceUtil::Optional< ::std::string>& __p_moreInfo, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__Logic__peLogin_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__Logic__peLogin_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_info);
        __os->write(__p_remoteIp);
        __os->write(__p_localIp);
        __os->write(__p_tunnelIndex);
        __os->write(1, __p_moreInfo);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::begin_peLogin(const ::PerpcIce::PeGuestInfo& __p_info, const ::std::string& __p_remoteIp, const ::std::string& __p_localIp, ::Ice::Int __p_tunnelIndex, const IceUtil::Optional< ::std::string>& __p_moreInfo, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__Logic__peLogin_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__Logic__peLogin_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__Logic__peLogin_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_info);
        __os->write(__p_remoteIp);
        __os->write(__p_localIp);
        __os->write(__p_tunnelIndex);
        __os->write(1, __p_moreInfo);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::__begin_peLogin(const ::PerpcIce::PeGuestInfo& __p_info, const ::std::string& __p_remoteIp, const ::std::string& __p_localIp, ::Ice::Int __p_tunnelIndex, const IceUtil::Optional< ::std::string>& __p_moreInfo, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_peLogin(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_peLogin(__p_info, __p_remoteIp, __p_localIp, __p_tunnelIndex, __p_moreInfo, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::BoxLogic::Logic::end_peLogin(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__Logic__peLogin_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::BoxLogic::Logic::peLogout(const ::std::string& __p_peName, const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __BoxLogic__Logic__peLogout_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_peName);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::begin_peLogout(const ::std::string& __p_peName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__Logic__peLogout_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__Logic__peLogout_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_peName);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::BoxLogic::Logic::end_peLogout(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BoxLogic__Logic__peLogout_name);
}

void
IceProxy::BoxLogic::Logic::updateCDPToken(const ::std::string& __p_token, const ::std::string& __p_lastFilePath, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__Logic__updateCDPToken_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__Logic__updateCDPToken_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_token);
        __os->write(__p_lastFilePath);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::begin_updateCDPToken(const ::std::string& __p_token, const ::std::string& __p_lastFilePath, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__Logic__updateCDPToken_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__Logic__updateCDPToken_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__Logic__updateCDPToken_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_token);
        __os->write(__p_lastFilePath);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::__begin_updateCDPToken(const ::std::string& __p_token, const ::std::string& __p_lastFilePath, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_updateCDPToken(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_updateCDPToken(__p_token, __p_lastFilePath, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::Logic::end_updateCDPToken(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__Logic__updateCDPToken_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::BoxLogic::Logic::updateTrafficControl(const ::std::string& __p_token, ::Ice::Long __p_ioSession, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__Logic__updateTrafficControl_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__Logic__updateTrafficControl_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_token);
        __os->write(__p_ioSession);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::begin_updateTrafficControl(const ::std::string& __p_token, ::Ice::Long __p_ioSession, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__Logic__updateTrafficControl_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__Logic__updateTrafficControl_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__Logic__updateTrafficControl_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_token);
        __os->write(__p_ioSession);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::__begin_updateTrafficControl(const ::std::string& __p_token, ::Ice::Long __p_ioSession, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_updateTrafficControl(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_updateTrafficControl(__p_token, __p_ioSession, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::Logic::end_updateTrafficControl(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__Logic__updateTrafficControl_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::BoxLogic::Logic::updateRestoreToken(const ::std::string& __p_updateConfig, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__Logic__updateRestoreToken_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__Logic__updateRestoreToken_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_updateConfig);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::begin_updateRestoreToken(const ::std::string& __p_updateConfig, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__Logic__updateRestoreToken_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__Logic__updateRestoreToken_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__Logic__updateRestoreToken_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_updateConfig);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::__begin_updateRestoreToken(const ::std::string& __p_updateConfig, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_updateRestoreToken(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_updateRestoreToken(__p_updateConfig, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::Logic::end_updateRestoreToken(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__Logic__updateRestoreToken_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::BoxLogic::Logic::closeCDPToken(const ::std::string& __p_token, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__Logic__closeCDPToken_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__Logic__closeCDPToken_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_token);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::begin_closeCDPToken(const ::std::string& __p_token, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__Logic__closeCDPToken_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__Logic__closeCDPToken_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__Logic__closeCDPToken_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_token);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::__begin_closeCDPToken(const ::std::string& __p_token, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_closeCDPToken(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_closeCDPToken(__p_token, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::Logic::end_closeCDPToken(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__Logic__closeCDPToken_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::BoxLogic::Logic::refreshSnapshotToken(const ::std::string& __p_token, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__Logic__refreshSnapshotToken_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__Logic__refreshSnapshotToken_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_token);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::begin_refreshSnapshotToken(const ::std::string& __p_token, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__Logic__refreshSnapshotToken_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__Logic__refreshSnapshotToken_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__Logic__refreshSnapshotToken_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_token);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::__begin_refreshSnapshotToken(const ::std::string& __p_token, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_refreshSnapshotToken(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_refreshSnapshotToken(__p_token, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::Logic::end_refreshSnapshotToken(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__Logic__refreshSnapshotToken_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::BoxLogic::Logic::reportRestoreStatus(const ::std::string& __p_token, const ::BoxLogic::RestoreProgress& __p_progress, bool __p_finished, const IceUtil::Optional< ::std::string>& __p_hostIdent, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__Logic__reportRestoreStatus_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__Logic__reportRestoreStatus_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_token);
        __os->write(__p_progress);
        __os->write(__p_finished);
        __os->write(1, __p_hostIdent);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::begin_reportRestoreStatus(const ::std::string& __p_token, const ::BoxLogic::RestoreProgress& __p_progress, bool __p_finished, const IceUtil::Optional< ::std::string>& __p_hostIdent, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__Logic__reportRestoreStatus_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__Logic__reportRestoreStatus_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__Logic__reportRestoreStatus_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_token);
        __os->write(__p_progress);
        __os->write(__p_finished);
        __os->write(1, __p_hostIdent);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::__begin_reportRestoreStatus(const ::std::string& __p_token, const ::BoxLogic::RestoreProgress& __p_progress, bool __p_finished, const IceUtil::Optional< ::std::string>& __p_hostIdent, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_reportRestoreStatus(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_reportRestoreStatus(__p_token, __p_progress, __p_finished, __p_hostIdent, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::Logic::end_reportRestoreStatus(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__Logic__reportRestoreStatus_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

::std::string
IceProxy::BoxLogic::Logic::QueryJsonData(const ::std::string& __p_hostName, const ::std::string& __p_inputJson, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__Logic__QueryJsonData_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__Logic__QueryJsonData_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_inputJson);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::begin_QueryJsonData(const ::std::string& __p_hostName, const ::std::string& __p_inputJson, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__Logic__QueryJsonData_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__Logic__QueryJsonData_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__Logic__QueryJsonData_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_inputJson);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::__begin_QueryJsonData(const ::std::string& __p_hostName, const ::std::string& __p_inputJson, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_QueryJsonData(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_QueryJsonData(__p_hostName, __p_inputJson, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::BoxLogic::Logic::end_QueryJsonData(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__Logic__QueryJsonData_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::BoxLogic::Logic::startKvm(const ::std::string& __p_peHostIdent, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__Logic__startKvm_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__Logic__startKvm_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_peHostIdent);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::begin_startKvm(const ::std::string& __p_peHostIdent, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__Logic__startKvm_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__Logic__startKvm_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__Logic__startKvm_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_peHostIdent);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::__begin_startKvm(const ::std::string& __p_peHostIdent, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_startKvm(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_startKvm(__p_peHostIdent, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::Logic::end_startKvm(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__Logic__startKvm_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::BoxLogic::Logic::fetchProxyEndPoints(const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__Logic__fetchProxyEndPoints_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__Logic__fetchProxyEndPoints_name, ::Ice::Normal, __ctx);
    __og.writeEmptyParams();
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::begin_fetchProxyEndPoints(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__Logic__fetchProxyEndPoints_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__Logic__fetchProxyEndPoints_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__Logic__fetchProxyEndPoints_name, ::Ice::Normal, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::__begin_fetchProxyEndPoints(const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_fetchProxyEndPoints(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_fetchProxyEndPoints(__ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::Logic::end_fetchProxyEndPoints(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__Logic__fetchProxyEndPoints_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

::BoxLogic::LastCdpDetail
IceProxy::BoxLogic::Logic::queryLastCdpDetailByRestoreToken(const ::std::string& __p_token, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__Logic__queryLastCdpDetailByRestoreToken_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__Logic__queryLastCdpDetailByRestoreToken_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_token);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::BoxLogic::LastCdpDetail __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::begin_queryLastCdpDetailByRestoreToken(const ::std::string& __p_token, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__Logic__queryLastCdpDetailByRestoreToken_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__Logic__queryLastCdpDetailByRestoreToken_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__Logic__queryLastCdpDetailByRestoreToken_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_token);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::__begin_queryLastCdpDetailByRestoreToken(const ::std::string& __p_token, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::BoxLogic::LastCdpDetail&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::BoxLogic::LastCdpDetail&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
            ::BoxLogic::LastCdpDetail __ret;
            try
            {
                __ret = __proxy->end_queryLastCdpDetailByRestoreToken(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::BoxLogic::LastCdpDetail&)> _response;
    };
    return begin_queryLastCdpDetailByRestoreToken(__p_token, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::BoxLogic::LastCdpDetail
IceProxy::BoxLogic::Logic::end_queryLastCdpDetailByRestoreToken(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__Logic__queryLastCdpDetailByRestoreToken_name);
    ::BoxLogic::LastCdpDetail __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

bool
IceProxy::BoxLogic::Logic::queryLastCdpDetailByCdpToken(const ::std::string& __p_token, const ::std::string& __p_hostName, ::BoxLogic::LastCdpDetail& __p_detail, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__Logic__queryLastCdpDetailByCdpToken_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__Logic__queryLastCdpDetailByCdpToken_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_token);
        __os->write(__p_hostName);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_detail);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::begin_queryLastCdpDetailByCdpToken(const ::std::string& __p_token, const ::std::string& __p_hostName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__Logic__queryLastCdpDetailByCdpToken_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__Logic__queryLastCdpDetailByCdpToken_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__Logic__queryLastCdpDetailByCdpToken_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_token);
        __os->write(__p_hostName);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::__begin_queryLastCdpDetailByCdpToken(const ::std::string& __p_token, const ::std::string& __p_hostName, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool, const ::BoxLogic::LastCdpDetail&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool, const ::BoxLogic::LastCdpDetail&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
            ::BoxLogic::LastCdpDetail __p_detail;
            bool __ret;
            try
            {
                __ret = __proxy->end_queryLastCdpDetailByCdpToken(__p_detail, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_detail);
            }
        }
    
    private:
        
        ::std::function<void (bool, const ::BoxLogic::LastCdpDetail&)> _response;
    };
    return begin_queryLastCdpDetailByCdpToken(__p_token, __p_hostName, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::BoxLogic::Logic::end_queryLastCdpDetailByCdpToken(::BoxLogic::LastCdpDetail& __p_detail, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__Logic__queryLastCdpDetailByCdpToken_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_detail);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::std::string
IceProxy::BoxLogic::Logic::queryNetworkTransmissionType(const ::std::string& __p_info, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__Logic__queryNetworkTransmissionType_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__Logic__queryNetworkTransmissionType_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_info);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::begin_queryNetworkTransmissionType(const ::std::string& __p_info, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__Logic__queryNetworkTransmissionType_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__Logic__queryNetworkTransmissionType_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__Logic__queryNetworkTransmissionType_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_info);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::__begin_queryNetworkTransmissionType(const ::std::string& __p_info, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_queryNetworkTransmissionType(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_queryNetworkTransmissionType(__p_info, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::BoxLogic::Logic::end_queryNetworkTransmissionType(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__Logic__queryNetworkTransmissionType_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::Ice::Int
IceProxy::BoxLogic::Logic::dataQueuingReport(const ::std::string& __p_jsonContent, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__Logic__dataQueuingReport_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__Logic__dataQueuingReport_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_jsonContent);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::begin_dataQueuingReport(const ::std::string& __p_jsonContent, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__Logic__dataQueuingReport_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__Logic__dataQueuingReport_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__Logic__dataQueuingReport_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_jsonContent);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::__begin_dataQueuingReport(const ::std::string& __p_jsonContent, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_dataQueuingReport(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int)> _response;
    };
    return begin_dataQueuingReport(__p_jsonContent, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::BoxLogic::Logic::end_dataQueuingReport(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__Logic__dataQueuingReport_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::std::string
IceProxy::BoxLogic::Logic::getHashFilePathByRestoreToken(const ::std::string& __p_token, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__Logic__getHashFilePathByRestoreToken_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__Logic__getHashFilePathByRestoreToken_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_token);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::begin_getHashFilePathByRestoreToken(const ::std::string& __p_token, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__Logic__getHashFilePathByRestoreToken_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__Logic__getHashFilePathByRestoreToken_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__Logic__getHashFilePathByRestoreToken_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_token);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::__begin_getHashFilePathByRestoreToken(const ::std::string& __p_token, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_getHashFilePathByRestoreToken(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_getHashFilePathByRestoreToken(__p_token, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::BoxLogic::Logic::end_getHashFilePathByRestoreToken(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__Logic__getHashFilePathByRestoreToken_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::BoxLogic::Logic::VmwareAgentReport(const ::std::string& __p_jsonContent, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__Logic__VmwareAgentReport_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__Logic__VmwareAgentReport_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_jsonContent);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::begin_VmwareAgentReport(const ::std::string& __p_jsonContent, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__Logic__VmwareAgentReport_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__Logic__VmwareAgentReport_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__Logic__VmwareAgentReport_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_jsonContent);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Logic::__begin_VmwareAgentReport(const ::std::string& __p_jsonContent, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_VmwareAgentReport(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_VmwareAgentReport(__p_jsonContent, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::Logic::end_VmwareAgentReport(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__Logic__VmwareAgentReport_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

const ::std::string&
IceProxy::BoxLogic::Logic::ice_staticId()
{
    return ::BoxLogic::Logic::ice_staticId();
}

::IceProxy::Ice::Object*
IceProxy::BoxLogic::Logic::__newInstance() const
{
    return new Logic;
}
::IceProxy::Ice::Object* ::IceProxy::BoxLogic::upCast(::IceProxy::BoxLogic::LogicInternal* p) { return p; }

void
::IceProxy::BoxLogic::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::BoxLogic::LogicInternal>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::BoxLogic::LogicInternal;
        v->__copyFrom(proxy);
    }
}

::std::string
IceProxy::BoxLogic::LogicInternal::pathJoin(const ::BoxLogic::Paths& __p_paths, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__pathJoin_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__pathJoin_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_paths);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_pathJoin(const ::BoxLogic::Paths& __p_paths, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__pathJoin_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__pathJoin_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__pathJoin_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_paths);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_pathJoin(const ::BoxLogic::Paths& __p_paths, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_pathJoin(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_pathJoin(__p_paths, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::BoxLogic::LogicInternal::end_pathJoin(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__pathJoin_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

bool
IceProxy::BoxLogic::LogicInternal::isFileExist(const ::std::string& __p_path, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__isFileExist_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__isFileExist_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_path);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_isFileExist(const ::std::string& __p_path, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__isFileExist_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__isFileExist_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__isFileExist_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_path);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_isFileExist(const ::std::string& __p_path, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            bool __ret;
            try
            {
                __ret = __proxy->end_isFileExist(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (bool)> _response;
    };
    return begin_isFileExist(__p_path, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::BoxLogic::LogicInternal::end_isFileExist(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__isFileExist_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

bool
IceProxy::BoxLogic::LogicInternal::AllFilesExist(const ::BoxLogic::Paths& __p_paths, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__AllFilesExist_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__AllFilesExist_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_paths);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_AllFilesExist(const ::BoxLogic::Paths& __p_paths, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__AllFilesExist_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__AllFilesExist_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__AllFilesExist_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_paths);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_AllFilesExist(const ::BoxLogic::Paths& __p_paths, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            bool __ret;
            try
            {
                __ret = __proxy->end_AllFilesExist(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (bool)> _response;
    };
    return begin_AllFilesExist(__p_paths, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::BoxLogic::LogicInternal::end_AllFilesExist(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__AllFilesExist_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

bool
IceProxy::BoxLogic::LogicInternal::isFolderExist(const ::std::string& __p_path, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__isFolderExist_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__isFolderExist_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_path);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_isFolderExist(const ::std::string& __p_path, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__isFolderExist_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__isFolderExist_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__isFolderExist_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_path);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_isFolderExist(const ::std::string& __p_path, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            bool __ret;
            try
            {
                __ret = __proxy->end_isFolderExist(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (bool)> _response;
    };
    return begin_isFolderExist(__p_path, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::BoxLogic::LogicInternal::end_isFolderExist(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__isFolderExist_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::BoxLogic::LogicInternal::makeDirs(const ::std::string& __p_path, bool __p_existOk, ::Ice::Short __p_mode, const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__makeDirs_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_path);
        __os->write(__p_existOk);
        __os->write(__p_mode);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_makeDirs(const ::std::string& __p_path, bool __p_existOk, ::Ice::Short __p_mode, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__makeDirs_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__makeDirs_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_path);
        __os->write(__p_existOk);
        __os->write(__p_mode);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::BoxLogic::LogicInternal::end_makeDirs(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BoxLogic__LogicInternal__makeDirs_name);
}

void
IceProxy::BoxLogic::LogicInternal::remove(const ::std::string& __p_path, const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__remove_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_path);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_remove(const ::std::string& __p_path, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__remove_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__remove_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_path);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::BoxLogic::LogicInternal::end_remove(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __BoxLogic__LogicInternal__remove_name);
}

void
IceProxy::BoxLogic::LogicInternal::copy(const ::std::string& __p_params, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__copy_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__copy_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_params);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_copy(const ::std::string& __p_params, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__copy_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__copy_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__copy_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_params);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_copy(const ::std::string& __p_params, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_copy(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_copy(__p_params, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::LogicInternal::end_copy(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__copy_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::BoxLogic::LogicInternal::findFiles(const ::std::string& __p_params, ::BoxLogic::Paths& __p_paths, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__findFiles_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__findFiles_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_params);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_paths);
    __og.endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_findFiles(const ::std::string& __p_params, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__findFiles_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__findFiles_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__findFiles_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_params);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_findFiles(const ::std::string& __p_params, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::BoxLogic::Paths&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::BoxLogic::Paths&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            ::BoxLogic::Paths __p_paths;
            try
            {
                __proxy->end_findFiles(__p_paths, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__p_paths);
            }
        }
    
    private:
        
        ::std::function<void (const ::BoxLogic::Paths&)> _response;
    };
    return begin_findFiles(__p_params, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::LogicInternal::end_findFiles(::BoxLogic::Paths& __p_paths, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__findFiles_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_paths);
    __result->__endReadParams();
}

::std::string
IceProxy::BoxLogic::LogicInternal::queryCdpTimestampRange(const ::std::string& __p_path, bool __p_discardDirtyData, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__queryCdpTimestampRange_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__queryCdpTimestampRange_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_path);
        __os->write(__p_discardDirtyData);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_queryCdpTimestampRange(const ::std::string& __p_path, bool __p_discardDirtyData, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__queryCdpTimestampRange_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__queryCdpTimestampRange_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__queryCdpTimestampRange_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_path);
        __os->write(__p_discardDirtyData);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_queryCdpTimestampRange(const ::std::string& __p_path, bool __p_discardDirtyData, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_queryCdpTimestampRange(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_queryCdpTimestampRange(__p_path, __p_discardDirtyData, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::BoxLogic::LogicInternal::end_queryCdpTimestampRange(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__queryCdpTimestampRange_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::std::string
IceProxy::BoxLogic::LogicInternal::queryCdpTimestamp(const ::std::string& __p_path, const ::std::string& __p_timestamp, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__queryCdpTimestamp_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__queryCdpTimestamp_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_path);
        __os->write(__p_timestamp);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_queryCdpTimestamp(const ::std::string& __p_path, const ::std::string& __p_timestamp, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__queryCdpTimestamp_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__queryCdpTimestamp_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__queryCdpTimestamp_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_path);
        __os->write(__p_timestamp);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_queryCdpTimestamp(const ::std::string& __p_path, const ::std::string& __p_timestamp, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_queryCdpTimestamp(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_queryCdpTimestamp(__p_path, __p_timestamp, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::BoxLogic::LogicInternal::end_queryCdpTimestamp(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__queryCdpTimestamp_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::std::string
IceProxy::BoxLogic::LogicInternal::formatCdpTimestamp(const ::std::string& __p_timestamp, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__formatCdpTimestamp_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__formatCdpTimestamp_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_timestamp);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_formatCdpTimestamp(const ::std::string& __p_timestamp, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__formatCdpTimestamp_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__formatCdpTimestamp_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__formatCdpTimestamp_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_timestamp);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_formatCdpTimestamp(const ::std::string& __p_timestamp, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_formatCdpTimestamp(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_formatCdpTimestamp(__p_timestamp, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::BoxLogic::LogicInternal::end_formatCdpTimestamp(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__formatCdpTimestamp_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::BoxLogic::LogicInternal::mergeCdpFile(const ::std::string& __p_params, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__mergeCdpFile_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__mergeCdpFile_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_params);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_mergeCdpFile(const ::std::string& __p_params, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__mergeCdpFile_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__mergeCdpFile_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__mergeCdpFile_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_params);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_mergeCdpFile(const ::std::string& __p_params, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_mergeCdpFile(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_mergeCdpFile(__p_params, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::LogicInternal::end_mergeCdpFile(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__mergeCdpFile_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

bool
IceProxy::BoxLogic::LogicInternal::isHardwareDriverExist(const ::BoxLogic::Hardware& __p_hardware, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__isHardwareDriverExist_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__isHardwareDriverExist_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hardware);
        __os->write(__p_osType);
        __os->write(__p_osBit);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_isHardwareDriverExist(const ::BoxLogic::Hardware& __p_hardware, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__isHardwareDriverExist_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__isHardwareDriverExist_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__isHardwareDriverExist_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hardware);
        __os->write(__p_osType);
        __os->write(__p_osBit);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_isHardwareDriverExist(const ::BoxLogic::Hardware& __p_hardware, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            bool __ret;
            try
            {
                __ret = __proxy->end_isHardwareDriverExist(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (bool)> _response;
    };
    return begin_isHardwareDriverExist(__p_hardware, __p_osType, __p_osBit, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::BoxLogic::LogicInternal::end_isHardwareDriverExist(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__isHardwareDriverExist_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::std::string
IceProxy::BoxLogic::LogicInternal::GetDriversVersions(const ::BoxLogic::Hardware& __p_hardware, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__GetDriversVersions_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__GetDriversVersions_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hardware);
        __os->write(__p_osType);
        __os->write(__p_osBit);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_GetDriversVersions(const ::BoxLogic::Hardware& __p_hardware, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__GetDriversVersions_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__GetDriversVersions_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__GetDriversVersions_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hardware);
        __os->write(__p_osType);
        __os->write(__p_osBit);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_GetDriversVersions(const ::BoxLogic::Hardware& __p_hardware, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_GetDriversVersions(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_GetDriversVersions(__p_hardware, __p_osType, __p_osBit, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::BoxLogic::LogicInternal::end_GetDriversVersions(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__GetDriversVersions_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

bool
IceProxy::BoxLogic::LogicInternal::ChkIsSubId(const ::BoxLogic::Hardware& __p_hardware, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__ChkIsSubId_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__ChkIsSubId_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hardware);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_ChkIsSubId(const ::BoxLogic::Hardware& __p_hardware, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__ChkIsSubId_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__ChkIsSubId_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__ChkIsSubId_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hardware);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_ChkIsSubId(const ::BoxLogic::Hardware& __p_hardware, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            bool __ret;
            try
            {
                __ret = __proxy->end_ChkIsSubId(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (bool)> _response;
    };
    return begin_ChkIsSubId(__p_hardware, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::BoxLogic::LogicInternal::end_ChkIsSubId(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__ChkIsSubId_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::std::string
IceProxy::BoxLogic::LogicInternal::GetDriversSubList(const ::std::string& __p_userSelect, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__GetDriversSubList_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__GetDriversSubList_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_userSelect);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_GetDriversSubList(const ::std::string& __p_userSelect, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__GetDriversSubList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__GetDriversSubList_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__GetDriversSubList_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_userSelect);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_GetDriversSubList(const ::std::string& __p_userSelect, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_GetDriversSubList(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_GetDriversSubList(__p_userSelect, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::BoxLogic::LogicInternal::end_GetDriversSubList(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__GetDriversSubList_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::BoxLogic::LogicInternal::generatePeStageIso(const ::std::string& __p_isoWorkerFolderPath, const ::std::string& __p_isoFilePath, const ::BoxLogic::Hardwares& __p_hardwares, const ::BoxLogic::IPConfigs& __p_ipconfigs, const ::BoxLogic::StringList& __p_pciBusDeviceIds, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::std::string& __p_driverIds, const ::std::string& __p_jsonConfigure, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__generatePeStageIso_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__generatePeStageIso_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_isoWorkerFolderPath);
        __os->write(__p_isoFilePath);
        __os->write(__p_hardwares);
        __os->write(__p_ipconfigs);
        __os->write(__p_pciBusDeviceIds);
        __os->write(__p_osType);
        __os->write(__p_osBit);
        __os->write(__p_driverIds);
        __os->write(__p_jsonConfigure);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_generatePeStageIso(const ::std::string& __p_isoWorkerFolderPath, const ::std::string& __p_isoFilePath, const ::BoxLogic::Hardwares& __p_hardwares, const ::BoxLogic::IPConfigs& __p_ipconfigs, const ::BoxLogic::StringList& __p_pciBusDeviceIds, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::std::string& __p_driverIds, const ::std::string& __p_jsonConfigure, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__generatePeStageIso_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__generatePeStageIso_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__generatePeStageIso_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_isoWorkerFolderPath);
        __os->write(__p_isoFilePath);
        __os->write(__p_hardwares);
        __os->write(__p_ipconfigs);
        __os->write(__p_pciBusDeviceIds);
        __os->write(__p_osType);
        __os->write(__p_osBit);
        __os->write(__p_driverIds);
        __os->write(__p_jsonConfigure);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_generatePeStageIso(const ::std::string& __p_isoWorkerFolderPath, const ::std::string& __p_isoFilePath, const ::BoxLogic::Hardwares& __p_hardwares, const ::BoxLogic::IPConfigs& __p_ipconfigs, const ::BoxLogic::StringList& __p_pciBusDeviceIds, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::std::string& __p_driverIds, const ::std::string& __p_jsonConfigure, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_generatePeStageIso(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_generatePeStageIso(__p_isoWorkerFolderPath, __p_isoFilePath, __p_hardwares, __p_ipconfigs, __p_pciBusDeviceIds, __p_osType, __p_osBit, __p_driverIds, __p_jsonConfigure, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::LogicInternal::end_generatePeStageIso(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__generatePeStageIso_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

::std::string
IceProxy::BoxLogic::LogicInternal::runRestoreKvm(const ::std::string& __p_params, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__runRestoreKvm_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__runRestoreKvm_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_params);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_runRestoreKvm(const ::std::string& __p_params, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__runRestoreKvm_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__runRestoreKvm_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__runRestoreKvm_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_params);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_runRestoreKvm(const ::std::string& __p_params, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_runRestoreKvm(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_runRestoreKvm(__p_params, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::BoxLogic::LogicInternal::end_runRestoreKvm(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__runRestoreKvm_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::std::string
IceProxy::BoxLogic::LogicInternal::getCurrentNetworkInfos(const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__getCurrentNetworkInfos_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__getCurrentNetworkInfos_name, ::Ice::Normal, __ctx);
    __og.writeEmptyParams();
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_getCurrentNetworkInfos(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__getCurrentNetworkInfos_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__getCurrentNetworkInfos_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__getCurrentNetworkInfos_name, ::Ice::Normal, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_getCurrentNetworkInfos(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_getCurrentNetworkInfos(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_getCurrentNetworkInfos(__ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::BoxLogic::LogicInternal::end_getCurrentNetworkInfos(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__getCurrentNetworkInfos_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::BoxLogic::LogicInternal::setNetwork(const ::std::string& __p_setting, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__setNetwork_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__setNetwork_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_setting);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_setNetwork(const ::std::string& __p_setting, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__setNetwork_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__setNetwork_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__setNetwork_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_setting);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_setNetwork(const ::std::string& __p_setting, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_setNetwork(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_setNetwork(__p_setting, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::LogicInternal::end_setNetwork(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__setNetwork_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

::std::string
IceProxy::BoxLogic::LogicInternal::enumStorageNodes(const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__enumStorageNodes_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__enumStorageNodes_name, ::Ice::Normal, __ctx);
    __og.writeEmptyParams();
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_enumStorageNodes(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__enumStorageNodes_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__enumStorageNodes_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__enumStorageNodes_name, ::Ice::Normal, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_enumStorageNodes(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_enumStorageNodes(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_enumStorageNodes(__ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::BoxLogic::LogicInternal::end_enumStorageNodes(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__enumStorageNodes_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::std::string
IceProxy::BoxLogic::LogicInternal::getLocalIqn(const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__getLocalIqn_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__getLocalIqn_name, ::Ice::Normal, __ctx);
    __og.writeEmptyParams();
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_getLocalIqn(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__getLocalIqn_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__getLocalIqn_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__getLocalIqn_name, ::Ice::Normal, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_getLocalIqn(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_getLocalIqn(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_getLocalIqn(__ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::BoxLogic::LogicInternal::end_getLocalIqn(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__getLocalIqn_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::BoxLogic::LogicInternal::setLocalIqn(const ::std::string& __p_iqn, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__setLocalIqn_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__setLocalIqn_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_iqn);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_setLocalIqn(const ::std::string& __p_iqn, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__setLocalIqn_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__setLocalIqn_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__setLocalIqn_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_iqn);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_setLocalIqn(const ::std::string& __p_iqn, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_setLocalIqn(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_setLocalIqn(__p_iqn, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::LogicInternal::end_setLocalIqn(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__setLocalIqn_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::BoxLogic::LogicInternal::setGlobalDoubleChap(const ::std::string& __p_userName, const ::std::string& __p_password, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__setGlobalDoubleChap_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__setGlobalDoubleChap_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_userName);
        __os->write(__p_password);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_setGlobalDoubleChap(const ::std::string& __p_userName, const ::std::string& __p_password, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__setGlobalDoubleChap_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__setGlobalDoubleChap_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__setGlobalDoubleChap_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_userName);
        __os->write(__p_password);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_setGlobalDoubleChap(const ::std::string& __p_userName, const ::std::string& __p_password, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_setGlobalDoubleChap(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_setGlobalDoubleChap(__p_userName, __p_password, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::LogicInternal::end_setGlobalDoubleChap(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__setGlobalDoubleChap_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

bool
IceProxy::BoxLogic::LogicInternal::getGlobalDoubleChap(::std::string& __p_userName, ::std::string& __p_password, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__getGlobalDoubleChap_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__getGlobalDoubleChap_name, ::Ice::Normal, __ctx);
    __og.writeEmptyParams();
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_userName);
    __is->read(__p_password);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_getGlobalDoubleChap(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__getGlobalDoubleChap_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__getGlobalDoubleChap_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__getGlobalDoubleChap_name, ::Ice::Normal, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_getGlobalDoubleChap(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool, const ::std::string&, const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool, const ::std::string&, const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            ::std::string __p_userName;
            ::std::string __p_password;
            bool __ret;
            try
            {
                __ret = __proxy->end_getGlobalDoubleChap(__p_userName, __p_password, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_userName, __p_password);
            }
        }
    
    private:
        
        ::std::function<void (bool, const ::std::string&, const ::std::string&)> _response;
    };
    return begin_getGlobalDoubleChap(__ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::BoxLogic::LogicInternal::end_getGlobalDoubleChap(::std::string& __p_userName, ::std::string& __p_password, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__getGlobalDoubleChap_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_userName);
    __is->read(__p_password);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::std::string
IceProxy::BoxLogic::LogicInternal::loginExternalDevice(const ::std::string& __p_remoteIp, ::Ice::Int __p_remotePort, bool __p_useChap, const ::std::string& __p_userName, const ::std::string& __p_password, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__loginExternalDevice_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__loginExternalDevice_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_remoteIp);
        __os->write(__p_remotePort);
        __os->write(__p_useChap);
        __os->write(__p_userName);
        __os->write(__p_password);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_loginExternalDevice(const ::std::string& __p_remoteIp, ::Ice::Int __p_remotePort, bool __p_useChap, const ::std::string& __p_userName, const ::std::string& __p_password, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__loginExternalDevice_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__loginExternalDevice_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__loginExternalDevice_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_remoteIp);
        __os->write(__p_remotePort);
        __os->write(__p_useChap);
        __os->write(__p_userName);
        __os->write(__p_password);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_loginExternalDevice(const ::std::string& __p_remoteIp, ::Ice::Int __p_remotePort, bool __p_useChap, const ::std::string& __p_userName, const ::std::string& __p_password, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_loginExternalDevice(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_loginExternalDevice(__p_remoteIp, __p_remotePort, __p_useChap, __p_userName, __p_password, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::BoxLogic::LogicInternal::end_loginExternalDevice(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__loginExternalDevice_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::BoxLogic::LogicInternal::logoutExternalDevice(const ::std::string& __p_iqn, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__logoutExternalDevice_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__logoutExternalDevice_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_iqn);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_logoutExternalDevice(const ::std::string& __p_iqn, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__logoutExternalDevice_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__logoutExternalDevice_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__logoutExternalDevice_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_iqn);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_logoutExternalDevice(const ::std::string& __p_iqn, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_logoutExternalDevice(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_logoutExternalDevice(__p_iqn, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::LogicInternal::end_logoutExternalDevice(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__logoutExternalDevice_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::BoxLogic::LogicInternal::refreshExternalDevice(const ::std::string& __p_iqn, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__refreshExternalDevice_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__refreshExternalDevice_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_iqn);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_refreshExternalDevice(const ::std::string& __p_iqn, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__refreshExternalDevice_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__refreshExternalDevice_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__refreshExternalDevice_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_iqn);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_refreshExternalDevice(const ::std::string& __p_iqn, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_refreshExternalDevice(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_refreshExternalDevice(__p_iqn, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::LogicInternal::end_refreshExternalDevice(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__refreshExternalDevice_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::BoxLogic::LogicInternal::formatAndInitializeStorageNode(const ::std::string& __p_node, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__formatAndInitializeStorageNode_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__formatAndInitializeStorageNode_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_node);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_formatAndInitializeStorageNode(const ::std::string& __p_node, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__formatAndInitializeStorageNode_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__formatAndInitializeStorageNode_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__formatAndInitializeStorageNode_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_node);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_formatAndInitializeStorageNode(const ::std::string& __p_node, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_formatAndInitializeStorageNode(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_formatAndInitializeStorageNode(__p_node, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::LogicInternal::end_formatAndInitializeStorageNode(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__formatAndInitializeStorageNode_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::BoxLogic::LogicInternal::mountStorageNode(const ::std::string& __p_node, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__mountStorageNode_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__mountStorageNode_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_node);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_mountStorageNode(const ::std::string& __p_node, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__mountStorageNode_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__mountStorageNode_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__mountStorageNode_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_node);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_mountStorageNode(const ::std::string& __p_node, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_mountStorageNode(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_mountStorageNode(__p_node, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::LogicInternal::end_mountStorageNode(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__mountStorageNode_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::BoxLogic::LogicInternal::unmountStorageNode(const ::std::string& __p_node, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__unmountStorageNode_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__unmountStorageNode_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_node);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_unmountStorageNode(const ::std::string& __p_node, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__unmountStorageNode_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__unmountStorageNode_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__unmountStorageNode_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_node);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_unmountStorageNode(const ::std::string& __p_node, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_unmountStorageNode(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_unmountStorageNode(__p_node, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::LogicInternal::end_unmountStorageNode(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__unmountStorageNode_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

::Ice::Int
IceProxy::BoxLogic::LogicInternal::runCmd(const ::std::string& __p_cmd, bool __p_shell, ::BoxLogic::StringList& __p_lines, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__runCmd_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__runCmd_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_cmd);
        __os->write(__p_shell);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_lines);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_runCmd(const ::std::string& __p_cmd, bool __p_shell, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__runCmd_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__runCmd_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__runCmd_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_cmd);
        __os->write(__p_shell);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_runCmd(const ::std::string& __p_cmd, bool __p_shell, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int, const ::BoxLogic::StringList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int, const ::BoxLogic::StringList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            ::BoxLogic::StringList __p_lines;
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_runCmd(__p_lines, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_lines);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int, const ::BoxLogic::StringList&)> _response;
    };
    return begin_runCmd(__p_cmd, __p_shell, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::BoxLogic::LogicInternal::end_runCmd(::BoxLogic::StringList& __p_lines, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__runCmd_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_lines);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::std::string
IceProxy::BoxLogic::LogicInternal::CmdCtrl(const ::std::string& __p_cmdinfo, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__CmdCtrl_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__CmdCtrl_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_cmdinfo);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_CmdCtrl(const ::std::string& __p_cmdinfo, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__CmdCtrl_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__CmdCtrl_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__CmdCtrl_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_cmdinfo);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_CmdCtrl(const ::std::string& __p_cmdinfo, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_CmdCtrl(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_CmdCtrl(__p_cmdinfo, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::BoxLogic::LogicInternal::end_CmdCtrl(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__CmdCtrl_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::BoxLogic::LogicInternal::setPasswd(const ::std::string& __p_passwd, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__setPasswd_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__setPasswd_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_passwd);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_setPasswd(const ::std::string& __p_passwd, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__setPasswd_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__setPasswd_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__setPasswd_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_passwd);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_setPasswd(const ::std::string& __p_passwd, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_setPasswd(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_setPasswd(__p_passwd, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::LogicInternal::end_setPasswd(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__setPasswd_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

::std::string
IceProxy::BoxLogic::LogicInternal::getPasswd(const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__getPasswd_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__getPasswd_name, ::Ice::Normal, __ctx);
    __og.writeEmptyParams();
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_getPasswd(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__getPasswd_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__getPasswd_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__getPasswd_name, ::Ice::Normal, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_getPasswd(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_getPasswd(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_getPasswd(__ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::BoxLogic::LogicInternal::end_getPasswd(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__getPasswd_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::BoxLogic::LogicInternal::calcClusterTime0Hash(const ::std::string& __p_config, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__calcClusterTime0Hash_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__calcClusterTime0Hash_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_config);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_calcClusterTime0Hash(const ::std::string& __p_config, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__calcClusterTime0Hash_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__calcClusterTime0Hash_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__calcClusterTime0Hash_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_config);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_calcClusterTime0Hash(const ::std::string& __p_config, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_calcClusterTime0Hash(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_calcClusterTime0Hash(__p_config, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::LogicInternal::end_calcClusterTime0Hash(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__calcClusterTime0Hash_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::BoxLogic::LogicInternal::generateClusterDiffImages(const ::std::string& __p_config, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__generateClusterDiffImages_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__generateClusterDiffImages_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_config);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_generateClusterDiffImages(const ::std::string& __p_config, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__generateClusterDiffImages_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__generateClusterDiffImages_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__generateClusterDiffImages_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_config);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_generateClusterDiffImages(const ::std::string& __p_config, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_generateClusterDiffImages(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_generateClusterDiffImages(__p_config, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::LogicInternal::end_generateClusterDiffImages(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__generateClusterDiffImages_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::BoxLogic::LogicInternal::mergeCdpFiles(const ::std::string& __p_config, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__mergeCdpFiles_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__mergeCdpFiles_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_config);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_mergeCdpFiles(const ::std::string& __p_config, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__mergeCdpFiles_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__mergeCdpFiles_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__mergeCdpFiles_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_config);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_mergeCdpFiles(const ::std::string& __p_config, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_mergeCdpFiles(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_mergeCdpFiles(__p_config, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::LogicInternal::end_mergeCdpFiles(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__mergeCdpFiles_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::BoxLogic::LogicInternal::cutCdpFile(const ::std::string& __p_config, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__cutCdpFile_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__cutCdpFile_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_config);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_cutCdpFile(const ::std::string& __p_config, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__cutCdpFile_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__cutCdpFile_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__cutCdpFile_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_config);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_cutCdpFile(const ::std::string& __p_config, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_cutCdpFile(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_cutCdpFile(__p_config, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::LogicInternal::end_cutCdpFile(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__cutCdpFile_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

::Ice::Int
IceProxy::BoxLogic::LogicInternal::getRawDiskFiles(const ::std::string& __p_binpath, const ::std::string& __p_destpath, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__getRawDiskFiles_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__getRawDiskFiles_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_binpath);
        __os->write(__p_destpath);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_getRawDiskFiles(const ::std::string& __p_binpath, const ::std::string& __p_destpath, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__getRawDiskFiles_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__getRawDiskFiles_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__getRawDiskFiles_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_binpath);
        __os->write(__p_destpath);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_getRawDiskFiles(const ::std::string& __p_binpath, const ::std::string& __p_destpath, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_getRawDiskFiles(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int)> _response;
    };
    return begin_getRawDiskFiles(__p_binpath, __p_destpath, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::BoxLogic::LogicInternal::end_getRawDiskFiles(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__getRawDiskFiles_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::std::string
IceProxy::BoxLogic::LogicInternal::NbdFindUnusedReverse(const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__NbdFindUnusedReverse_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__NbdFindUnusedReverse_name, ::Ice::Normal, __ctx);
    __og.writeEmptyParams();
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_NbdFindUnusedReverse(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__NbdFindUnusedReverse_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__NbdFindUnusedReverse_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__NbdFindUnusedReverse_name, ::Ice::Normal, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_NbdFindUnusedReverse(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_NbdFindUnusedReverse(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_NbdFindUnusedReverse(__ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::BoxLogic::LogicInternal::end_NbdFindUnusedReverse(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__NbdFindUnusedReverse_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::BoxLogic::LogicInternal::NbdSetUnused(const ::std::string& __p_deviceName, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__NbdSetUnused_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__NbdSetUnused_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_deviceName);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_NbdSetUnused(const ::std::string& __p_deviceName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__NbdSetUnused_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__NbdSetUnused_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__NbdSetUnused_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_deviceName);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_NbdSetUnused(const ::std::string& __p_deviceName, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_NbdSetUnused(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_NbdSetUnused(__p_deviceName, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::LogicInternal::end_NbdSetUnused(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__NbdSetUnused_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::BoxLogic::LogicInternal::NbdSetUsed(const ::std::string& __p_deviceName, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__NbdSetUsed_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__NbdSetUsed_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_deviceName);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_NbdSetUsed(const ::std::string& __p_deviceName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__NbdSetUsed_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__NbdSetUsed_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__NbdSetUsed_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_deviceName);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_NbdSetUsed(const ::std::string& __p_deviceName, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_NbdSetUsed(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_NbdSetUsed(__p_deviceName, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::LogicInternal::end_NbdSetUsed(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__NbdSetUsed_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

::std::string
IceProxy::BoxLogic::LogicInternal::queryTakeOverHostInfo(const ::std::string& __p_queryString, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__queryTakeOverHostInfo_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__queryTakeOverHostInfo_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_queryString);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_queryTakeOverHostInfo(const ::std::string& __p_queryString, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__queryTakeOverHostInfo_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__queryTakeOverHostInfo_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__queryTakeOverHostInfo_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_queryString);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_queryTakeOverHostInfo(const ::std::string& __p_queryString, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_queryTakeOverHostInfo(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_queryTakeOverHostInfo(__p_queryString, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::BoxLogic::LogicInternal::end_queryTakeOverHostInfo(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__queryTakeOverHostInfo_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::BoxLogic::LogicInternal::mergeQcowFile(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__mergeQcowFile_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__mergeQcowFile_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_jsonInput);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_mergeQcowFile(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__mergeQcowFile_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__mergeQcowFile_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__mergeQcowFile_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_jsonInput);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_mergeQcowFile(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_mergeQcowFile(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_mergeQcowFile(__p_jsonInput, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::LogicInternal::end_mergeQcowFile(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__mergeQcowFile_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

::std::string
IceProxy::BoxLogic::LogicInternal::startBackupOptimize(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__startBackupOptimize_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__startBackupOptimize_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_jsonInput);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_startBackupOptimize(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__startBackupOptimize_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__startBackupOptimize_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__startBackupOptimize_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_jsonInput);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_startBackupOptimize(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_startBackupOptimize(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_startBackupOptimize(__p_jsonInput, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::BoxLogic::LogicInternal::end_startBackupOptimize(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__startBackupOptimize_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::BoxLogic::LogicInternal::stopBackupOptimize(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__stopBackupOptimize_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__stopBackupOptimize_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_jsonInput);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_stopBackupOptimize(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__stopBackupOptimize_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__stopBackupOptimize_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__stopBackupOptimize_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_jsonInput);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_stopBackupOptimize(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_stopBackupOptimize(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_stopBackupOptimize(__p_jsonInput, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::LogicInternal::end_stopBackupOptimize(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__stopBackupOptimize_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::BoxLogic::LogicInternal::mergeHashFile(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__mergeHashFile_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__mergeHashFile_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_jsonInput);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_mergeHashFile(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__mergeHashFile_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__mergeHashFile_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__mergeHashFile_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_jsonInput);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_mergeHashFile(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_mergeHashFile(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_mergeHashFile(__p_jsonInput, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::LogicInternal::end_mergeHashFile(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__mergeHashFile_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::BoxLogic::LogicInternal::generateBitMapFromQcowFile(const ::std::string& __p_jsonArgs, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__generateBitMapFromQcowFile_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__generateBitMapFromQcowFile_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_jsonArgs);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_generateBitMapFromQcowFile(const ::std::string& __p_jsonArgs, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__generateBitMapFromQcowFile_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__generateBitMapFromQcowFile_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__generateBitMapFromQcowFile_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_jsonArgs);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_generateBitMapFromQcowFile(const ::std::string& __p_jsonArgs, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_generateBitMapFromQcowFile(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_generateBitMapFromQcowFile(__p_jsonArgs, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::LogicInternal::end_generateBitMapFromQcowFile(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__generateBitMapFromQcowFile_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

::Ice::Long
IceProxy::BoxLogic::LogicInternal::fromMapGetQcowMaxSize(const ::std::string& __p_mapPath, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__fromMapGetQcowMaxSize_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__fromMapGetQcowMaxSize_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_mapPath);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Long __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_fromMapGetQcowMaxSize(const ::std::string& __p_mapPath, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__fromMapGetQcowMaxSize_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__fromMapGetQcowMaxSize_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__fromMapGetQcowMaxSize_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_mapPath);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_fromMapGetQcowMaxSize(const ::std::string& __p_mapPath, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Long)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            ::Ice::Long __ret;
            try
            {
                __ret = __proxy->end_fromMapGetQcowMaxSize(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Long)> _response;
    };
    return begin_fromMapGetQcowMaxSize(__p_mapPath, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Long
IceProxy::BoxLogic::LogicInternal::end_fromMapGetQcowMaxSize(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__fromMapGetQcowMaxSize_name);
    ::Ice::Long __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::BoxLogic::LogicInternal::reorganizeHashFile(const ::BoxLogic::BinaryStream& __p_bitmap, const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__reorganizeHashFile_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__reorganizeHashFile_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_bitmap);
        __os->write(__p_jsonInput);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_reorganizeHashFile(const ::BoxLogic::BinaryStream& __p_bitmap, const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__reorganizeHashFile_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__reorganizeHashFile_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__reorganizeHashFile_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_bitmap);
        __os->write(__p_jsonInput);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_reorganizeHashFile(const ::BoxLogic::BinaryStream& __p_bitmap, const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_reorganizeHashFile(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_reorganizeHashFile(__p_bitmap, __p_jsonInput, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::LogicInternal::end_reorganizeHashFile(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__reorganizeHashFile_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::BoxLogic::LogicInternal::reorganizeHashFilev2(const ::std::string& __p_bitmapPath, const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__reorganizeHashFilev2_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__reorganizeHashFilev2_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_bitmapPath);
        __os->write(__p_jsonInput);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_reorganizeHashFilev2(const ::std::string& __p_bitmapPath, const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__reorganizeHashFilev2_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__reorganizeHashFilev2_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__reorganizeHashFilev2_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_bitmapPath);
        __os->write(__p_jsonInput);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_reorganizeHashFilev2(const ::std::string& __p_bitmapPath, const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_reorganizeHashFilev2(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_reorganizeHashFilev2(__p_bitmapPath, __p_jsonInput, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::LogicInternal::end_reorganizeHashFilev2(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__reorganizeHashFilev2_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

::Ice::Long
IceProxy::BoxLogic::LogicInternal::hash2Interval(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__hash2Interval_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__hash2Interval_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_jsonInput);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Long __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_hash2Interval(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__hash2Interval_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__hash2Interval_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__hash2Interval_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_jsonInput);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_hash2Interval(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Long)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            ::Ice::Long __ret;
            try
            {
                __ret = __proxy->end_hash2Interval(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Long)> _response;
    };
    return begin_hash2Interval(__p_jsonInput, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Long
IceProxy::BoxLogic::LogicInternal::end_hash2Interval(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__hash2Interval_name);
    ::Ice::Long __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::std::string
IceProxy::BoxLogic::LogicInternal::exportSnapshot(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__exportSnapshot_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__exportSnapshot_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_jsonInput);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_exportSnapshot(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__exportSnapshot_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__exportSnapshot_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__exportSnapshot_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_jsonInput);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_exportSnapshot(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_exportSnapshot(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_exportSnapshot(__p_jsonInput, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::BoxLogic::LogicInternal::end_exportSnapshot(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__exportSnapshot_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::std::string
IceProxy::BoxLogic::LogicInternal::getAllTapeJson(const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__getAllTapeJson_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__getAllTapeJson_name, ::Ice::Normal, __ctx);
    __og.writeEmptyParams();
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_getAllTapeJson(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__getAllTapeJson_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__getAllTapeJson_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__getAllTapeJson_name, ::Ice::Normal, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_getAllTapeJson(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_getAllTapeJson(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_getAllTapeJson(__ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::BoxLogic::LogicInternal::end_getAllTapeJson(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__getAllTapeJson_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::std::string
IceProxy::BoxLogic::LogicInternal::getAllMediumxJson(const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__getAllMediumxJson_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__getAllMediumxJson_name, ::Ice::Normal, __ctx);
    __og.writeEmptyParams();
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_getAllMediumxJson(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__getAllMediumxJson_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__getAllMediumxJson_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__getAllMediumxJson_name, ::Ice::Normal, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_getAllMediumxJson(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_getAllMediumxJson(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_getAllMediumxJson(__ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::BoxLogic::LogicInternal::end_getAllMediumxJson(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__getAllMediumxJson_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::std::string
IceProxy::BoxLogic::LogicInternal::archiveMediaOperation(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__archiveMediaOperation_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__archiveMediaOperation_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_jsonInput);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_archiveMediaOperation(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__archiveMediaOperation_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__archiveMediaOperation_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__archiveMediaOperation_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_jsonInput);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_archiveMediaOperation(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_archiveMediaOperation(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_archiveMediaOperation(__p_jsonInput, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::BoxLogic::LogicInternal::end_archiveMediaOperation(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__archiveMediaOperation_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::std::string
IceProxy::BoxLogic::LogicInternal::getArchiveFileMetaData(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__getArchiveFileMetaData_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__getArchiveFileMetaData_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_jsonInput);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_getArchiveFileMetaData(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__getArchiveFileMetaData_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__getArchiveFileMetaData_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__getArchiveFileMetaData_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_jsonInput);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_getArchiveFileMetaData(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_getArchiveFileMetaData(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_getArchiveFileMetaData(__p_jsonInput, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::BoxLogic::LogicInternal::end_getArchiveFileMetaData(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__getArchiveFileMetaData_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::std::string
IceProxy::BoxLogic::LogicInternal::genArchiveQcowFile(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__genArchiveQcowFile_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__genArchiveQcowFile_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_jsonInput);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_genArchiveQcowFile(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__genArchiveQcowFile_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__genArchiveQcowFile_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__genArchiveQcowFile_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_jsonInput);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_genArchiveQcowFile(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_genArchiveQcowFile(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_genArchiveQcowFile(__p_jsonInput, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::BoxLogic::LogicInternal::end_genArchiveQcowFile(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__genArchiveQcowFile_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::std::string
IceProxy::BoxLogic::LogicInternal::fileBackup(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__fileBackup_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__fileBackup_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_jsonInput);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_fileBackup(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__fileBackup_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__fileBackup_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__fileBackup_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_jsonInput);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_fileBackup(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_fileBackup(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_fileBackup(__p_jsonInput, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::BoxLogic::LogicInternal::end_fileBackup(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__fileBackup_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::std::string
IceProxy::BoxLogic::LogicInternal::kvmRpc(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__LogicInternal__kvmRpc_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__LogicInternal__kvmRpc_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_jsonInput);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::begin_kvmRpc(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__LogicInternal__kvmRpc_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__LogicInternal__kvmRpc_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__LogicInternal__kvmRpc_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_jsonInput);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::LogicInternal::__begin_kvmRpc(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_kvmRpc(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_kvmRpc(__p_jsonInput, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::BoxLogic::LogicInternal::end_kvmRpc(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__LogicInternal__kvmRpc_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

const ::std::string&
IceProxy::BoxLogic::LogicInternal::ice_staticId()
{
    return ::BoxLogic::LogicInternal::ice_staticId();
}

::IceProxy::Ice::Object*
IceProxy::BoxLogic::LogicInternal::__newInstance() const
{
    return new LogicInternal;
}
::IceProxy::Ice::Object* ::IceProxy::BoxLogic::upCast(::IceProxy::BoxLogic::Setup* p) { return p; }

void
::IceProxy::BoxLogic::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::BoxLogic::Setup>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::BoxLogic::Setup;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::BoxLogic::Setup::startSetup(const ::std::string& __p_session, const ::std::string& __p_flagJson, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__Setup__startSetup_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__Setup__startSetup_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_session);
        __os->write(__p_flagJson);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Setup::begin_startSetup(const ::std::string& __p_session, const ::std::string& __p_flagJson, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__Setup__startSetup_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__Setup__startSetup_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__Setup__startSetup_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_session);
        __os->write(__p_flagJson);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Setup::__begin_startSetup(const ::std::string& __p_session, const ::std::string& __p_flagJson, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::SetupPrx __proxy = ::BoxLogic::SetupPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_startSetup(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_startSetup(__p_session, __p_flagJson, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::Setup::end_startSetup(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__Setup__startSetup_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::BoxLogic::Setup::cancelSetup(const ::std::string& __p_session, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__BoxLogic__Setup__cancelSetup_name);
    ::IceInternal::Outgoing __og(this, __BoxLogic__Setup__cancelSetup_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_session);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Setup::begin_cancelSetup(const ::std::string& __p_session, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__BoxLogic__Setup__cancelSetup_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __BoxLogic__Setup__cancelSetup_name, __del, __cookie);
    try
    {
        __result->prepare(__BoxLogic__Setup__cancelSetup_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_session);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::BoxLogic::Setup::__begin_cancelSetup(const ::std::string& __p_session, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::BoxLogic::SetupPrx __proxy = ::BoxLogic::SetupPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_cancelSetup(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_cancelSetup(__p_session, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::BoxLogic::Setup::end_cancelSetup(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __BoxLogic__Setup__cancelSetup_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

const ::std::string&
IceProxy::BoxLogic::Setup::ice_staticId()
{
    return ::BoxLogic::Setup::ice_staticId();
}

::IceProxy::Ice::Object*
IceProxy::BoxLogic::Setup::__newInstance() const
{
    return new Setup;
}

::Ice::Object* BoxLogic::upCast(::BoxLogic::Logic* p) { return p; }

namespace
{
const ::std::string __BoxLogic__Logic_ids[2] =
{
    "::BoxLogic::Logic",
    "::Ice::Object"
};

}

bool
BoxLogic::Logic::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__BoxLogic__Logic_ids, __BoxLogic__Logic_ids + 2, _s);
}

::std::vector< ::std::string>
BoxLogic::Logic::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__BoxLogic__Logic_ids[0], &__BoxLogic__Logic_ids[2]);
}

const ::std::string&
BoxLogic::Logic::ice_id(const ::Ice::Current&) const
{
    return __BoxLogic__Logic_ids[0];
}

const ::std::string&
BoxLogic::Logic::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::BoxLogic::Logic";
    return typeId;
#else
    return __BoxLogic__Logic_ids[0];
#endif
}

::Ice::DispatchStatus
BoxLogic::Logic::___ping(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ping(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BoxLogic::Logic::___queryHostName(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::BoxLogic::AgentIdentification __p_ident;
    ::std::string __p_info;
    __is->read(__p_ident);
    __is->read(__p_info);
    __inS.endReadParams();
    try
    {
        ::std::string __ret = queryHostName(__p_ident, __p_info, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::Logic::___login(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    ::std::string __p_remoteIp;
    ::std::string __p_localIp;
    ::Ice::Int __p_tunnelIndex;
    __is->read(__p_hostName);
    __is->read(__p_remoteIp);
    __is->read(__p_localIp);
    __is->read(__p_tunnelIndex);
    __inS.endReadParams();
    try
    {
        bool __ret = login(__p_hostName, __p_remoteIp, __p_localIp, __p_tunnelIndex, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::Logic::___logout(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    __is->read(__p_hostName);
    __inS.endReadParams();
    logout(__p_hostName, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BoxLogic::Logic::___queryHostSoftIdent(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    __is->read(__p_hostName);
    __inS.endReadParams();
    try
    {
        ::std::string __ret = queryHostSoftIdent(__p_hostName, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::Logic::___reportAgentModuleError(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    ::BoxLogic::AgentModuleError __p_error;
    __is->read(__p_hostName);
    __is->read(__p_error);
    __inS.endReadParams();
    reportAgentModuleError(__p_hostName, __p_error, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BoxLogic::Logic::___reportBackupProgress(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    ::BoxLogic::BackupProgress __p_progress;
    __is->read(__p_hostName);
    __is->read(__p_progress);
    __inS.endReadParams();
    reportBackupProgress(__p_hostName, __p_progress, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BoxLogic::Logic::___reportBackupFinish(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    ::BoxLogic::BackupFinishCode __p_code;
    __is->read(__p_hostName);
    __is->read(__p_code);
    __inS.endReadParams();
    try
    {
        reportBackupFinish(__p_hostName, __p_code, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::Logic::___reportVolumeRestoreStatus(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_peHost;
    ::BoxLogic::RestoreStageCode __p_code;
    ::std::string __p_msg;
    ::std::string __p_debug;
    __is->read(__p_peHost);
    __is->read(__p_code);
    __is->read(__p_msg);
    __is->read(__p_debug);
    __inS.endReadParams();
    try
    {
        reportVolumeRestoreStatus(__p_peHost, __p_code, __p_msg, __p_debug, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::Logic::___clearAllHostSession(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    clearAllHostSession(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BoxLogic::Logic::___peLogin(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::PerpcIce::PeGuestInfo __p_info;
    ::std::string __p_remoteIp;
    ::std::string __p_localIp;
    ::Ice::Int __p_tunnelIndex;
    IceUtil::Optional< ::std::string> __p_moreInfo;
    __is->read(__p_info);
    __is->read(__p_remoteIp);
    __is->read(__p_localIp);
    __is->read(__p_tunnelIndex);
    __is->read(1, __p_moreInfo);
    __inS.endReadParams();
    try
    {
        ::std::string __ret = peLogin(__p_info, __p_remoteIp, __p_localIp, __p_tunnelIndex, __p_moreInfo, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::Logic::___peLogout(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_peName;
    __is->read(__p_peName);
    __inS.endReadParams();
    peLogout(__p_peName, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BoxLogic::Logic::___updateCDPToken(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_token;
    ::std::string __p_lastFilePath;
    __is->read(__p_token);
    __is->read(__p_lastFilePath);
    __inS.endReadParams();
    try
    {
        updateCDPToken(__p_token, __p_lastFilePath, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::Logic::___updateTrafficControl(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_token;
    ::Ice::Long __p_ioSession;
    __is->read(__p_token);
    __is->read(__p_ioSession);
    __inS.endReadParams();
    try
    {
        updateTrafficControl(__p_token, __p_ioSession, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::Logic::___updateRestoreToken(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_updateConfig;
    __is->read(__p_updateConfig);
    __inS.endReadParams();
    try
    {
        updateRestoreToken(__p_updateConfig, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::Logic::___closeCDPToken(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_token;
    __is->read(__p_token);
    __inS.endReadParams();
    try
    {
        closeCDPToken(__p_token, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::Logic::___refreshSnapshotToken(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_token;
    __is->read(__p_token);
    __inS.endReadParams();
    try
    {
        refreshSnapshotToken(__p_token, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::Logic::___reportRestoreStatus(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_token;
    ::BoxLogic::RestoreProgress __p_progress;
    bool __p_finished;
    IceUtil::Optional< ::std::string> __p_hostIdent;
    __is->read(__p_token);
    __is->read(__p_progress);
    __is->read(__p_finished);
    __is->read(1, __p_hostIdent);
    __inS.endReadParams();
    try
    {
        reportRestoreStatus(__p_token, __p_progress, __p_finished, __p_hostIdent, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::Logic::___QueryJsonData(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    ::std::string __p_inputJson;
    __is->read(__p_hostName);
    __is->read(__p_inputJson);
    __inS.endReadParams();
    try
    {
        ::std::string __ret = QueryJsonData(__p_hostName, __p_inputJson, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::Logic::___startKvm(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_peHostIdent;
    __is->read(__p_peHostIdent);
    __inS.endReadParams();
    try
    {
        startKvm(__p_peHostIdent, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::Logic::___fetchProxyEndPoints(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    try
    {
        fetchProxyEndPoints(__current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::Logic::___queryLastCdpDetailByRestoreToken(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_token;
    __is->read(__p_token);
    __inS.endReadParams();
    try
    {
        ::BoxLogic::LastCdpDetail __ret = queryLastCdpDetailByRestoreToken(__p_token, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::Logic::___queryLastCdpDetailByCdpToken(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_token;
    ::std::string __p_hostName;
    __is->read(__p_token);
    __is->read(__p_hostName);
    __inS.endReadParams();
    ::BoxLogic::LastCdpDetail __p_detail;
    try
    {
        bool __ret = queryLastCdpDetailByCdpToken(__p_token, __p_hostName, __p_detail, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_detail);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::Logic::___queryNetworkTransmissionType(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_info;
    __is->read(__p_info);
    __inS.endReadParams();
    try
    {
        ::std::string __ret = queryNetworkTransmissionType(__p_info, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::Logic::___dataQueuingReport(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_jsonContent;
    __is->read(__p_jsonContent);
    __inS.endReadParams();
    try
    {
        ::Ice::Int __ret = dataQueuingReport(__p_jsonContent, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::Logic::___getHashFilePathByRestoreToken(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_token;
    __is->read(__p_token);
    __inS.endReadParams();
    try
    {
        ::std::string __ret = getHashFilePathByRestoreToken(__p_token, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::Logic::___VmwareAgentReport(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_jsonContent;
    __is->read(__p_jsonContent);
    __inS.endReadParams();
    try
    {
        VmwareAgentReport(__p_jsonContent, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __BoxLogic__Logic_all[] =
{
    "QueryJsonData",
    "VmwareAgentReport",
    "clearAllHostSession",
    "closeCDPToken",
    "dataQueuingReport",
    "fetchProxyEndPoints",
    "getHashFilePathByRestoreToken",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "login",
    "logout",
    "peLogin",
    "peLogout",
    "ping",
    "queryHostName",
    "queryHostSoftIdent",
    "queryLastCdpDetailByCdpToken",
    "queryLastCdpDetailByRestoreToken",
    "queryNetworkTransmissionType",
    "refreshSnapshotToken",
    "reportAgentModuleError",
    "reportBackupFinish",
    "reportBackupProgress",
    "reportRestoreStatus",
    "reportVolumeRestoreStatus",
    "startKvm",
    "updateCDPToken",
    "updateRestoreToken",
    "updateTrafficControl"
};

}

::Ice::DispatchStatus
BoxLogic::Logic::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__BoxLogic__Logic_all, __BoxLogic__Logic_all + 31, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __BoxLogic__Logic_all)
    {
        case 0:
        {
            return ___QueryJsonData(in, current);
        }
        case 1:
        {
            return ___VmwareAgentReport(in, current);
        }
        case 2:
        {
            return ___clearAllHostSession(in, current);
        }
        case 3:
        {
            return ___closeCDPToken(in, current);
        }
        case 4:
        {
            return ___dataQueuingReport(in, current);
        }
        case 5:
        {
            return ___fetchProxyEndPoints(in, current);
        }
        case 6:
        {
            return ___getHashFilePathByRestoreToken(in, current);
        }
        case 7:
        {
            return ___ice_id(in, current);
        }
        case 8:
        {
            return ___ice_ids(in, current);
        }
        case 9:
        {
            return ___ice_isA(in, current);
        }
        case 10:
        {
            return ___ice_ping(in, current);
        }
        case 11:
        {
            return ___login(in, current);
        }
        case 12:
        {
            return ___logout(in, current);
        }
        case 13:
        {
            return ___peLogin(in, current);
        }
        case 14:
        {
            return ___peLogout(in, current);
        }
        case 15:
        {
            return ___ping(in, current);
        }
        case 16:
        {
            return ___queryHostName(in, current);
        }
        case 17:
        {
            return ___queryHostSoftIdent(in, current);
        }
        case 18:
        {
            return ___queryLastCdpDetailByCdpToken(in, current);
        }
        case 19:
        {
            return ___queryLastCdpDetailByRestoreToken(in, current);
        }
        case 20:
        {
            return ___queryNetworkTransmissionType(in, current);
        }
        case 21:
        {
            return ___refreshSnapshotToken(in, current);
        }
        case 22:
        {
            return ___reportAgentModuleError(in, current);
        }
        case 23:
        {
            return ___reportBackupFinish(in, current);
        }
        case 24:
        {
            return ___reportBackupProgress(in, current);
        }
        case 25:
        {
            return ___reportRestoreStatus(in, current);
        }
        case 26:
        {
            return ___reportVolumeRestoreStatus(in, current);
        }
        case 27:
        {
            return ___startKvm(in, current);
        }
        case 28:
        {
            return ___updateCDPToken(in, current);
        }
        case 29:
        {
            return ___updateRestoreToken(in, current);
        }
        case 30:
        {
            return ___updateTrafficControl(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
BoxLogic::Logic::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
BoxLogic::Logic::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
BoxLogic::__patch(LogicPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::BoxLogic::LogicPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::BoxLogic::Logic::ice_staticId(), v);
    }
}

::Ice::Object* BoxLogic::upCast(::BoxLogic::LogicInternal* p) { return p; }

namespace
{
const ::std::string __BoxLogic__LogicInternal_ids[2] =
{
    "::BoxLogic::LogicInternal",
    "::Ice::Object"
};

}

bool
BoxLogic::LogicInternal::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__BoxLogic__LogicInternal_ids, __BoxLogic__LogicInternal_ids + 2, _s);
}

::std::vector< ::std::string>
BoxLogic::LogicInternal::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__BoxLogic__LogicInternal_ids[0], &__BoxLogic__LogicInternal_ids[2]);
}

const ::std::string&
BoxLogic::LogicInternal::ice_id(const ::Ice::Current&) const
{
    return __BoxLogic__LogicInternal_ids[0];
}

const ::std::string&
BoxLogic::LogicInternal::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::BoxLogic::LogicInternal";
    return typeId;
#else
    return __BoxLogic__LogicInternal_ids[0];
#endif
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___pathJoin(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::BoxLogic::Paths __p_paths;
    __is->read(__p_paths);
    __inS.endReadParams();
    ::std::string __ret = pathJoin(__p_paths, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___isFileExist(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_path;
    __is->read(__p_path);
    __inS.endReadParams();
    bool __ret = isFileExist(__p_path, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___AllFilesExist(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::BoxLogic::Paths __p_paths;
    __is->read(__p_paths);
    __inS.endReadParams();
    bool __ret = AllFilesExist(__p_paths, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___isFolderExist(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_path;
    __is->read(__p_path);
    __inS.endReadParams();
    bool __ret = isFolderExist(__p_path, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___makeDirs(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_path;
    bool __p_existOk;
    ::Ice::Short __p_mode;
    __is->read(__p_path);
    __is->read(__p_existOk);
    __is->read(__p_mode);
    __inS.endReadParams();
    makeDirs(__p_path, __p_existOk, __p_mode, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___remove(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_path;
    __is->read(__p_path);
    __inS.endReadParams();
    remove(__p_path, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___copy(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_params;
    __is->read(__p_params);
    __inS.endReadParams();
    try
    {
        copy(__p_params, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___findFiles(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_params;
    __is->read(__p_params);
    __inS.endReadParams();
    ::BoxLogic::Paths __p_paths;
    findFiles(__p_params, __p_paths, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__p_paths);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___queryCdpTimestampRange(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_path;
    bool __p_discardDirtyData;
    __is->read(__p_path);
    __is->read(__p_discardDirtyData);
    __inS.endReadParams();
    try
    {
        ::std::string __ret = queryCdpTimestampRange(__p_path, __p_discardDirtyData, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___queryCdpTimestamp(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_path;
    ::std::string __p_timestamp;
    __is->read(__p_path);
    __is->read(__p_timestamp);
    __inS.endReadParams();
    try
    {
        ::std::string __ret = queryCdpTimestamp(__p_path, __p_timestamp, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___formatCdpTimestamp(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_timestamp;
    __is->read(__p_timestamp);
    __inS.endReadParams();
    try
    {
        ::std::string __ret = formatCdpTimestamp(__p_timestamp, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___mergeCdpFile(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_params;
    __is->read(__p_params);
    __inS.endReadParams();
    try
    {
        mergeCdpFile(__p_params, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___isHardwareDriverExist(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::BoxLogic::Hardware __p_hardware;
    ::std::string __p_osType;
    ::std::string __p_osBit;
    __is->read(__p_hardware);
    __is->read(__p_osType);
    __is->read(__p_osBit);
    __inS.endReadParams();
    try
    {
        bool __ret = isHardwareDriverExist(__p_hardware, __p_osType, __p_osBit, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___GetDriversVersions(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::BoxLogic::Hardware __p_hardware;
    ::std::string __p_osType;
    ::std::string __p_osBit;
    __is->read(__p_hardware);
    __is->read(__p_osType);
    __is->read(__p_osBit);
    __inS.endReadParams();
    try
    {
        ::std::string __ret = GetDriversVersions(__p_hardware, __p_osType, __p_osBit, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___ChkIsSubId(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::BoxLogic::Hardware __p_hardware;
    __is->read(__p_hardware);
    __inS.endReadParams();
    try
    {
        bool __ret = ChkIsSubId(__p_hardware, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___GetDriversSubList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_userSelect;
    __is->read(__p_userSelect);
    __inS.endReadParams();
    try
    {
        ::std::string __ret = GetDriversSubList(__p_userSelect, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___generatePeStageIso(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_isoWorkerFolderPath;
    ::std::string __p_isoFilePath;
    ::BoxLogic::Hardwares __p_hardwares;
    ::BoxLogic::IPConfigs __p_ipconfigs;
    ::BoxLogic::StringList __p_pciBusDeviceIds;
    ::std::string __p_osType;
    ::std::string __p_osBit;
    ::std::string __p_driverIds;
    ::std::string __p_jsonConfigure;
    __is->read(__p_isoWorkerFolderPath);
    __is->read(__p_isoFilePath);
    __is->read(__p_hardwares);
    __is->read(__p_ipconfigs);
    __is->read(__p_pciBusDeviceIds);
    __is->read(__p_osType);
    __is->read(__p_osBit);
    __is->read(__p_driverIds);
    __is->read(__p_jsonConfigure);
    __inS.endReadParams();
    try
    {
        generatePeStageIso(__p_isoWorkerFolderPath, __p_isoFilePath, __p_hardwares, __p_ipconfigs, __p_pciBusDeviceIds, __p_osType, __p_osBit, __p_driverIds, __p_jsonConfigure, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___runRestoreKvm(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_params;
    __is->read(__p_params);
    __inS.endReadParams();
    try
    {
        ::std::string __ret = runRestoreKvm(__p_params, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___getCurrentNetworkInfos(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    try
    {
        ::std::string __ret = getCurrentNetworkInfos(__current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___setNetwork(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_setting;
    __is->read(__p_setting);
    __inS.endReadParams();
    try
    {
        setNetwork(__p_setting, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___enumStorageNodes(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    try
    {
        ::std::string __ret = enumStorageNodes(__current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___getLocalIqn(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    try
    {
        ::std::string __ret = getLocalIqn(__current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___setLocalIqn(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_iqn;
    __is->read(__p_iqn);
    __inS.endReadParams();
    try
    {
        setLocalIqn(__p_iqn, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___setGlobalDoubleChap(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_userName;
    ::std::string __p_password;
    __is->read(__p_userName);
    __is->read(__p_password);
    __inS.endReadParams();
    try
    {
        setGlobalDoubleChap(__p_userName, __p_password, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___getGlobalDoubleChap(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::std::string __p_userName;
    ::std::string __p_password;
    try
    {
        bool __ret = getGlobalDoubleChap(__p_userName, __p_password, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_userName);
        __os->write(__p_password);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___loginExternalDevice(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_remoteIp;
    ::Ice::Int __p_remotePort;
    bool __p_useChap;
    ::std::string __p_userName;
    ::std::string __p_password;
    __is->read(__p_remoteIp);
    __is->read(__p_remotePort);
    __is->read(__p_useChap);
    __is->read(__p_userName);
    __is->read(__p_password);
    __inS.endReadParams();
    try
    {
        ::std::string __ret = loginExternalDevice(__p_remoteIp, __p_remotePort, __p_useChap, __p_userName, __p_password, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___logoutExternalDevice(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_iqn;
    __is->read(__p_iqn);
    __inS.endReadParams();
    try
    {
        logoutExternalDevice(__p_iqn, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___refreshExternalDevice(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_iqn;
    __is->read(__p_iqn);
    __inS.endReadParams();
    try
    {
        refreshExternalDevice(__p_iqn, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___formatAndInitializeStorageNode(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_node;
    __is->read(__p_node);
    __inS.endReadParams();
    try
    {
        formatAndInitializeStorageNode(__p_node, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___mountStorageNode(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_node;
    __is->read(__p_node);
    __inS.endReadParams();
    try
    {
        mountStorageNode(__p_node, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___unmountStorageNode(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_node;
    __is->read(__p_node);
    __inS.endReadParams();
    try
    {
        unmountStorageNode(__p_node, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___runCmd(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_cmd;
    bool __p_shell;
    __is->read(__p_cmd);
    __is->read(__p_shell);
    __inS.endReadParams();
    ::BoxLogic::StringList __p_lines;
    try
    {
        ::Ice::Int __ret = runCmd(__p_cmd, __p_shell, __p_lines, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_lines);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___CmdCtrl(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_cmdinfo;
    __is->read(__p_cmdinfo);
    __inS.endReadParams();
    try
    {
        ::std::string __ret = CmdCtrl(__p_cmdinfo, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___setPasswd(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_passwd;
    __is->read(__p_passwd);
    __inS.endReadParams();
    try
    {
        setPasswd(__p_passwd, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___getPasswd(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    try
    {
        ::std::string __ret = getPasswd(__current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___calcClusterTime0Hash(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_config;
    __is->read(__p_config);
    __inS.endReadParams();
    try
    {
        calcClusterTime0Hash(__p_config, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___generateClusterDiffImages(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_config;
    __is->read(__p_config);
    __inS.endReadParams();
    try
    {
        generateClusterDiffImages(__p_config, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___mergeCdpFiles(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_config;
    __is->read(__p_config);
    __inS.endReadParams();
    try
    {
        mergeCdpFiles(__p_config, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___cutCdpFile(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_config;
    __is->read(__p_config);
    __inS.endReadParams();
    try
    {
        cutCdpFile(__p_config, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___getRawDiskFiles(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_binpath;
    ::std::string __p_destpath;
    __is->read(__p_binpath);
    __is->read(__p_destpath);
    __inS.endReadParams();
    try
    {
        ::Ice::Int __ret = getRawDiskFiles(__p_binpath, __p_destpath, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___NbdFindUnusedReverse(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    try
    {
        ::std::string __ret = NbdFindUnusedReverse(__current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___NbdSetUnused(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_deviceName;
    __is->read(__p_deviceName);
    __inS.endReadParams();
    try
    {
        NbdSetUnused(__p_deviceName, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___NbdSetUsed(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_deviceName;
    __is->read(__p_deviceName);
    __inS.endReadParams();
    try
    {
        NbdSetUsed(__p_deviceName, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___queryTakeOverHostInfo(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_queryString;
    __is->read(__p_queryString);
    __inS.endReadParams();
    try
    {
        ::std::string __ret = queryTakeOverHostInfo(__p_queryString, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___mergeQcowFile(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_jsonInput;
    __is->read(__p_jsonInput);
    __inS.endReadParams();
    try
    {
        mergeQcowFile(__p_jsonInput, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___startBackupOptimize(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_jsonInput;
    __is->read(__p_jsonInput);
    __inS.endReadParams();
    try
    {
        ::std::string __ret = startBackupOptimize(__p_jsonInput, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___stopBackupOptimize(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_jsonInput;
    __is->read(__p_jsonInput);
    __inS.endReadParams();
    try
    {
        stopBackupOptimize(__p_jsonInput, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___mergeHashFile(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_jsonInput;
    __is->read(__p_jsonInput);
    __inS.endReadParams();
    try
    {
        mergeHashFile(__p_jsonInput, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___generateBitMapFromQcowFile(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_jsonArgs;
    __is->read(__p_jsonArgs);
    __inS.endReadParams();
    try
    {
        generateBitMapFromQcowFile(__p_jsonArgs, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___fromMapGetQcowMaxSize(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_mapPath;
    __is->read(__p_mapPath);
    __inS.endReadParams();
    try
    {
        ::Ice::Long __ret = fromMapGetQcowMaxSize(__p_mapPath, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___reorganizeHashFile(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::BoxLogic::BinaryStream __p_bitmap;
    ::std::string __p_jsonInput;
    __is->read(__p_bitmap);
    __is->read(__p_jsonInput);
    __inS.endReadParams();
    try
    {
        reorganizeHashFile(__p_bitmap, __p_jsonInput, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___reorganizeHashFilev2(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_bitmapPath;
    ::std::string __p_jsonInput;
    __is->read(__p_bitmapPath);
    __is->read(__p_jsonInput);
    __inS.endReadParams();
    try
    {
        reorganizeHashFilev2(__p_bitmapPath, __p_jsonInput, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___hash2Interval(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_jsonInput;
    __is->read(__p_jsonInput);
    __inS.endReadParams();
    try
    {
        ::Ice::Long __ret = hash2Interval(__p_jsonInput, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___exportSnapshot(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_jsonInput;
    __is->read(__p_jsonInput);
    __inS.endReadParams();
    try
    {
        ::std::string __ret = exportSnapshot(__p_jsonInput, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___getAllTapeJson(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    try
    {
        ::std::string __ret = getAllTapeJson(__current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___getAllMediumxJson(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    try
    {
        ::std::string __ret = getAllMediumxJson(__current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___archiveMediaOperation(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_jsonInput;
    __is->read(__p_jsonInput);
    __inS.endReadParams();
    try
    {
        ::std::string __ret = archiveMediaOperation(__p_jsonInput, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___getArchiveFileMetaData(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_jsonInput;
    __is->read(__p_jsonInput);
    __inS.endReadParams();
    try
    {
        ::std::string __ret = getArchiveFileMetaData(__p_jsonInput, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___genArchiveQcowFile(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_jsonInput;
    __is->read(__p_jsonInput);
    __inS.endReadParams();
    try
    {
        ::std::string __ret = genArchiveQcowFile(__p_jsonInput, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___fileBackup(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_jsonInput;
    __is->read(__p_jsonInput);
    __inS.endReadParams();
    try
    {
        ::std::string __ret = fileBackup(__p_jsonInput, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::LogicInternal::___kvmRpc(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_jsonInput;
    __is->read(__p_jsonInput);
    __inS.endReadParams();
    try
    {
        ::std::string __ret = kvmRpc(__p_jsonInput, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __BoxLogic__LogicInternal_all[] =
{
    "AllFilesExist",
    "ChkIsSubId",
    "CmdCtrl",
    "GetDriversSubList",
    "GetDriversVersions",
    "NbdFindUnusedReverse",
    "NbdSetUnused",
    "NbdSetUsed",
    "archiveMediaOperation",
    "calcClusterTime0Hash",
    "copy",
    "cutCdpFile",
    "enumStorageNodes",
    "exportSnapshot",
    "fileBackup",
    "findFiles",
    "formatAndInitializeStorageNode",
    "formatCdpTimestamp",
    "fromMapGetQcowMaxSize",
    "genArchiveQcowFile",
    "generateBitMapFromQcowFile",
    "generateClusterDiffImages",
    "generatePeStageIso",
    "getAllMediumxJson",
    "getAllTapeJson",
    "getArchiveFileMetaData",
    "getCurrentNetworkInfos",
    "getGlobalDoubleChap",
    "getLocalIqn",
    "getPasswd",
    "getRawDiskFiles",
    "hash2Interval",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "isFileExist",
    "isFolderExist",
    "isHardwareDriverExist",
    "kvmRpc",
    "loginExternalDevice",
    "logoutExternalDevice",
    "makeDirs",
    "mergeCdpFile",
    "mergeCdpFiles",
    "mergeHashFile",
    "mergeQcowFile",
    "mountStorageNode",
    "pathJoin",
    "queryCdpTimestamp",
    "queryCdpTimestampRange",
    "queryTakeOverHostInfo",
    "refreshExternalDevice",
    "remove",
    "reorganizeHashFile",
    "reorganizeHashFilev2",
    "runCmd",
    "runRestoreKvm",
    "setGlobalDoubleChap",
    "setLocalIqn",
    "setNetwork",
    "setPasswd",
    "startBackupOptimize",
    "stopBackupOptimize",
    "unmountStorageNode"
};

}

::Ice::DispatchStatus
BoxLogic::LogicInternal::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__BoxLogic__LogicInternal_all, __BoxLogic__LogicInternal_all + 65, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __BoxLogic__LogicInternal_all)
    {
        case 0:
        {
            return ___AllFilesExist(in, current);
        }
        case 1:
        {
            return ___ChkIsSubId(in, current);
        }
        case 2:
        {
            return ___CmdCtrl(in, current);
        }
        case 3:
        {
            return ___GetDriversSubList(in, current);
        }
        case 4:
        {
            return ___GetDriversVersions(in, current);
        }
        case 5:
        {
            return ___NbdFindUnusedReverse(in, current);
        }
        case 6:
        {
            return ___NbdSetUnused(in, current);
        }
        case 7:
        {
            return ___NbdSetUsed(in, current);
        }
        case 8:
        {
            return ___archiveMediaOperation(in, current);
        }
        case 9:
        {
            return ___calcClusterTime0Hash(in, current);
        }
        case 10:
        {
            return ___copy(in, current);
        }
        case 11:
        {
            return ___cutCdpFile(in, current);
        }
        case 12:
        {
            return ___enumStorageNodes(in, current);
        }
        case 13:
        {
            return ___exportSnapshot(in, current);
        }
        case 14:
        {
            return ___fileBackup(in, current);
        }
        case 15:
        {
            return ___findFiles(in, current);
        }
        case 16:
        {
            return ___formatAndInitializeStorageNode(in, current);
        }
        case 17:
        {
            return ___formatCdpTimestamp(in, current);
        }
        case 18:
        {
            return ___fromMapGetQcowMaxSize(in, current);
        }
        case 19:
        {
            return ___genArchiveQcowFile(in, current);
        }
        case 20:
        {
            return ___generateBitMapFromQcowFile(in, current);
        }
        case 21:
        {
            return ___generateClusterDiffImages(in, current);
        }
        case 22:
        {
            return ___generatePeStageIso(in, current);
        }
        case 23:
        {
            return ___getAllMediumxJson(in, current);
        }
        case 24:
        {
            return ___getAllTapeJson(in, current);
        }
        case 25:
        {
            return ___getArchiveFileMetaData(in, current);
        }
        case 26:
        {
            return ___getCurrentNetworkInfos(in, current);
        }
        case 27:
        {
            return ___getGlobalDoubleChap(in, current);
        }
        case 28:
        {
            return ___getLocalIqn(in, current);
        }
        case 29:
        {
            return ___getPasswd(in, current);
        }
        case 30:
        {
            return ___getRawDiskFiles(in, current);
        }
        case 31:
        {
            return ___hash2Interval(in, current);
        }
        case 32:
        {
            return ___ice_id(in, current);
        }
        case 33:
        {
            return ___ice_ids(in, current);
        }
        case 34:
        {
            return ___ice_isA(in, current);
        }
        case 35:
        {
            return ___ice_ping(in, current);
        }
        case 36:
        {
            return ___isFileExist(in, current);
        }
        case 37:
        {
            return ___isFolderExist(in, current);
        }
        case 38:
        {
            return ___isHardwareDriverExist(in, current);
        }
        case 39:
        {
            return ___kvmRpc(in, current);
        }
        case 40:
        {
            return ___loginExternalDevice(in, current);
        }
        case 41:
        {
            return ___logoutExternalDevice(in, current);
        }
        case 42:
        {
            return ___makeDirs(in, current);
        }
        case 43:
        {
            return ___mergeCdpFile(in, current);
        }
        case 44:
        {
            return ___mergeCdpFiles(in, current);
        }
        case 45:
        {
            return ___mergeHashFile(in, current);
        }
        case 46:
        {
            return ___mergeQcowFile(in, current);
        }
        case 47:
        {
            return ___mountStorageNode(in, current);
        }
        case 48:
        {
            return ___pathJoin(in, current);
        }
        case 49:
        {
            return ___queryCdpTimestamp(in, current);
        }
        case 50:
        {
            return ___queryCdpTimestampRange(in, current);
        }
        case 51:
        {
            return ___queryTakeOverHostInfo(in, current);
        }
        case 52:
        {
            return ___refreshExternalDevice(in, current);
        }
        case 53:
        {
            return ___remove(in, current);
        }
        case 54:
        {
            return ___reorganizeHashFile(in, current);
        }
        case 55:
        {
            return ___reorganizeHashFilev2(in, current);
        }
        case 56:
        {
            return ___runCmd(in, current);
        }
        case 57:
        {
            return ___runRestoreKvm(in, current);
        }
        case 58:
        {
            return ___setGlobalDoubleChap(in, current);
        }
        case 59:
        {
            return ___setLocalIqn(in, current);
        }
        case 60:
        {
            return ___setNetwork(in, current);
        }
        case 61:
        {
            return ___setPasswd(in, current);
        }
        case 62:
        {
            return ___startBackupOptimize(in, current);
        }
        case 63:
        {
            return ___stopBackupOptimize(in, current);
        }
        case 64:
        {
            return ___unmountStorageNode(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
BoxLogic::LogicInternal::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
BoxLogic::LogicInternal::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
BoxLogic::__patch(LogicInternalPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::BoxLogic::LogicInternalPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::BoxLogic::LogicInternal::ice_staticId(), v);
    }
}

::Ice::Object* BoxLogic::upCast(::BoxLogic::Setup* p) { return p; }

namespace
{
const ::std::string __BoxLogic__Setup_ids[2] =
{
    "::BoxLogic::Setup",
    "::Ice::Object"
};

}

bool
BoxLogic::Setup::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__BoxLogic__Setup_ids, __BoxLogic__Setup_ids + 2, _s);
}

::std::vector< ::std::string>
BoxLogic::Setup::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__BoxLogic__Setup_ids[0], &__BoxLogic__Setup_ids[2]);
}

const ::std::string&
BoxLogic::Setup::ice_id(const ::Ice::Current&) const
{
    return __BoxLogic__Setup_ids[0];
}

const ::std::string&
BoxLogic::Setup::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::BoxLogic::Setup";
    return typeId;
#else
    return __BoxLogic__Setup_ids[0];
#endif
}

::Ice::DispatchStatus
BoxLogic::Setup::___startSetup(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_session;
    ::std::string __p_flagJson;
    __is->read(__p_session);
    __is->read(__p_flagJson);
    __inS.endReadParams();
    try
    {
        startSetup(__p_session, __p_flagJson, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
BoxLogic::Setup::___cancelSetup(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_session;
    __is->read(__p_session);
    __inS.endReadParams();
    try
    {
        cancelSetup(__p_session, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __BoxLogic__Setup_all[] =
{
    "cancelSetup",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "startSetup"
};

}

::Ice::DispatchStatus
BoxLogic::Setup::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__BoxLogic__Setup_all, __BoxLogic__Setup_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __BoxLogic__Setup_all)
    {
        case 0:
        {
            return ___cancelSetup(in, current);
        }
        case 1:
        {
            return ___ice_id(in, current);
        }
        case 2:
        {
            return ___ice_ids(in, current);
        }
        case 3:
        {
            return ___ice_isA(in, current);
        }
        case 4:
        {
            return ___ice_ping(in, current);
        }
        case 5:
        {
            return ___startSetup(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
BoxLogic::Setup::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
BoxLogic::Setup::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
BoxLogic::__patch(SetupPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::BoxLogic::SetupPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::BoxLogic::Setup::ice_staticId(), v);
    }
}
