// **********************************************************************
//
// Copyright (c) 2003-2015 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.6.1
//
// <auto-generated>
//
// Generated from file `logic.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef ____cpp_logic_h__
#define ____cpp_logic_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Proxy.h>
#include <Ice/GCObject.h>
#include <Ice/AsyncResult.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <IceUtil/Optional.h>
#include <Ice/StreamF.h>
#include <utils.h>
#include <perpcice.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 306
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace BoxLogic
{

class Logic;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::BoxLogic::Logic>&);
::IceProxy::Ice::Object* upCast(::IceProxy::BoxLogic::Logic*);

class LogicInternal;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::BoxLogic::LogicInternal>&);
::IceProxy::Ice::Object* upCast(::IceProxy::BoxLogic::LogicInternal*);

class Setup;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::BoxLogic::Setup>&);
::IceProxy::Ice::Object* upCast(::IceProxy::BoxLogic::Setup*);

}

}

namespace BoxLogic
{

class Logic;
bool operator==(const Logic&, const Logic&);
bool operator<(const Logic&, const Logic&);
::Ice::Object* upCast(::BoxLogic::Logic*);
typedef ::IceInternal::Handle< ::BoxLogic::Logic> LogicPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::BoxLogic::Logic> LogicPrx;
void __patch(LogicPtr&, const ::Ice::ObjectPtr&);

class LogicInternal;
bool operator==(const LogicInternal&, const LogicInternal&);
bool operator<(const LogicInternal&, const LogicInternal&);
::Ice::Object* upCast(::BoxLogic::LogicInternal*);
typedef ::IceInternal::Handle< ::BoxLogic::LogicInternal> LogicInternalPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::BoxLogic::LogicInternal> LogicInternalPrx;
void __patch(LogicInternalPtr&, const ::Ice::ObjectPtr&);

class Setup;
bool operator==(const Setup&, const Setup&);
bool operator<(const Setup&, const Setup&);
::Ice::Object* upCast(::BoxLogic::Setup*);
typedef ::IceInternal::Handle< ::BoxLogic::Setup> SetupPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::BoxLogic::Setup> SetupPrx;
void __patch(SetupPtr&, const ::Ice::ObjectPtr&);

}

namespace BoxLogic
{

typedef ::std::vector< ::std::string> MACs;

struct AgentIdentification
{
    ::std::string Name;
    ::BoxLogic::MACs Hardware;
};

enum DiskType
{
    RAW = 0,
    MBR = 1,
    GPT = 2
};

enum DiskStatus
{
    ErrorOccurred = 0,
    Unsupported = 1,
    NotExistLastSnapshot = 2,
    Backuping = 3,
    CDPing = 4,
    LastSnapshotIsNormal = 5,
    LastSnapshotIsCDP = 6
};

struct CDPSnapshot
{
    CDPSnapshot() :
        setByRestore(false),
        token("invalid"),
        seconds(ICE_INT64(-1)),
        microseconds(-1)
    {
    }
    
    CDPSnapshot(bool __ice_setByRestore, const ::std::string& __ice_token, ::Ice::Long __ice_seconds, ::Ice::Int __ice_microseconds) :
        setByRestore(__ice_setByRestore),
        token(__ice_token),
        seconds(__ice_seconds),
        microseconds(__ice_microseconds)
    {
    }
    

    bool setByRestore;
    ::std::string token;
    ::Ice::Long seconds;
    ::Ice::Int microseconds;

    bool operator==(const CDPSnapshot& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(setByRestore != __rhs.setByRestore)
        {
            return false;
        }
        if(token != __rhs.token)
        {
            return false;
        }
        if(seconds != __rhs.seconds)
        {
            return false;
        }
        if(microseconds != __rhs.microseconds)
        {
            return false;
        }
        return true;
    }

    bool operator<(const CDPSnapshot& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(setByRestore < __rhs.setByRestore)
        {
            return true;
        }
        else if(__rhs.setByRestore < setByRestore)
        {
            return false;
        }
        if(token < __rhs.token)
        {
            return true;
        }
        else if(__rhs.token < token)
        {
            return false;
        }
        if(seconds < __rhs.seconds)
        {
            return true;
        }
        else if(__rhs.seconds < seconds)
        {
            return false;
        }
        if(microseconds < __rhs.microseconds)
        {
            return true;
        }
        else if(__rhs.microseconds < microseconds)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const CDPSnapshot& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const CDPSnapshot& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const CDPSnapshot& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const CDPSnapshot& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct DiskDetail
{
    DiskDetail() :
        lastSnapshot("invalid")
    {
    }
    
    DiskDetail(const ::std::string& __ice_name, ::BoxLogic::DiskStatus __ice_status, ::BoxLogic::DiskType __ice_type, ::Ice::Long __ice_numberOfSectors, bool __ice_bootDevice, const ::std::string& __ice_lastSnapshot, const ::BoxLogic::CDPSnapshot& __ice_cdpSnapshot) :
        name(__ice_name),
        status(__ice_status),
        type(__ice_type),
        numberOfSectors(__ice_numberOfSectors),
        bootDevice(__ice_bootDevice),
        lastSnapshot(__ice_lastSnapshot),
        cdpSnapshot(__ice_cdpSnapshot)
    {
    }
    

    ::std::string name;
    ::BoxLogic::DiskStatus status;
    ::BoxLogic::DiskType type;
    ::Ice::Long numberOfSectors;
    bool bootDevice;
    ::std::string lastSnapshot;
    ::BoxLogic::CDPSnapshot cdpSnapshot;

    bool operator==(const DiskDetail& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(name != __rhs.name)
        {
            return false;
        }
        if(status != __rhs.status)
        {
            return false;
        }
        if(type != __rhs.type)
        {
            return false;
        }
        if(numberOfSectors != __rhs.numberOfSectors)
        {
            return false;
        }
        if(bootDevice != __rhs.bootDevice)
        {
            return false;
        }
        if(lastSnapshot != __rhs.lastSnapshot)
        {
            return false;
        }
        if(cdpSnapshot != __rhs.cdpSnapshot)
        {
            return false;
        }
        return true;
    }

    bool operator<(const DiskDetail& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(name < __rhs.name)
        {
            return true;
        }
        else if(__rhs.name < name)
        {
            return false;
        }
        if(status < __rhs.status)
        {
            return true;
        }
        else if(__rhs.status < status)
        {
            return false;
        }
        if(type < __rhs.type)
        {
            return true;
        }
        else if(__rhs.type < type)
        {
            return false;
        }
        if(numberOfSectors < __rhs.numberOfSectors)
        {
            return true;
        }
        else if(__rhs.numberOfSectors < numberOfSectors)
        {
            return false;
        }
        if(bootDevice < __rhs.bootDevice)
        {
            return true;
        }
        else if(__rhs.bootDevice < bootDevice)
        {
            return false;
        }
        if(lastSnapshot < __rhs.lastSnapshot)
        {
            return true;
        }
        else if(__rhs.lastSnapshot < lastSnapshot)
        {
            return false;
        }
        if(cdpSnapshot < __rhs.cdpSnapshot)
        {
            return true;
        }
        else if(__rhs.cdpSnapshot < cdpSnapshot)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const DiskDetail& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const DiskDetail& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const DiskDetail& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const DiskDetail& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct Disk
{
    ::Ice::Int id;
    ::BoxLogic::DiskDetail detail;

    bool operator==(const Disk& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(id != __rhs.id)
        {
            return false;
        }
        if(detail != __rhs.detail)
        {
            return false;
        }
        return true;
    }

    bool operator<(const Disk& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(id < __rhs.id)
        {
            return true;
        }
        else if(__rhs.id < id)
        {
            return false;
        }
        if(detail < __rhs.detail)
        {
            return true;
        }
        else if(__rhs.detail < detail)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const Disk& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const Disk& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const Disk& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const Disk& __rhs) const
    {
        return !operator<(__rhs);
    }
};

typedef ::std::vector< ::BoxLogic::Disk> Disks;

struct AgentModuleError
{
    ::std::string moduleName;
    ::std::string description;
    ::std::string debug;
    ::Ice::Long rawCode;

    bool operator==(const AgentModuleError& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(moduleName != __rhs.moduleName)
        {
            return false;
        }
        if(description != __rhs.description)
        {
            return false;
        }
        if(debug != __rhs.debug)
        {
            return false;
        }
        if(rawCode != __rhs.rawCode)
        {
            return false;
        }
        return true;
    }

    bool operator<(const AgentModuleError& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(moduleName < __rhs.moduleName)
        {
            return true;
        }
        else if(__rhs.moduleName < moduleName)
        {
            return false;
        }
        if(description < __rhs.description)
        {
            return true;
        }
        else if(__rhs.description < description)
        {
            return false;
        }
        if(debug < __rhs.debug)
        {
            return true;
        }
        else if(__rhs.debug < debug)
        {
            return false;
        }
        if(rawCode < __rhs.rawCode)
        {
            return true;
        }
        else if(__rhs.rawCode < rawCode)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const AgentModuleError& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const AgentModuleError& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const AgentModuleError& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const AgentModuleError& __rhs) const
    {
        return !operator<(__rhs);
    }
};

enum BackupProgressCode
{
    UnknownBackupProgressCode = 0,
    ScanningDuplicateFile = 1,
    AnalyzingDuplicateFile = 2,
    CreatingDataBitmap = 3,
    CreatingDiskSnapshot = 4,
    TransitingData = 5
};

struct BackupProgress
{
    ::BoxLogic::BackupProgressCode code;
    ::Ice::Long progressIndex;
    ::Ice::Long progressTotal;

    bool operator==(const BackupProgress& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(code != __rhs.code)
        {
            return false;
        }
        if(progressIndex != __rhs.progressIndex)
        {
            return false;
        }
        if(progressTotal != __rhs.progressTotal)
        {
            return false;
        }
        return true;
    }

    bool operator<(const BackupProgress& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(code < __rhs.code)
        {
            return true;
        }
        else if(__rhs.code < code)
        {
            return false;
        }
        if(progressIndex < __rhs.progressIndex)
        {
            return true;
        }
        else if(__rhs.progressIndex < progressIndex)
        {
            return false;
        }
        if(progressTotal < __rhs.progressTotal)
        {
            return true;
        }
        else if(__rhs.progressTotal < progressTotal)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const BackupProgress& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const BackupProgress& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const BackupProgress& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const BackupProgress& __rhs) const
    {
        return !operator<(__rhs);
    }
};

enum BackupFinishCode
{
    Successful = 0,
    UserCancel = 1,
    Failed = 2,
    Error = 3
};

struct CDPConfig
{
    CDPConfig() :
        mode(0),
        ip("invalid"),
        port(-1),
        socketNumber(-1),
        cacheMaxBytes(-1),
        netTimeouts(-1),
        token("invalid")
    {
    }
    
    CDPConfig(::Ice::Byte __ice_mode, const ::std::string& __ice_ip, ::Ice::Short __ice_port, ::Ice::Int __ice_socketNumber, ::Ice::Int __ice_cacheMaxBytes, ::Ice::Int __ice_netTimeouts, const ::std::string& __ice_token) :
        mode(__ice_mode),
        ip(__ice_ip),
        port(__ice_port),
        socketNumber(__ice_socketNumber),
        cacheMaxBytes(__ice_cacheMaxBytes),
        netTimeouts(__ice_netTimeouts),
        token(__ice_token)
    {
    }
    

    ::Ice::Byte mode;
    ::std::string ip;
    ::Ice::Short port;
    ::Ice::Int socketNumber;
    ::Ice::Int cacheMaxBytes;
    ::Ice::Int netTimeouts;
    ::std::string token;

    bool operator==(const CDPConfig& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(mode != __rhs.mode)
        {
            return false;
        }
        if(ip != __rhs.ip)
        {
            return false;
        }
        if(port != __rhs.port)
        {
            return false;
        }
        if(socketNumber != __rhs.socketNumber)
        {
            return false;
        }
        if(cacheMaxBytes != __rhs.cacheMaxBytes)
        {
            return false;
        }
        if(netTimeouts != __rhs.netTimeouts)
        {
            return false;
        }
        if(token != __rhs.token)
        {
            return false;
        }
        return true;
    }

    bool operator<(const CDPConfig& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(mode < __rhs.mode)
        {
            return true;
        }
        else if(__rhs.mode < mode)
        {
            return false;
        }
        if(ip < __rhs.ip)
        {
            return true;
        }
        else if(__rhs.ip < ip)
        {
            return false;
        }
        if(port < __rhs.port)
        {
            return true;
        }
        else if(__rhs.port < port)
        {
            return false;
        }
        if(socketNumber < __rhs.socketNumber)
        {
            return true;
        }
        else if(__rhs.socketNumber < socketNumber)
        {
            return false;
        }
        if(cacheMaxBytes < __rhs.cacheMaxBytes)
        {
            return true;
        }
        else if(__rhs.cacheMaxBytes < cacheMaxBytes)
        {
            return false;
        }
        if(netTimeouts < __rhs.netTimeouts)
        {
            return true;
        }
        else if(__rhs.netTimeouts < netTimeouts)
        {
            return false;
        }
        if(token < __rhs.token)
        {
            return true;
        }
        else if(__rhs.token < token)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const CDPConfig& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const CDPConfig& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const CDPConfig& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const CDPConfig& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct RestoreProgress
{
    ::Ice::Long remainingBytes;
    ::Ice::Long totalBytes;

    bool operator==(const RestoreProgress& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(remainingBytes != __rhs.remainingBytes)
        {
            return false;
        }
        if(totalBytes != __rhs.totalBytes)
        {
            return false;
        }
        return true;
    }

    bool operator<(const RestoreProgress& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(remainingBytes < __rhs.remainingBytes)
        {
            return true;
        }
        else if(__rhs.remainingBytes < remainingBytes)
        {
            return false;
        }
        if(totalBytes < __rhs.totalBytes)
        {
            return true;
        }
        else if(__rhs.totalBytes < totalBytes)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const RestoreProgress& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const RestoreProgress& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const RestoreProgress& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const RestoreProgress& __rhs) const
    {
        return !operator<(__rhs);
    }
};

enum RestoreStageCode
{
    FinishFailed = 0,
    FinishOk = 1,
    UmountAllVolumes = 2,
    Started = 3
};

struct LastCdpDetail
{
    ::std::string token;
    ::Ice::Long seconds;
    ::Ice::Int microseconds;

    bool operator==(const LastCdpDetail& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(token != __rhs.token)
        {
            return false;
        }
        if(seconds != __rhs.seconds)
        {
            return false;
        }
        if(microseconds != __rhs.microseconds)
        {
            return false;
        }
        return true;
    }

    bool operator<(const LastCdpDetail& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(token < __rhs.token)
        {
            return true;
        }
        else if(__rhs.token < token)
        {
            return false;
        }
        if(seconds < __rhs.seconds)
        {
            return true;
        }
        else if(__rhs.seconds < seconds)
        {
            return false;
        }
        if(microseconds < __rhs.microseconds)
        {
            return true;
        }
        else if(__rhs.microseconds < microseconds)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const LastCdpDetail& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const LastCdpDetail& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const LastCdpDetail& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const LastCdpDetail& __rhs) const
    {
        return !operator<(__rhs);
    }
};

typedef ::std::vector< ::std::string> AgentStatus;

typedef ::std::vector< ::std::string> Paths;

typedef ::std::vector< ::std::string> StringList;

struct Hardware
{
    ::std::string Type;
    ::std::string Vid;
    ::BoxLogic::StringList HWIds;
    ::BoxLogic::StringList CompatIds;
};

typedef ::std::vector< ::BoxLogic::Hardware> Hardwares;

struct IPConfig
{
    ::std::string ipAddress;
    ::std::string subnetMask;
    ::std::string gateway;
    ::std::string nameServer;
    ::std::string multiInfos;
    ::std::string hardwareConfig;

    bool operator==(const IPConfig& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(ipAddress != __rhs.ipAddress)
        {
            return false;
        }
        if(subnetMask != __rhs.subnetMask)
        {
            return false;
        }
        if(gateway != __rhs.gateway)
        {
            return false;
        }
        if(nameServer != __rhs.nameServer)
        {
            return false;
        }
        if(multiInfos != __rhs.multiInfos)
        {
            return false;
        }
        if(hardwareConfig != __rhs.hardwareConfig)
        {
            return false;
        }
        return true;
    }

    bool operator<(const IPConfig& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(ipAddress < __rhs.ipAddress)
        {
            return true;
        }
        else if(__rhs.ipAddress < ipAddress)
        {
            return false;
        }
        if(subnetMask < __rhs.subnetMask)
        {
            return true;
        }
        else if(__rhs.subnetMask < subnetMask)
        {
            return false;
        }
        if(gateway < __rhs.gateway)
        {
            return true;
        }
        else if(__rhs.gateway < gateway)
        {
            return false;
        }
        if(nameServer < __rhs.nameServer)
        {
            return true;
        }
        else if(__rhs.nameServer < nameServer)
        {
            return false;
        }
        if(multiInfos < __rhs.multiInfos)
        {
            return true;
        }
        else if(__rhs.multiInfos < multiInfos)
        {
            return false;
        }
        if(hardwareConfig < __rhs.hardwareConfig)
        {
            return true;
        }
        else if(__rhs.hardwareConfig < hardwareConfig)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const IPConfig& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const IPConfig& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const IPConfig& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const IPConfig& __rhs) const
    {
        return !operator<(__rhs);
    }
};

typedef ::std::vector< ::BoxLogic::IPConfig> IPConfigs;

typedef ::std::vector< ::Ice::Byte> BinaryStream;

}

namespace Ice
{
template<>
struct StreamableTraits< ::BoxLogic::AgentIdentification>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::BoxLogic::AgentIdentification, S>
{
    static void write(S* __os, const ::BoxLogic::AgentIdentification& v)
    {
        __os->write(v.Name);
        __os->write(v.Hardware);
    }
};

template<class S>
struct StreamReader< ::BoxLogic::AgentIdentification, S>
{
    static void read(S* __is, ::BoxLogic::AgentIdentification& v)
    {
        __is->read(v.Name);
        __is->read(v.Hardware);
    }
};

template<>
struct StreamableTraits< ::BoxLogic::DiskType>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::BoxLogic::DiskStatus>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 6;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::BoxLogic::CDPSnapshot>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 14;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::BoxLogic::CDPSnapshot, S>
{
    static void write(S* __os, const ::BoxLogic::CDPSnapshot& v)
    {
        __os->write(v.setByRestore);
        __os->write(v.token);
        __os->write(v.seconds);
        __os->write(v.microseconds);
    }
};

template<class S>
struct StreamReader< ::BoxLogic::CDPSnapshot, S>
{
    static void read(S* __is, ::BoxLogic::CDPSnapshot& v)
    {
        __is->read(v.setByRestore);
        __is->read(v.token);
        __is->read(v.seconds);
        __is->read(v.microseconds);
    }
};

template<>
struct StreamableTraits< ::BoxLogic::DiskDetail>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 27;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::BoxLogic::DiskDetail, S>
{
    static void write(S* __os, const ::BoxLogic::DiskDetail& v)
    {
        __os->write(v.name);
        __os->write(v.status);
        __os->write(v.type);
        __os->write(v.numberOfSectors);
        __os->write(v.bootDevice);
        __os->write(v.lastSnapshot);
        __os->write(v.cdpSnapshot);
    }
};

template<class S>
struct StreamReader< ::BoxLogic::DiskDetail, S>
{
    static void read(S* __is, ::BoxLogic::DiskDetail& v)
    {
        __is->read(v.name);
        __is->read(v.status);
        __is->read(v.type);
        __is->read(v.numberOfSectors);
        __is->read(v.bootDevice);
        __is->read(v.lastSnapshot);
        __is->read(v.cdpSnapshot);
    }
};

template<>
struct StreamableTraits< ::BoxLogic::Disk>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 31;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::BoxLogic::Disk, S>
{
    static void write(S* __os, const ::BoxLogic::Disk& v)
    {
        __os->write(v.id);
        __os->write(v.detail);
    }
};

template<class S>
struct StreamReader< ::BoxLogic::Disk, S>
{
    static void read(S* __is, ::BoxLogic::Disk& v)
    {
        __is->read(v.id);
        __is->read(v.detail);
    }
};

template<>
struct StreamableTraits< ::BoxLogic::AgentModuleError>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 11;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::BoxLogic::AgentModuleError, S>
{
    static void write(S* __os, const ::BoxLogic::AgentModuleError& v)
    {
        __os->write(v.moduleName);
        __os->write(v.description);
        __os->write(v.debug);
        __os->write(v.rawCode);
    }
};

template<class S>
struct StreamReader< ::BoxLogic::AgentModuleError, S>
{
    static void read(S* __is, ::BoxLogic::AgentModuleError& v)
    {
        __is->read(v.moduleName);
        __is->read(v.description);
        __is->read(v.debug);
        __is->read(v.rawCode);
    }
};

template<>
struct StreamableTraits< ::BoxLogic::BackupProgressCode>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 5;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::BoxLogic::BackupProgress>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 17;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::BoxLogic::BackupProgress, S>
{
    static void write(S* __os, const ::BoxLogic::BackupProgress& v)
    {
        __os->write(v.code);
        __os->write(v.progressIndex);
        __os->write(v.progressTotal);
    }
};

template<class S>
struct StreamReader< ::BoxLogic::BackupProgress, S>
{
    static void read(S* __is, ::BoxLogic::BackupProgress& v)
    {
        __is->read(v.code);
        __is->read(v.progressIndex);
        __is->read(v.progressTotal);
    }
};

template<>
struct StreamableTraits< ::BoxLogic::BackupFinishCode>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 3;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::BoxLogic::CDPConfig>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 17;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::BoxLogic::CDPConfig, S>
{
    static void write(S* __os, const ::BoxLogic::CDPConfig& v)
    {
        __os->write(v.mode);
        __os->write(v.ip);
        __os->write(v.port);
        __os->write(v.socketNumber);
        __os->write(v.cacheMaxBytes);
        __os->write(v.netTimeouts);
        __os->write(v.token);
    }
};

template<class S>
struct StreamReader< ::BoxLogic::CDPConfig, S>
{
    static void read(S* __is, ::BoxLogic::CDPConfig& v)
    {
        __is->read(v.mode);
        __is->read(v.ip);
        __is->read(v.port);
        __is->read(v.socketNumber);
        __is->read(v.cacheMaxBytes);
        __is->read(v.netTimeouts);
        __is->read(v.token);
    }
};

template<>
struct StreamableTraits< ::BoxLogic::RestoreProgress>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 16;
    static const bool fixedLength = true;
};

template<class S>
struct StreamWriter< ::BoxLogic::RestoreProgress, S>
{
    static void write(S* __os, const ::BoxLogic::RestoreProgress& v)
    {
        __os->write(v.remainingBytes);
        __os->write(v.totalBytes);
    }
};

template<class S>
struct StreamReader< ::BoxLogic::RestoreProgress, S>
{
    static void read(S* __is, ::BoxLogic::RestoreProgress& v)
    {
        __is->read(v.remainingBytes);
        __is->read(v.totalBytes);
    }
};

template<>
struct StreamableTraits< ::BoxLogic::RestoreStageCode>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 3;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::BoxLogic::LastCdpDetail>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 13;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::BoxLogic::LastCdpDetail, S>
{
    static void write(S* __os, const ::BoxLogic::LastCdpDetail& v)
    {
        __os->write(v.token);
        __os->write(v.seconds);
        __os->write(v.microseconds);
    }
};

template<class S>
struct StreamReader< ::BoxLogic::LastCdpDetail, S>
{
    static void read(S* __is, ::BoxLogic::LastCdpDetail& v)
    {
        __is->read(v.token);
        __is->read(v.seconds);
        __is->read(v.microseconds);
    }
};

template<>
struct StreamableTraits< ::BoxLogic::Hardware>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::BoxLogic::Hardware, S>
{
    static void write(S* __os, const ::BoxLogic::Hardware& v)
    {
        __os->write(v.Type);
        __os->write(v.Vid);
        __os->write(v.HWIds);
        __os->write(v.CompatIds);
    }
};

template<class S>
struct StreamReader< ::BoxLogic::Hardware, S>
{
    static void read(S* __is, ::BoxLogic::Hardware& v)
    {
        __is->read(v.Type);
        __is->read(v.Vid);
        __is->read(v.HWIds);
        __is->read(v.CompatIds);
    }
};

template<>
struct StreamableTraits< ::BoxLogic::IPConfig>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 6;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::BoxLogic::IPConfig, S>
{
    static void write(S* __os, const ::BoxLogic::IPConfig& v)
    {
        __os->write(v.ipAddress);
        __os->write(v.subnetMask);
        __os->write(v.gateway);
        __os->write(v.nameServer);
        __os->write(v.multiInfos);
        __os->write(v.hardwareConfig);
    }
};

template<class S>
struct StreamReader< ::BoxLogic::IPConfig, S>
{
    static void read(S* __is, ::BoxLogic::IPConfig& v)
    {
        __is->read(v.ipAddress);
        __is->read(v.subnetMask);
        __is->read(v.gateway);
        __is->read(v.nameServer);
        __is->read(v.multiInfos);
        __is->read(v.hardwareConfig);
    }
};

}

namespace BoxLogic
{

class Callback_Logic_ping_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Logic_ping_Base> Callback_Logic_pingPtr;

class Callback_Logic_queryHostName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Logic_queryHostName_Base> Callback_Logic_queryHostNamePtr;

class Callback_Logic_login_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Logic_login_Base> Callback_Logic_loginPtr;

class Callback_Logic_logout_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Logic_logout_Base> Callback_Logic_logoutPtr;

class Callback_Logic_queryHostSoftIdent_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Logic_queryHostSoftIdent_Base> Callback_Logic_queryHostSoftIdentPtr;

class Callback_Logic_reportAgentModuleError_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Logic_reportAgentModuleError_Base> Callback_Logic_reportAgentModuleErrorPtr;

class Callback_Logic_reportBackupProgress_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Logic_reportBackupProgress_Base> Callback_Logic_reportBackupProgressPtr;

class Callback_Logic_reportBackupFinish_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Logic_reportBackupFinish_Base> Callback_Logic_reportBackupFinishPtr;

class Callback_Logic_reportVolumeRestoreStatus_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Logic_reportVolumeRestoreStatus_Base> Callback_Logic_reportVolumeRestoreStatusPtr;

class Callback_Logic_clearAllHostSession_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Logic_clearAllHostSession_Base> Callback_Logic_clearAllHostSessionPtr;

class Callback_Logic_peLogin_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Logic_peLogin_Base> Callback_Logic_peLoginPtr;

class Callback_Logic_peLogout_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Logic_peLogout_Base> Callback_Logic_peLogoutPtr;

class Callback_Logic_updateCDPToken_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Logic_updateCDPToken_Base> Callback_Logic_updateCDPTokenPtr;

class Callback_Logic_updateTrafficControl_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Logic_updateTrafficControl_Base> Callback_Logic_updateTrafficControlPtr;

class Callback_Logic_updateRestoreToken_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Logic_updateRestoreToken_Base> Callback_Logic_updateRestoreTokenPtr;

class Callback_Logic_closeCDPToken_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Logic_closeCDPToken_Base> Callback_Logic_closeCDPTokenPtr;

class Callback_Logic_refreshSnapshotToken_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Logic_refreshSnapshotToken_Base> Callback_Logic_refreshSnapshotTokenPtr;

class Callback_Logic_reportRestoreStatus_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Logic_reportRestoreStatus_Base> Callback_Logic_reportRestoreStatusPtr;

class Callback_Logic_QueryJsonData_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Logic_QueryJsonData_Base> Callback_Logic_QueryJsonDataPtr;

class Callback_Logic_startKvm_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Logic_startKvm_Base> Callback_Logic_startKvmPtr;

class Callback_Logic_fetchProxyEndPoints_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Logic_fetchProxyEndPoints_Base> Callback_Logic_fetchProxyEndPointsPtr;

class Callback_Logic_queryLastCdpDetailByRestoreToken_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Logic_queryLastCdpDetailByRestoreToken_Base> Callback_Logic_queryLastCdpDetailByRestoreTokenPtr;

class Callback_Logic_queryLastCdpDetailByCdpToken_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Logic_queryLastCdpDetailByCdpToken_Base> Callback_Logic_queryLastCdpDetailByCdpTokenPtr;

class Callback_Logic_queryNetworkTransmissionType_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Logic_queryNetworkTransmissionType_Base> Callback_Logic_queryNetworkTransmissionTypePtr;

class Callback_Logic_dataQueuingReport_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Logic_dataQueuingReport_Base> Callback_Logic_dataQueuingReportPtr;

class Callback_Logic_getHashFilePathByRestoreToken_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Logic_getHashFilePathByRestoreToken_Base> Callback_Logic_getHashFilePathByRestoreTokenPtr;

class Callback_Logic_VmwareAgentReport_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Logic_VmwareAgentReport_Base> Callback_Logic_VmwareAgentReportPtr;

class Callback_LogicInternal_pathJoin_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_pathJoin_Base> Callback_LogicInternal_pathJoinPtr;

class Callback_LogicInternal_isFileExist_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_isFileExist_Base> Callback_LogicInternal_isFileExistPtr;

class Callback_LogicInternal_AllFilesExist_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_AllFilesExist_Base> Callback_LogicInternal_AllFilesExistPtr;

class Callback_LogicInternal_isFolderExist_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_isFolderExist_Base> Callback_LogicInternal_isFolderExistPtr;

class Callback_LogicInternal_makeDirs_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_makeDirs_Base> Callback_LogicInternal_makeDirsPtr;

class Callback_LogicInternal_remove_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_remove_Base> Callback_LogicInternal_removePtr;

class Callback_LogicInternal_copy_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_copy_Base> Callback_LogicInternal_copyPtr;

class Callback_LogicInternal_findFiles_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_findFiles_Base> Callback_LogicInternal_findFilesPtr;

class Callback_LogicInternal_queryCdpTimestampRange_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_queryCdpTimestampRange_Base> Callback_LogicInternal_queryCdpTimestampRangePtr;

class Callback_LogicInternal_queryCdpTimestamp_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_queryCdpTimestamp_Base> Callback_LogicInternal_queryCdpTimestampPtr;

class Callback_LogicInternal_formatCdpTimestamp_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_formatCdpTimestamp_Base> Callback_LogicInternal_formatCdpTimestampPtr;

class Callback_LogicInternal_mergeCdpFile_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_mergeCdpFile_Base> Callback_LogicInternal_mergeCdpFilePtr;

class Callback_LogicInternal_isHardwareDriverExist_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_isHardwareDriverExist_Base> Callback_LogicInternal_isHardwareDriverExistPtr;

class Callback_LogicInternal_GetDriversVersions_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_GetDriversVersions_Base> Callback_LogicInternal_GetDriversVersionsPtr;

class Callback_LogicInternal_ChkIsSubId_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_ChkIsSubId_Base> Callback_LogicInternal_ChkIsSubIdPtr;

class Callback_LogicInternal_GetDriversSubList_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_GetDriversSubList_Base> Callback_LogicInternal_GetDriversSubListPtr;

class Callback_LogicInternal_generatePeStageIso_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_generatePeStageIso_Base> Callback_LogicInternal_generatePeStageIsoPtr;

class Callback_LogicInternal_runRestoreKvm_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_runRestoreKvm_Base> Callback_LogicInternal_runRestoreKvmPtr;

class Callback_LogicInternal_getCurrentNetworkInfos_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_getCurrentNetworkInfos_Base> Callback_LogicInternal_getCurrentNetworkInfosPtr;

class Callback_LogicInternal_setNetwork_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_setNetwork_Base> Callback_LogicInternal_setNetworkPtr;

class Callback_LogicInternal_enumStorageNodes_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_enumStorageNodes_Base> Callback_LogicInternal_enumStorageNodesPtr;

class Callback_LogicInternal_getLocalIqn_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_getLocalIqn_Base> Callback_LogicInternal_getLocalIqnPtr;

class Callback_LogicInternal_setLocalIqn_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_setLocalIqn_Base> Callback_LogicInternal_setLocalIqnPtr;

class Callback_LogicInternal_setGlobalDoubleChap_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_setGlobalDoubleChap_Base> Callback_LogicInternal_setGlobalDoubleChapPtr;

class Callback_LogicInternal_getGlobalDoubleChap_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_getGlobalDoubleChap_Base> Callback_LogicInternal_getGlobalDoubleChapPtr;

class Callback_LogicInternal_loginExternalDevice_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_loginExternalDevice_Base> Callback_LogicInternal_loginExternalDevicePtr;

class Callback_LogicInternal_logoutExternalDevice_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_logoutExternalDevice_Base> Callback_LogicInternal_logoutExternalDevicePtr;

class Callback_LogicInternal_refreshExternalDevice_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_refreshExternalDevice_Base> Callback_LogicInternal_refreshExternalDevicePtr;

class Callback_LogicInternal_formatAndInitializeStorageNode_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_formatAndInitializeStorageNode_Base> Callback_LogicInternal_formatAndInitializeStorageNodePtr;

class Callback_LogicInternal_mountStorageNode_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_mountStorageNode_Base> Callback_LogicInternal_mountStorageNodePtr;

class Callback_LogicInternal_unmountStorageNode_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_unmountStorageNode_Base> Callback_LogicInternal_unmountStorageNodePtr;

class Callback_LogicInternal_runCmd_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_runCmd_Base> Callback_LogicInternal_runCmdPtr;

class Callback_LogicInternal_CmdCtrl_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_CmdCtrl_Base> Callback_LogicInternal_CmdCtrlPtr;

class Callback_LogicInternal_setPasswd_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_setPasswd_Base> Callback_LogicInternal_setPasswdPtr;

class Callback_LogicInternal_getPasswd_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_getPasswd_Base> Callback_LogicInternal_getPasswdPtr;

class Callback_LogicInternal_calcClusterTime0Hash_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_calcClusterTime0Hash_Base> Callback_LogicInternal_calcClusterTime0HashPtr;

class Callback_LogicInternal_generateClusterDiffImages_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_generateClusterDiffImages_Base> Callback_LogicInternal_generateClusterDiffImagesPtr;

class Callback_LogicInternal_mergeCdpFiles_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_mergeCdpFiles_Base> Callback_LogicInternal_mergeCdpFilesPtr;

class Callback_LogicInternal_cutCdpFile_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_cutCdpFile_Base> Callback_LogicInternal_cutCdpFilePtr;

class Callback_LogicInternal_getRawDiskFiles_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_getRawDiskFiles_Base> Callback_LogicInternal_getRawDiskFilesPtr;

class Callback_LogicInternal_NbdFindUnusedReverse_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_NbdFindUnusedReverse_Base> Callback_LogicInternal_NbdFindUnusedReversePtr;

class Callback_LogicInternal_NbdSetUnused_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_NbdSetUnused_Base> Callback_LogicInternal_NbdSetUnusedPtr;

class Callback_LogicInternal_NbdSetUsed_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_NbdSetUsed_Base> Callback_LogicInternal_NbdSetUsedPtr;

class Callback_LogicInternal_queryTakeOverHostInfo_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_queryTakeOverHostInfo_Base> Callback_LogicInternal_queryTakeOverHostInfoPtr;

class Callback_LogicInternal_mergeQcowFile_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_mergeQcowFile_Base> Callback_LogicInternal_mergeQcowFilePtr;

class Callback_LogicInternal_startBackupOptimize_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_startBackupOptimize_Base> Callback_LogicInternal_startBackupOptimizePtr;

class Callback_LogicInternal_stopBackupOptimize_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_stopBackupOptimize_Base> Callback_LogicInternal_stopBackupOptimizePtr;

class Callback_LogicInternal_mergeHashFile_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_mergeHashFile_Base> Callback_LogicInternal_mergeHashFilePtr;

class Callback_LogicInternal_generateBitMapFromQcowFile_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_generateBitMapFromQcowFile_Base> Callback_LogicInternal_generateBitMapFromQcowFilePtr;

class Callback_LogicInternal_fromMapGetQcowMaxSize_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_fromMapGetQcowMaxSize_Base> Callback_LogicInternal_fromMapGetQcowMaxSizePtr;

class Callback_LogicInternal_reorganizeHashFile_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_reorganizeHashFile_Base> Callback_LogicInternal_reorganizeHashFilePtr;

class Callback_LogicInternal_reorganizeHashFilev2_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_reorganizeHashFilev2_Base> Callback_LogicInternal_reorganizeHashFilev2Ptr;

class Callback_LogicInternal_hash2Interval_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_hash2Interval_Base> Callback_LogicInternal_hash2IntervalPtr;

class Callback_LogicInternal_exportSnapshot_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_exportSnapshot_Base> Callback_LogicInternal_exportSnapshotPtr;

class Callback_LogicInternal_getAllTapeJson_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_getAllTapeJson_Base> Callback_LogicInternal_getAllTapeJsonPtr;

class Callback_LogicInternal_getAllMediumxJson_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_getAllMediumxJson_Base> Callback_LogicInternal_getAllMediumxJsonPtr;

class Callback_LogicInternal_archiveMediaOperation_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_archiveMediaOperation_Base> Callback_LogicInternal_archiveMediaOperationPtr;

class Callback_LogicInternal_getArchiveFileMetaData_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_getArchiveFileMetaData_Base> Callback_LogicInternal_getArchiveFileMetaDataPtr;

class Callback_LogicInternal_genArchiveQcowFile_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_genArchiveQcowFile_Base> Callback_LogicInternal_genArchiveQcowFilePtr;

class Callback_LogicInternal_fileBackup_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_fileBackup_Base> Callback_LogicInternal_fileBackupPtr;

class Callback_LogicInternal_kvmRpc_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_LogicInternal_kvmRpc_Base> Callback_LogicInternal_kvmRpcPtr;

class Callback_Setup_startSetup_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Setup_startSetup_Base> Callback_Setup_startSetupPtr;

class Callback_Setup_cancelSetup_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Setup_cancelSetup_Base> Callback_Setup_cancelSetupPtr;

}

namespace IceProxy
{

namespace BoxLogic
{

class Logic : virtual public ::IceProxy::Ice::Object
{
public:

    void ping()
    {
        ping(0);
    }
    void ping(const ::Ice::Context& __ctx)
    {
        ping(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_ping(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_ping(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_ping(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_ping(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_ping(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_ping(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_ping(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_ping(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_ping()
    {
        return begin_ping(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ping(const ::Ice::Context& __ctx)
    {
        return begin_ping(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ping(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ping(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ping(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ping(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ping(const ::BoxLogic::Callback_Logic_pingPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ping(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ping(const ::Ice::Context& __ctx, const ::BoxLogic::Callback_Logic_pingPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ping(&__ctx, __del, __cookie);
    }

    void end_ping(const ::Ice::AsyncResultPtr&);
    
private:

    void ping(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_ping(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string queryHostName(const ::BoxLogic::AgentIdentification& __p_ident, const ::std::string& __p_info)
    {
        return queryHostName(__p_ident, __p_info, 0);
    }
    ::std::string queryHostName(const ::BoxLogic::AgentIdentification& __p_ident, const ::std::string& __p_info, const ::Ice::Context& __ctx)
    {
        return queryHostName(__p_ident, __p_info, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_queryHostName(const ::BoxLogic::AgentIdentification& __p_ident, const ::std::string& __p_info, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_queryHostName(__p_ident, __p_info, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_queryHostName(const ::BoxLogic::AgentIdentification& __p_ident, const ::std::string& __p_info, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_queryHostName(__p_ident, __p_info, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_queryHostName(const ::BoxLogic::AgentIdentification& __p_ident, const ::std::string& __p_info, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_queryHostName(__p_ident, __p_info, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_queryHostName(const ::BoxLogic::AgentIdentification& __p_ident, const ::std::string& __p_info, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_queryHostName(__p_ident, __p_info, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_queryHostName(const ::BoxLogic::AgentIdentification& __p_ident, const ::std::string& __p_info, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_queryHostName(const ::BoxLogic::AgentIdentification& __p_ident, const ::std::string& __p_info)
    {
        return begin_queryHostName(__p_ident, __p_info, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_queryHostName(const ::BoxLogic::AgentIdentification& __p_ident, const ::std::string& __p_info, const ::Ice::Context& __ctx)
    {
        return begin_queryHostName(__p_ident, __p_info, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_queryHostName(const ::BoxLogic::AgentIdentification& __p_ident, const ::std::string& __p_info, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryHostName(__p_ident, __p_info, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryHostName(const ::BoxLogic::AgentIdentification& __p_ident, const ::std::string& __p_info, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryHostName(__p_ident, __p_info, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryHostName(const ::BoxLogic::AgentIdentification& __p_ident, const ::std::string& __p_info, const ::BoxLogic::Callback_Logic_queryHostNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryHostName(__p_ident, __p_info, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryHostName(const ::BoxLogic::AgentIdentification& __p_ident, const ::std::string& __p_info, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_Logic_queryHostNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryHostName(__p_ident, __p_info, &__ctx, __del, __cookie);
    }

    ::std::string end_queryHostName(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string queryHostName(const ::BoxLogic::AgentIdentification&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_queryHostName(const ::BoxLogic::AgentIdentification&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool login(const ::std::string& __p_hostName, const ::std::string& __p_remoteIp, const ::std::string& __p_localIp, ::Ice::Int __p_tunnelIndex)
    {
        return login(__p_hostName, __p_remoteIp, __p_localIp, __p_tunnelIndex, 0);
    }
    bool login(const ::std::string& __p_hostName, const ::std::string& __p_remoteIp, const ::std::string& __p_localIp, ::Ice::Int __p_tunnelIndex, const ::Ice::Context& __ctx)
    {
        return login(__p_hostName, __p_remoteIp, __p_localIp, __p_tunnelIndex, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_login(const ::std::string& __p_hostName, const ::std::string& __p_remoteIp, const ::std::string& __p_localIp, ::Ice::Int __p_tunnelIndex, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_login(__p_hostName, __p_remoteIp, __p_localIp, __p_tunnelIndex, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_login(const ::std::string& __p_hostName, const ::std::string& __p_remoteIp, const ::std::string& __p_localIp, ::Ice::Int __p_tunnelIndex, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_login(__p_hostName, __p_remoteIp, __p_localIp, __p_tunnelIndex, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_login(const ::std::string& __p_hostName, const ::std::string& __p_remoteIp, const ::std::string& __p_localIp, ::Ice::Int __p_tunnelIndex, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_login(__p_hostName, __p_remoteIp, __p_localIp, __p_tunnelIndex, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_login(const ::std::string& __p_hostName, const ::std::string& __p_remoteIp, const ::std::string& __p_localIp, ::Ice::Int __p_tunnelIndex, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_login(__p_hostName, __p_remoteIp, __p_localIp, __p_tunnelIndex, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_login(const ::std::string& __p_hostName, const ::std::string& __p_remoteIp, const ::std::string& __p_localIp, ::Ice::Int __p_tunnelIndex, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_login(const ::std::string& __p_hostName, const ::std::string& __p_remoteIp, const ::std::string& __p_localIp, ::Ice::Int __p_tunnelIndex)
    {
        return begin_login(__p_hostName, __p_remoteIp, __p_localIp, __p_tunnelIndex, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_login(const ::std::string& __p_hostName, const ::std::string& __p_remoteIp, const ::std::string& __p_localIp, ::Ice::Int __p_tunnelIndex, const ::Ice::Context& __ctx)
    {
        return begin_login(__p_hostName, __p_remoteIp, __p_localIp, __p_tunnelIndex, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_login(const ::std::string& __p_hostName, const ::std::string& __p_remoteIp, const ::std::string& __p_localIp, ::Ice::Int __p_tunnelIndex, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_login(__p_hostName, __p_remoteIp, __p_localIp, __p_tunnelIndex, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_login(const ::std::string& __p_hostName, const ::std::string& __p_remoteIp, const ::std::string& __p_localIp, ::Ice::Int __p_tunnelIndex, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_login(__p_hostName, __p_remoteIp, __p_localIp, __p_tunnelIndex, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_login(const ::std::string& __p_hostName, const ::std::string& __p_remoteIp, const ::std::string& __p_localIp, ::Ice::Int __p_tunnelIndex, const ::BoxLogic::Callback_Logic_loginPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_login(__p_hostName, __p_remoteIp, __p_localIp, __p_tunnelIndex, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_login(const ::std::string& __p_hostName, const ::std::string& __p_remoteIp, const ::std::string& __p_localIp, ::Ice::Int __p_tunnelIndex, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_Logic_loginPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_login(__p_hostName, __p_remoteIp, __p_localIp, __p_tunnelIndex, &__ctx, __del, __cookie);
    }

    bool end_login(const ::Ice::AsyncResultPtr&);
    
private:

    bool login(const ::std::string&, const ::std::string&, const ::std::string&, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_login(const ::std::string&, const ::std::string&, const ::std::string&, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void logout(const ::std::string& __p_hostName)
    {
        logout(__p_hostName, 0);
    }
    void logout(const ::std::string& __p_hostName, const ::Ice::Context& __ctx)
    {
        logout(__p_hostName, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_logout(const ::std::string& __p_hostName, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_logout(__p_hostName, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_logout(const ::std::string& __p_hostName, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_logout(__p_hostName, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_logout(const ::std::string& __p_hostName, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_logout(__p_hostName, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_logout(const ::std::string& __p_hostName, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_logout(__p_hostName, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_logout(const ::std::string& __p_hostName)
    {
        return begin_logout(__p_hostName, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_logout(const ::std::string& __p_hostName, const ::Ice::Context& __ctx)
    {
        return begin_logout(__p_hostName, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_logout(const ::std::string& __p_hostName, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_logout(__p_hostName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_logout(const ::std::string& __p_hostName, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_logout(__p_hostName, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_logout(const ::std::string& __p_hostName, const ::BoxLogic::Callback_Logic_logoutPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_logout(__p_hostName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_logout(const ::std::string& __p_hostName, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_Logic_logoutPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_logout(__p_hostName, &__ctx, __del, __cookie);
    }

    void end_logout(const ::Ice::AsyncResultPtr&);
    
private:

    void logout(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_logout(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string queryHostSoftIdent(const ::std::string& __p_hostName)
    {
        return queryHostSoftIdent(__p_hostName, 0);
    }
    ::std::string queryHostSoftIdent(const ::std::string& __p_hostName, const ::Ice::Context& __ctx)
    {
        return queryHostSoftIdent(__p_hostName, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_queryHostSoftIdent(const ::std::string& __p_hostName, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_queryHostSoftIdent(__p_hostName, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_queryHostSoftIdent(const ::std::string& __p_hostName, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_queryHostSoftIdent(__p_hostName, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_queryHostSoftIdent(const ::std::string& __p_hostName, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_queryHostSoftIdent(__p_hostName, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_queryHostSoftIdent(const ::std::string& __p_hostName, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_queryHostSoftIdent(__p_hostName, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_queryHostSoftIdent(const ::std::string& __p_hostName, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_queryHostSoftIdent(const ::std::string& __p_hostName)
    {
        return begin_queryHostSoftIdent(__p_hostName, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_queryHostSoftIdent(const ::std::string& __p_hostName, const ::Ice::Context& __ctx)
    {
        return begin_queryHostSoftIdent(__p_hostName, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_queryHostSoftIdent(const ::std::string& __p_hostName, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryHostSoftIdent(__p_hostName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryHostSoftIdent(const ::std::string& __p_hostName, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryHostSoftIdent(__p_hostName, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryHostSoftIdent(const ::std::string& __p_hostName, const ::BoxLogic::Callback_Logic_queryHostSoftIdentPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryHostSoftIdent(__p_hostName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryHostSoftIdent(const ::std::string& __p_hostName, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_Logic_queryHostSoftIdentPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryHostSoftIdent(__p_hostName, &__ctx, __del, __cookie);
    }

    ::std::string end_queryHostSoftIdent(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string queryHostSoftIdent(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_queryHostSoftIdent(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void reportAgentModuleError(const ::std::string& __p_hostName, const ::BoxLogic::AgentModuleError& __p_error)
    {
        reportAgentModuleError(__p_hostName, __p_error, 0);
    }
    void reportAgentModuleError(const ::std::string& __p_hostName, const ::BoxLogic::AgentModuleError& __p_error, const ::Ice::Context& __ctx)
    {
        reportAgentModuleError(__p_hostName, __p_error, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_reportAgentModuleError(const ::std::string& __p_hostName, const ::BoxLogic::AgentModuleError& __p_error, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_reportAgentModuleError(__p_hostName, __p_error, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_reportAgentModuleError(const ::std::string& __p_hostName, const ::BoxLogic::AgentModuleError& __p_error, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_reportAgentModuleError(__p_hostName, __p_error, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_reportAgentModuleError(const ::std::string& __p_hostName, const ::BoxLogic::AgentModuleError& __p_error, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_reportAgentModuleError(__p_hostName, __p_error, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_reportAgentModuleError(const ::std::string& __p_hostName, const ::BoxLogic::AgentModuleError& __p_error, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_reportAgentModuleError(__p_hostName, __p_error, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_reportAgentModuleError(const ::std::string& __p_hostName, const ::BoxLogic::AgentModuleError& __p_error)
    {
        return begin_reportAgentModuleError(__p_hostName, __p_error, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reportAgentModuleError(const ::std::string& __p_hostName, const ::BoxLogic::AgentModuleError& __p_error, const ::Ice::Context& __ctx)
    {
        return begin_reportAgentModuleError(__p_hostName, __p_error, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reportAgentModuleError(const ::std::string& __p_hostName, const ::BoxLogic::AgentModuleError& __p_error, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reportAgentModuleError(__p_hostName, __p_error, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reportAgentModuleError(const ::std::string& __p_hostName, const ::BoxLogic::AgentModuleError& __p_error, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reportAgentModuleError(__p_hostName, __p_error, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reportAgentModuleError(const ::std::string& __p_hostName, const ::BoxLogic::AgentModuleError& __p_error, const ::BoxLogic::Callback_Logic_reportAgentModuleErrorPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reportAgentModuleError(__p_hostName, __p_error, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reportAgentModuleError(const ::std::string& __p_hostName, const ::BoxLogic::AgentModuleError& __p_error, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_Logic_reportAgentModuleErrorPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reportAgentModuleError(__p_hostName, __p_error, &__ctx, __del, __cookie);
    }

    void end_reportAgentModuleError(const ::Ice::AsyncResultPtr&);
    
private:

    void reportAgentModuleError(const ::std::string&, const ::BoxLogic::AgentModuleError&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_reportAgentModuleError(const ::std::string&, const ::BoxLogic::AgentModuleError&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void reportBackupProgress(const ::std::string& __p_hostName, const ::BoxLogic::BackupProgress& __p_progress)
    {
        reportBackupProgress(__p_hostName, __p_progress, 0);
    }
    void reportBackupProgress(const ::std::string& __p_hostName, const ::BoxLogic::BackupProgress& __p_progress, const ::Ice::Context& __ctx)
    {
        reportBackupProgress(__p_hostName, __p_progress, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_reportBackupProgress(const ::std::string& __p_hostName, const ::BoxLogic::BackupProgress& __p_progress, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_reportBackupProgress(__p_hostName, __p_progress, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_reportBackupProgress(const ::std::string& __p_hostName, const ::BoxLogic::BackupProgress& __p_progress, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_reportBackupProgress(__p_hostName, __p_progress, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_reportBackupProgress(const ::std::string& __p_hostName, const ::BoxLogic::BackupProgress& __p_progress, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_reportBackupProgress(__p_hostName, __p_progress, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_reportBackupProgress(const ::std::string& __p_hostName, const ::BoxLogic::BackupProgress& __p_progress, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_reportBackupProgress(__p_hostName, __p_progress, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_reportBackupProgress(const ::std::string& __p_hostName, const ::BoxLogic::BackupProgress& __p_progress)
    {
        return begin_reportBackupProgress(__p_hostName, __p_progress, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reportBackupProgress(const ::std::string& __p_hostName, const ::BoxLogic::BackupProgress& __p_progress, const ::Ice::Context& __ctx)
    {
        return begin_reportBackupProgress(__p_hostName, __p_progress, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reportBackupProgress(const ::std::string& __p_hostName, const ::BoxLogic::BackupProgress& __p_progress, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reportBackupProgress(__p_hostName, __p_progress, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reportBackupProgress(const ::std::string& __p_hostName, const ::BoxLogic::BackupProgress& __p_progress, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reportBackupProgress(__p_hostName, __p_progress, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reportBackupProgress(const ::std::string& __p_hostName, const ::BoxLogic::BackupProgress& __p_progress, const ::BoxLogic::Callback_Logic_reportBackupProgressPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reportBackupProgress(__p_hostName, __p_progress, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reportBackupProgress(const ::std::string& __p_hostName, const ::BoxLogic::BackupProgress& __p_progress, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_Logic_reportBackupProgressPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reportBackupProgress(__p_hostName, __p_progress, &__ctx, __del, __cookie);
    }

    void end_reportBackupProgress(const ::Ice::AsyncResultPtr&);
    
private:

    void reportBackupProgress(const ::std::string&, const ::BoxLogic::BackupProgress&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_reportBackupProgress(const ::std::string&, const ::BoxLogic::BackupProgress&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void reportBackupFinish(const ::std::string& __p_hostName, ::BoxLogic::BackupFinishCode __p_code)
    {
        reportBackupFinish(__p_hostName, __p_code, 0);
    }
    void reportBackupFinish(const ::std::string& __p_hostName, ::BoxLogic::BackupFinishCode __p_code, const ::Ice::Context& __ctx)
    {
        reportBackupFinish(__p_hostName, __p_code, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_reportBackupFinish(const ::std::string& __p_hostName, ::BoxLogic::BackupFinishCode __p_code, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_reportBackupFinish(__p_hostName, __p_code, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_reportBackupFinish(const ::std::string& __p_hostName, ::BoxLogic::BackupFinishCode __p_code, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_reportBackupFinish(__p_hostName, __p_code, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_reportBackupFinish(const ::std::string& __p_hostName, ::BoxLogic::BackupFinishCode __p_code, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_reportBackupFinish(__p_hostName, __p_code, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_reportBackupFinish(const ::std::string& __p_hostName, ::BoxLogic::BackupFinishCode __p_code, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_reportBackupFinish(__p_hostName, __p_code, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_reportBackupFinish(const ::std::string& __p_hostName, ::BoxLogic::BackupFinishCode __p_code, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_reportBackupFinish(const ::std::string& __p_hostName, ::BoxLogic::BackupFinishCode __p_code)
    {
        return begin_reportBackupFinish(__p_hostName, __p_code, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reportBackupFinish(const ::std::string& __p_hostName, ::BoxLogic::BackupFinishCode __p_code, const ::Ice::Context& __ctx)
    {
        return begin_reportBackupFinish(__p_hostName, __p_code, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reportBackupFinish(const ::std::string& __p_hostName, ::BoxLogic::BackupFinishCode __p_code, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reportBackupFinish(__p_hostName, __p_code, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reportBackupFinish(const ::std::string& __p_hostName, ::BoxLogic::BackupFinishCode __p_code, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reportBackupFinish(__p_hostName, __p_code, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reportBackupFinish(const ::std::string& __p_hostName, ::BoxLogic::BackupFinishCode __p_code, const ::BoxLogic::Callback_Logic_reportBackupFinishPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reportBackupFinish(__p_hostName, __p_code, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reportBackupFinish(const ::std::string& __p_hostName, ::BoxLogic::BackupFinishCode __p_code, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_Logic_reportBackupFinishPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reportBackupFinish(__p_hostName, __p_code, &__ctx, __del, __cookie);
    }

    void end_reportBackupFinish(const ::Ice::AsyncResultPtr&);
    
private:

    void reportBackupFinish(const ::std::string&, ::BoxLogic::BackupFinishCode, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_reportBackupFinish(const ::std::string&, ::BoxLogic::BackupFinishCode, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void reportVolumeRestoreStatus(const ::std::string& __p_peHost, ::BoxLogic::RestoreStageCode __p_code, const ::std::string& __p_msg, const ::std::string& __p_debug)
    {
        reportVolumeRestoreStatus(__p_peHost, __p_code, __p_msg, __p_debug, 0);
    }
    void reportVolumeRestoreStatus(const ::std::string& __p_peHost, ::BoxLogic::RestoreStageCode __p_code, const ::std::string& __p_msg, const ::std::string& __p_debug, const ::Ice::Context& __ctx)
    {
        reportVolumeRestoreStatus(__p_peHost, __p_code, __p_msg, __p_debug, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_reportVolumeRestoreStatus(const ::std::string& __p_peHost, ::BoxLogic::RestoreStageCode __p_code, const ::std::string& __p_msg, const ::std::string& __p_debug, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_reportVolumeRestoreStatus(__p_peHost, __p_code, __p_msg, __p_debug, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_reportVolumeRestoreStatus(const ::std::string& __p_peHost, ::BoxLogic::RestoreStageCode __p_code, const ::std::string& __p_msg, const ::std::string& __p_debug, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_reportVolumeRestoreStatus(__p_peHost, __p_code, __p_msg, __p_debug, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_reportVolumeRestoreStatus(const ::std::string& __p_peHost, ::BoxLogic::RestoreStageCode __p_code, const ::std::string& __p_msg, const ::std::string& __p_debug, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_reportVolumeRestoreStatus(__p_peHost, __p_code, __p_msg, __p_debug, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_reportVolumeRestoreStatus(const ::std::string& __p_peHost, ::BoxLogic::RestoreStageCode __p_code, const ::std::string& __p_msg, const ::std::string& __p_debug, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_reportVolumeRestoreStatus(__p_peHost, __p_code, __p_msg, __p_debug, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_reportVolumeRestoreStatus(const ::std::string& __p_peHost, ::BoxLogic::RestoreStageCode __p_code, const ::std::string& __p_msg, const ::std::string& __p_debug, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_reportVolumeRestoreStatus(const ::std::string& __p_peHost, ::BoxLogic::RestoreStageCode __p_code, const ::std::string& __p_msg, const ::std::string& __p_debug)
    {
        return begin_reportVolumeRestoreStatus(__p_peHost, __p_code, __p_msg, __p_debug, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reportVolumeRestoreStatus(const ::std::string& __p_peHost, ::BoxLogic::RestoreStageCode __p_code, const ::std::string& __p_msg, const ::std::string& __p_debug, const ::Ice::Context& __ctx)
    {
        return begin_reportVolumeRestoreStatus(__p_peHost, __p_code, __p_msg, __p_debug, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reportVolumeRestoreStatus(const ::std::string& __p_peHost, ::BoxLogic::RestoreStageCode __p_code, const ::std::string& __p_msg, const ::std::string& __p_debug, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reportVolumeRestoreStatus(__p_peHost, __p_code, __p_msg, __p_debug, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reportVolumeRestoreStatus(const ::std::string& __p_peHost, ::BoxLogic::RestoreStageCode __p_code, const ::std::string& __p_msg, const ::std::string& __p_debug, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reportVolumeRestoreStatus(__p_peHost, __p_code, __p_msg, __p_debug, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reportVolumeRestoreStatus(const ::std::string& __p_peHost, ::BoxLogic::RestoreStageCode __p_code, const ::std::string& __p_msg, const ::std::string& __p_debug, const ::BoxLogic::Callback_Logic_reportVolumeRestoreStatusPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reportVolumeRestoreStatus(__p_peHost, __p_code, __p_msg, __p_debug, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reportVolumeRestoreStatus(const ::std::string& __p_peHost, ::BoxLogic::RestoreStageCode __p_code, const ::std::string& __p_msg, const ::std::string& __p_debug, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_Logic_reportVolumeRestoreStatusPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reportVolumeRestoreStatus(__p_peHost, __p_code, __p_msg, __p_debug, &__ctx, __del, __cookie);
    }

    void end_reportVolumeRestoreStatus(const ::Ice::AsyncResultPtr&);
    
private:

    void reportVolumeRestoreStatus(const ::std::string&, ::BoxLogic::RestoreStageCode, const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_reportVolumeRestoreStatus(const ::std::string&, ::BoxLogic::RestoreStageCode, const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void clearAllHostSession()
    {
        clearAllHostSession(0);
    }
    void clearAllHostSession(const ::Ice::Context& __ctx)
    {
        clearAllHostSession(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_clearAllHostSession(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_clearAllHostSession(0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_clearAllHostSession(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_clearAllHostSession(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_clearAllHostSession(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_clearAllHostSession(&__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_clearAllHostSession(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_clearAllHostSession(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_clearAllHostSession()
    {
        return begin_clearAllHostSession(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_clearAllHostSession(const ::Ice::Context& __ctx)
    {
        return begin_clearAllHostSession(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_clearAllHostSession(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clearAllHostSession(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_clearAllHostSession(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clearAllHostSession(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_clearAllHostSession(const ::BoxLogic::Callback_Logic_clearAllHostSessionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clearAllHostSession(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_clearAllHostSession(const ::Ice::Context& __ctx, const ::BoxLogic::Callback_Logic_clearAllHostSessionPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_clearAllHostSession(&__ctx, __del, __cookie);
    }

    void end_clearAllHostSession(const ::Ice::AsyncResultPtr&);
    
private:

    void clearAllHostSession(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_clearAllHostSession(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string peLogin(const ::PerpcIce::PeGuestInfo& __p_info, const ::std::string& __p_remoteIp, const ::std::string& __p_localIp, ::Ice::Int __p_tunnelIndex, const IceUtil::Optional< ::std::string>& __p_moreInfo)
    {
        return peLogin(__p_info, __p_remoteIp, __p_localIp, __p_tunnelIndex, __p_moreInfo, 0);
    }
    ::std::string peLogin(const ::PerpcIce::PeGuestInfo& __p_info, const ::std::string& __p_remoteIp, const ::std::string& __p_localIp, ::Ice::Int __p_tunnelIndex, const IceUtil::Optional< ::std::string>& __p_moreInfo, const ::Ice::Context& __ctx)
    {
        return peLogin(__p_info, __p_remoteIp, __p_localIp, __p_tunnelIndex, __p_moreInfo, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_peLogin(const ::PerpcIce::PeGuestInfo& __p_info, const ::std::string& __p_remoteIp, const ::std::string& __p_localIp, ::Ice::Int __p_tunnelIndex, const IceUtil::Optional< ::std::string>& __p_moreInfo, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_peLogin(__p_info, __p_remoteIp, __p_localIp, __p_tunnelIndex, __p_moreInfo, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_peLogin(const ::PerpcIce::PeGuestInfo& __p_info, const ::std::string& __p_remoteIp, const ::std::string& __p_localIp, ::Ice::Int __p_tunnelIndex, const IceUtil::Optional< ::std::string>& __p_moreInfo, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_peLogin(__p_info, __p_remoteIp, __p_localIp, __p_tunnelIndex, __p_moreInfo, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_peLogin(const ::PerpcIce::PeGuestInfo& __p_info, const ::std::string& __p_remoteIp, const ::std::string& __p_localIp, ::Ice::Int __p_tunnelIndex, const IceUtil::Optional< ::std::string>& __p_moreInfo, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_peLogin(__p_info, __p_remoteIp, __p_localIp, __p_tunnelIndex, __p_moreInfo, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_peLogin(const ::PerpcIce::PeGuestInfo& __p_info, const ::std::string& __p_remoteIp, const ::std::string& __p_localIp, ::Ice::Int __p_tunnelIndex, const IceUtil::Optional< ::std::string>& __p_moreInfo, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_peLogin(__p_info, __p_remoteIp, __p_localIp, __p_tunnelIndex, __p_moreInfo, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_peLogin(const ::PerpcIce::PeGuestInfo& __p_info, const ::std::string& __p_remoteIp, const ::std::string& __p_localIp, ::Ice::Int __p_tunnelIndex, const IceUtil::Optional< ::std::string>& __p_moreInfo, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_peLogin(const ::PerpcIce::PeGuestInfo& __p_info, const ::std::string& __p_remoteIp, const ::std::string& __p_localIp, ::Ice::Int __p_tunnelIndex, const IceUtil::Optional< ::std::string>& __p_moreInfo)
    {
        return begin_peLogin(__p_info, __p_remoteIp, __p_localIp, __p_tunnelIndex, __p_moreInfo, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_peLogin(const ::PerpcIce::PeGuestInfo& __p_info, const ::std::string& __p_remoteIp, const ::std::string& __p_localIp, ::Ice::Int __p_tunnelIndex, const IceUtil::Optional< ::std::string>& __p_moreInfo, const ::Ice::Context& __ctx)
    {
        return begin_peLogin(__p_info, __p_remoteIp, __p_localIp, __p_tunnelIndex, __p_moreInfo, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_peLogin(const ::PerpcIce::PeGuestInfo& __p_info, const ::std::string& __p_remoteIp, const ::std::string& __p_localIp, ::Ice::Int __p_tunnelIndex, const IceUtil::Optional< ::std::string>& __p_moreInfo, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_peLogin(__p_info, __p_remoteIp, __p_localIp, __p_tunnelIndex, __p_moreInfo, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_peLogin(const ::PerpcIce::PeGuestInfo& __p_info, const ::std::string& __p_remoteIp, const ::std::string& __p_localIp, ::Ice::Int __p_tunnelIndex, const IceUtil::Optional< ::std::string>& __p_moreInfo, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_peLogin(__p_info, __p_remoteIp, __p_localIp, __p_tunnelIndex, __p_moreInfo, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_peLogin(const ::PerpcIce::PeGuestInfo& __p_info, const ::std::string& __p_remoteIp, const ::std::string& __p_localIp, ::Ice::Int __p_tunnelIndex, const IceUtil::Optional< ::std::string>& __p_moreInfo, const ::BoxLogic::Callback_Logic_peLoginPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_peLogin(__p_info, __p_remoteIp, __p_localIp, __p_tunnelIndex, __p_moreInfo, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_peLogin(const ::PerpcIce::PeGuestInfo& __p_info, const ::std::string& __p_remoteIp, const ::std::string& __p_localIp, ::Ice::Int __p_tunnelIndex, const IceUtil::Optional< ::std::string>& __p_moreInfo, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_Logic_peLoginPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_peLogin(__p_info, __p_remoteIp, __p_localIp, __p_tunnelIndex, __p_moreInfo, &__ctx, __del, __cookie);
    }

    ::std::string end_peLogin(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string peLogin(const ::PerpcIce::PeGuestInfo&, const ::std::string&, const ::std::string&, ::Ice::Int, const IceUtil::Optional< ::std::string>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_peLogin(const ::PerpcIce::PeGuestInfo&, const ::std::string&, const ::std::string&, ::Ice::Int, const IceUtil::Optional< ::std::string>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void peLogout(const ::std::string& __p_peName)
    {
        peLogout(__p_peName, 0);
    }
    void peLogout(const ::std::string& __p_peName, const ::Ice::Context& __ctx)
    {
        peLogout(__p_peName, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_peLogout(const ::std::string& __p_peName, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_peLogout(__p_peName, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_peLogout(const ::std::string& __p_peName, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_peLogout(__p_peName, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_peLogout(const ::std::string& __p_peName, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_peLogout(__p_peName, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_peLogout(const ::std::string& __p_peName, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_peLogout(__p_peName, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_peLogout(const ::std::string& __p_peName)
    {
        return begin_peLogout(__p_peName, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_peLogout(const ::std::string& __p_peName, const ::Ice::Context& __ctx)
    {
        return begin_peLogout(__p_peName, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_peLogout(const ::std::string& __p_peName, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_peLogout(__p_peName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_peLogout(const ::std::string& __p_peName, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_peLogout(__p_peName, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_peLogout(const ::std::string& __p_peName, const ::BoxLogic::Callback_Logic_peLogoutPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_peLogout(__p_peName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_peLogout(const ::std::string& __p_peName, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_Logic_peLogoutPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_peLogout(__p_peName, &__ctx, __del, __cookie);
    }

    void end_peLogout(const ::Ice::AsyncResultPtr&);
    
private:

    void peLogout(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_peLogout(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void updateCDPToken(const ::std::string& __p_token, const ::std::string& __p_lastFilePath)
    {
        updateCDPToken(__p_token, __p_lastFilePath, 0);
    }
    void updateCDPToken(const ::std::string& __p_token, const ::std::string& __p_lastFilePath, const ::Ice::Context& __ctx)
    {
        updateCDPToken(__p_token, __p_lastFilePath, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_updateCDPToken(const ::std::string& __p_token, const ::std::string& __p_lastFilePath, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_updateCDPToken(__p_token, __p_lastFilePath, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_updateCDPToken(const ::std::string& __p_token, const ::std::string& __p_lastFilePath, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_updateCDPToken(__p_token, __p_lastFilePath, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_updateCDPToken(const ::std::string& __p_token, const ::std::string& __p_lastFilePath, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_updateCDPToken(__p_token, __p_lastFilePath, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_updateCDPToken(const ::std::string& __p_token, const ::std::string& __p_lastFilePath, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_updateCDPToken(__p_token, __p_lastFilePath, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_updateCDPToken(const ::std::string& __p_token, const ::std::string& __p_lastFilePath, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_updateCDPToken(const ::std::string& __p_token, const ::std::string& __p_lastFilePath)
    {
        return begin_updateCDPToken(__p_token, __p_lastFilePath, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_updateCDPToken(const ::std::string& __p_token, const ::std::string& __p_lastFilePath, const ::Ice::Context& __ctx)
    {
        return begin_updateCDPToken(__p_token, __p_lastFilePath, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_updateCDPToken(const ::std::string& __p_token, const ::std::string& __p_lastFilePath, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updateCDPToken(__p_token, __p_lastFilePath, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_updateCDPToken(const ::std::string& __p_token, const ::std::string& __p_lastFilePath, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updateCDPToken(__p_token, __p_lastFilePath, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_updateCDPToken(const ::std::string& __p_token, const ::std::string& __p_lastFilePath, const ::BoxLogic::Callback_Logic_updateCDPTokenPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updateCDPToken(__p_token, __p_lastFilePath, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_updateCDPToken(const ::std::string& __p_token, const ::std::string& __p_lastFilePath, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_Logic_updateCDPTokenPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updateCDPToken(__p_token, __p_lastFilePath, &__ctx, __del, __cookie);
    }

    void end_updateCDPToken(const ::Ice::AsyncResultPtr&);
    
private:

    void updateCDPToken(const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_updateCDPToken(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void updateTrafficControl(const ::std::string& __p_token, ::Ice::Long __p_ioSession)
    {
        updateTrafficControl(__p_token, __p_ioSession, 0);
    }
    void updateTrafficControl(const ::std::string& __p_token, ::Ice::Long __p_ioSession, const ::Ice::Context& __ctx)
    {
        updateTrafficControl(__p_token, __p_ioSession, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_updateTrafficControl(const ::std::string& __p_token, ::Ice::Long __p_ioSession, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_updateTrafficControl(__p_token, __p_ioSession, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_updateTrafficControl(const ::std::string& __p_token, ::Ice::Long __p_ioSession, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_updateTrafficControl(__p_token, __p_ioSession, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_updateTrafficControl(const ::std::string& __p_token, ::Ice::Long __p_ioSession, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_updateTrafficControl(__p_token, __p_ioSession, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_updateTrafficControl(const ::std::string& __p_token, ::Ice::Long __p_ioSession, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_updateTrafficControl(__p_token, __p_ioSession, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_updateTrafficControl(const ::std::string& __p_token, ::Ice::Long __p_ioSession, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_updateTrafficControl(const ::std::string& __p_token, ::Ice::Long __p_ioSession)
    {
        return begin_updateTrafficControl(__p_token, __p_ioSession, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_updateTrafficControl(const ::std::string& __p_token, ::Ice::Long __p_ioSession, const ::Ice::Context& __ctx)
    {
        return begin_updateTrafficControl(__p_token, __p_ioSession, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_updateTrafficControl(const ::std::string& __p_token, ::Ice::Long __p_ioSession, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updateTrafficControl(__p_token, __p_ioSession, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_updateTrafficControl(const ::std::string& __p_token, ::Ice::Long __p_ioSession, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updateTrafficControl(__p_token, __p_ioSession, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_updateTrafficControl(const ::std::string& __p_token, ::Ice::Long __p_ioSession, const ::BoxLogic::Callback_Logic_updateTrafficControlPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updateTrafficControl(__p_token, __p_ioSession, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_updateTrafficControl(const ::std::string& __p_token, ::Ice::Long __p_ioSession, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_Logic_updateTrafficControlPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updateTrafficControl(__p_token, __p_ioSession, &__ctx, __del, __cookie);
    }

    void end_updateTrafficControl(const ::Ice::AsyncResultPtr&);
    
private:

    void updateTrafficControl(const ::std::string&, ::Ice::Long, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_updateTrafficControl(const ::std::string&, ::Ice::Long, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void updateRestoreToken(const ::std::string& __p_updateConfig)
    {
        updateRestoreToken(__p_updateConfig, 0);
    }
    void updateRestoreToken(const ::std::string& __p_updateConfig, const ::Ice::Context& __ctx)
    {
        updateRestoreToken(__p_updateConfig, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_updateRestoreToken(const ::std::string& __p_updateConfig, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_updateRestoreToken(__p_updateConfig, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_updateRestoreToken(const ::std::string& __p_updateConfig, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_updateRestoreToken(__p_updateConfig, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_updateRestoreToken(const ::std::string& __p_updateConfig, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_updateRestoreToken(__p_updateConfig, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_updateRestoreToken(const ::std::string& __p_updateConfig, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_updateRestoreToken(__p_updateConfig, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_updateRestoreToken(const ::std::string& __p_updateConfig, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_updateRestoreToken(const ::std::string& __p_updateConfig)
    {
        return begin_updateRestoreToken(__p_updateConfig, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_updateRestoreToken(const ::std::string& __p_updateConfig, const ::Ice::Context& __ctx)
    {
        return begin_updateRestoreToken(__p_updateConfig, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_updateRestoreToken(const ::std::string& __p_updateConfig, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updateRestoreToken(__p_updateConfig, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_updateRestoreToken(const ::std::string& __p_updateConfig, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updateRestoreToken(__p_updateConfig, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_updateRestoreToken(const ::std::string& __p_updateConfig, const ::BoxLogic::Callback_Logic_updateRestoreTokenPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updateRestoreToken(__p_updateConfig, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_updateRestoreToken(const ::std::string& __p_updateConfig, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_Logic_updateRestoreTokenPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_updateRestoreToken(__p_updateConfig, &__ctx, __del, __cookie);
    }

    void end_updateRestoreToken(const ::Ice::AsyncResultPtr&);
    
private:

    void updateRestoreToken(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_updateRestoreToken(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void closeCDPToken(const ::std::string& __p_token)
    {
        closeCDPToken(__p_token, 0);
    }
    void closeCDPToken(const ::std::string& __p_token, const ::Ice::Context& __ctx)
    {
        closeCDPToken(__p_token, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_closeCDPToken(const ::std::string& __p_token, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_closeCDPToken(__p_token, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_closeCDPToken(const ::std::string& __p_token, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_closeCDPToken(__p_token, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_closeCDPToken(const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_closeCDPToken(__p_token, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_closeCDPToken(const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_closeCDPToken(__p_token, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_closeCDPToken(const ::std::string& __p_token, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_closeCDPToken(const ::std::string& __p_token)
    {
        return begin_closeCDPToken(__p_token, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_closeCDPToken(const ::std::string& __p_token, const ::Ice::Context& __ctx)
    {
        return begin_closeCDPToken(__p_token, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_closeCDPToken(const ::std::string& __p_token, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_closeCDPToken(__p_token, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_closeCDPToken(const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_closeCDPToken(__p_token, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_closeCDPToken(const ::std::string& __p_token, const ::BoxLogic::Callback_Logic_closeCDPTokenPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_closeCDPToken(__p_token, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_closeCDPToken(const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_Logic_closeCDPTokenPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_closeCDPToken(__p_token, &__ctx, __del, __cookie);
    }

    void end_closeCDPToken(const ::Ice::AsyncResultPtr&);
    
private:

    void closeCDPToken(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_closeCDPToken(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void refreshSnapshotToken(const ::std::string& __p_token)
    {
        refreshSnapshotToken(__p_token, 0);
    }
    void refreshSnapshotToken(const ::std::string& __p_token, const ::Ice::Context& __ctx)
    {
        refreshSnapshotToken(__p_token, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_refreshSnapshotToken(const ::std::string& __p_token, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_refreshSnapshotToken(__p_token, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_refreshSnapshotToken(const ::std::string& __p_token, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_refreshSnapshotToken(__p_token, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_refreshSnapshotToken(const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_refreshSnapshotToken(__p_token, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_refreshSnapshotToken(const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_refreshSnapshotToken(__p_token, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_refreshSnapshotToken(const ::std::string& __p_token, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_refreshSnapshotToken(const ::std::string& __p_token)
    {
        return begin_refreshSnapshotToken(__p_token, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_refreshSnapshotToken(const ::std::string& __p_token, const ::Ice::Context& __ctx)
    {
        return begin_refreshSnapshotToken(__p_token, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_refreshSnapshotToken(const ::std::string& __p_token, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_refreshSnapshotToken(__p_token, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_refreshSnapshotToken(const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_refreshSnapshotToken(__p_token, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_refreshSnapshotToken(const ::std::string& __p_token, const ::BoxLogic::Callback_Logic_refreshSnapshotTokenPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_refreshSnapshotToken(__p_token, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_refreshSnapshotToken(const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_Logic_refreshSnapshotTokenPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_refreshSnapshotToken(__p_token, &__ctx, __del, __cookie);
    }

    void end_refreshSnapshotToken(const ::Ice::AsyncResultPtr&);
    
private:

    void refreshSnapshotToken(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_refreshSnapshotToken(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void reportRestoreStatus(const ::std::string& __p_token, const ::BoxLogic::RestoreProgress& __p_progress, bool __p_finished, const IceUtil::Optional< ::std::string>& __p_hostIdent)
    {
        reportRestoreStatus(__p_token, __p_progress, __p_finished, __p_hostIdent, 0);
    }
    void reportRestoreStatus(const ::std::string& __p_token, const ::BoxLogic::RestoreProgress& __p_progress, bool __p_finished, const IceUtil::Optional< ::std::string>& __p_hostIdent, const ::Ice::Context& __ctx)
    {
        reportRestoreStatus(__p_token, __p_progress, __p_finished, __p_hostIdent, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_reportRestoreStatus(const ::std::string& __p_token, const ::BoxLogic::RestoreProgress& __p_progress, bool __p_finished, const IceUtil::Optional< ::std::string>& __p_hostIdent, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_reportRestoreStatus(__p_token, __p_progress, __p_finished, __p_hostIdent, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_reportRestoreStatus(const ::std::string& __p_token, const ::BoxLogic::RestoreProgress& __p_progress, bool __p_finished, const IceUtil::Optional< ::std::string>& __p_hostIdent, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_reportRestoreStatus(__p_token, __p_progress, __p_finished, __p_hostIdent, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_reportRestoreStatus(const ::std::string& __p_token, const ::BoxLogic::RestoreProgress& __p_progress, bool __p_finished, const IceUtil::Optional< ::std::string>& __p_hostIdent, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_reportRestoreStatus(__p_token, __p_progress, __p_finished, __p_hostIdent, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_reportRestoreStatus(const ::std::string& __p_token, const ::BoxLogic::RestoreProgress& __p_progress, bool __p_finished, const IceUtil::Optional< ::std::string>& __p_hostIdent, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_reportRestoreStatus(__p_token, __p_progress, __p_finished, __p_hostIdent, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_reportRestoreStatus(const ::std::string& __p_token, const ::BoxLogic::RestoreProgress& __p_progress, bool __p_finished, const IceUtil::Optional< ::std::string>& __p_hostIdent, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_reportRestoreStatus(const ::std::string& __p_token, const ::BoxLogic::RestoreProgress& __p_progress, bool __p_finished, const IceUtil::Optional< ::std::string>& __p_hostIdent)
    {
        return begin_reportRestoreStatus(__p_token, __p_progress, __p_finished, __p_hostIdent, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reportRestoreStatus(const ::std::string& __p_token, const ::BoxLogic::RestoreProgress& __p_progress, bool __p_finished, const IceUtil::Optional< ::std::string>& __p_hostIdent, const ::Ice::Context& __ctx)
    {
        return begin_reportRestoreStatus(__p_token, __p_progress, __p_finished, __p_hostIdent, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reportRestoreStatus(const ::std::string& __p_token, const ::BoxLogic::RestoreProgress& __p_progress, bool __p_finished, const IceUtil::Optional< ::std::string>& __p_hostIdent, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reportRestoreStatus(__p_token, __p_progress, __p_finished, __p_hostIdent, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reportRestoreStatus(const ::std::string& __p_token, const ::BoxLogic::RestoreProgress& __p_progress, bool __p_finished, const IceUtil::Optional< ::std::string>& __p_hostIdent, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reportRestoreStatus(__p_token, __p_progress, __p_finished, __p_hostIdent, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reportRestoreStatus(const ::std::string& __p_token, const ::BoxLogic::RestoreProgress& __p_progress, bool __p_finished, const IceUtil::Optional< ::std::string>& __p_hostIdent, const ::BoxLogic::Callback_Logic_reportRestoreStatusPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reportRestoreStatus(__p_token, __p_progress, __p_finished, __p_hostIdent, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reportRestoreStatus(const ::std::string& __p_token, const ::BoxLogic::RestoreProgress& __p_progress, bool __p_finished, const IceUtil::Optional< ::std::string>& __p_hostIdent, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_Logic_reportRestoreStatusPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reportRestoreStatus(__p_token, __p_progress, __p_finished, __p_hostIdent, &__ctx, __del, __cookie);
    }

    void end_reportRestoreStatus(const ::Ice::AsyncResultPtr&);
    
private:

    void reportRestoreStatus(const ::std::string&, const ::BoxLogic::RestoreProgress&, bool, const IceUtil::Optional< ::std::string>&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_reportRestoreStatus(const ::std::string&, const ::BoxLogic::RestoreProgress&, bool, const IceUtil::Optional< ::std::string>&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string QueryJsonData(const ::std::string& __p_hostName, const ::std::string& __p_inputJson)
    {
        return QueryJsonData(__p_hostName, __p_inputJson, 0);
    }
    ::std::string QueryJsonData(const ::std::string& __p_hostName, const ::std::string& __p_inputJson, const ::Ice::Context& __ctx)
    {
        return QueryJsonData(__p_hostName, __p_inputJson, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_QueryJsonData(const ::std::string& __p_hostName, const ::std::string& __p_inputJson, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_QueryJsonData(__p_hostName, __p_inputJson, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_QueryJsonData(const ::std::string& __p_hostName, const ::std::string& __p_inputJson, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_QueryJsonData(__p_hostName, __p_inputJson, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_QueryJsonData(const ::std::string& __p_hostName, const ::std::string& __p_inputJson, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_QueryJsonData(__p_hostName, __p_inputJson, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_QueryJsonData(const ::std::string& __p_hostName, const ::std::string& __p_inputJson, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_QueryJsonData(__p_hostName, __p_inputJson, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_QueryJsonData(const ::std::string& __p_hostName, const ::std::string& __p_inputJson, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_QueryJsonData(const ::std::string& __p_hostName, const ::std::string& __p_inputJson)
    {
        return begin_QueryJsonData(__p_hostName, __p_inputJson, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_QueryJsonData(const ::std::string& __p_hostName, const ::std::string& __p_inputJson, const ::Ice::Context& __ctx)
    {
        return begin_QueryJsonData(__p_hostName, __p_inputJson, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_QueryJsonData(const ::std::string& __p_hostName, const ::std::string& __p_inputJson, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_QueryJsonData(__p_hostName, __p_inputJson, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_QueryJsonData(const ::std::string& __p_hostName, const ::std::string& __p_inputJson, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_QueryJsonData(__p_hostName, __p_inputJson, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_QueryJsonData(const ::std::string& __p_hostName, const ::std::string& __p_inputJson, const ::BoxLogic::Callback_Logic_QueryJsonDataPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_QueryJsonData(__p_hostName, __p_inputJson, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_QueryJsonData(const ::std::string& __p_hostName, const ::std::string& __p_inputJson, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_Logic_QueryJsonDataPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_QueryJsonData(__p_hostName, __p_inputJson, &__ctx, __del, __cookie);
    }

    ::std::string end_QueryJsonData(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string QueryJsonData(const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_QueryJsonData(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void startKvm(const ::std::string& __p_peHostIdent)
    {
        startKvm(__p_peHostIdent, 0);
    }
    void startKvm(const ::std::string& __p_peHostIdent, const ::Ice::Context& __ctx)
    {
        startKvm(__p_peHostIdent, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_startKvm(const ::std::string& __p_peHostIdent, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_startKvm(__p_peHostIdent, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_startKvm(const ::std::string& __p_peHostIdent, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_startKvm(__p_peHostIdent, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_startKvm(const ::std::string& __p_peHostIdent, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_startKvm(__p_peHostIdent, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_startKvm(const ::std::string& __p_peHostIdent, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_startKvm(__p_peHostIdent, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_startKvm(const ::std::string& __p_peHostIdent, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_startKvm(const ::std::string& __p_peHostIdent)
    {
        return begin_startKvm(__p_peHostIdent, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_startKvm(const ::std::string& __p_peHostIdent, const ::Ice::Context& __ctx)
    {
        return begin_startKvm(__p_peHostIdent, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_startKvm(const ::std::string& __p_peHostIdent, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_startKvm(__p_peHostIdent, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_startKvm(const ::std::string& __p_peHostIdent, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_startKvm(__p_peHostIdent, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_startKvm(const ::std::string& __p_peHostIdent, const ::BoxLogic::Callback_Logic_startKvmPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_startKvm(__p_peHostIdent, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_startKvm(const ::std::string& __p_peHostIdent, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_Logic_startKvmPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_startKvm(__p_peHostIdent, &__ctx, __del, __cookie);
    }

    void end_startKvm(const ::Ice::AsyncResultPtr&);
    
private:

    void startKvm(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_startKvm(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void fetchProxyEndPoints()
    {
        fetchProxyEndPoints(0);
    }
    void fetchProxyEndPoints(const ::Ice::Context& __ctx)
    {
        fetchProxyEndPoints(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_fetchProxyEndPoints(const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_fetchProxyEndPoints(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_fetchProxyEndPoints(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_fetchProxyEndPoints(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_fetchProxyEndPoints(const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_fetchProxyEndPoints(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_fetchProxyEndPoints(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_fetchProxyEndPoints(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_fetchProxyEndPoints(const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_fetchProxyEndPoints()
    {
        return begin_fetchProxyEndPoints(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_fetchProxyEndPoints(const ::Ice::Context& __ctx)
    {
        return begin_fetchProxyEndPoints(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_fetchProxyEndPoints(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fetchProxyEndPoints(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_fetchProxyEndPoints(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fetchProxyEndPoints(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_fetchProxyEndPoints(const ::BoxLogic::Callback_Logic_fetchProxyEndPointsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fetchProxyEndPoints(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_fetchProxyEndPoints(const ::Ice::Context& __ctx, const ::BoxLogic::Callback_Logic_fetchProxyEndPointsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fetchProxyEndPoints(&__ctx, __del, __cookie);
    }

    void end_fetchProxyEndPoints(const ::Ice::AsyncResultPtr&);
    
private:

    void fetchProxyEndPoints(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_fetchProxyEndPoints(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::BoxLogic::LastCdpDetail queryLastCdpDetailByRestoreToken(const ::std::string& __p_token)
    {
        return queryLastCdpDetailByRestoreToken(__p_token, 0);
    }
    ::BoxLogic::LastCdpDetail queryLastCdpDetailByRestoreToken(const ::std::string& __p_token, const ::Ice::Context& __ctx)
    {
        return queryLastCdpDetailByRestoreToken(__p_token, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_queryLastCdpDetailByRestoreToken(const ::std::string& __p_token, const ::IceInternal::Function<void (const ::BoxLogic::LastCdpDetail&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_queryLastCdpDetailByRestoreToken(__p_token, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_queryLastCdpDetailByRestoreToken(const ::std::string& __p_token, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_queryLastCdpDetailByRestoreToken(__p_token, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_queryLastCdpDetailByRestoreToken(const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::BoxLogic::LastCdpDetail&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_queryLastCdpDetailByRestoreToken(__p_token, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_queryLastCdpDetailByRestoreToken(const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_queryLastCdpDetailByRestoreToken(__p_token, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_queryLastCdpDetailByRestoreToken(const ::std::string& __p_token, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::BoxLogic::LastCdpDetail&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_queryLastCdpDetailByRestoreToken(const ::std::string& __p_token)
    {
        return begin_queryLastCdpDetailByRestoreToken(__p_token, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_queryLastCdpDetailByRestoreToken(const ::std::string& __p_token, const ::Ice::Context& __ctx)
    {
        return begin_queryLastCdpDetailByRestoreToken(__p_token, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_queryLastCdpDetailByRestoreToken(const ::std::string& __p_token, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryLastCdpDetailByRestoreToken(__p_token, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryLastCdpDetailByRestoreToken(const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryLastCdpDetailByRestoreToken(__p_token, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryLastCdpDetailByRestoreToken(const ::std::string& __p_token, const ::BoxLogic::Callback_Logic_queryLastCdpDetailByRestoreTokenPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryLastCdpDetailByRestoreToken(__p_token, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryLastCdpDetailByRestoreToken(const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_Logic_queryLastCdpDetailByRestoreTokenPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryLastCdpDetailByRestoreToken(__p_token, &__ctx, __del, __cookie);
    }

    ::BoxLogic::LastCdpDetail end_queryLastCdpDetailByRestoreToken(const ::Ice::AsyncResultPtr&);
    
private:

    ::BoxLogic::LastCdpDetail queryLastCdpDetailByRestoreToken(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_queryLastCdpDetailByRestoreToken(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool queryLastCdpDetailByCdpToken(const ::std::string& __p_token, const ::std::string& __p_hostName, ::BoxLogic::LastCdpDetail& __p_detail)
    {
        return queryLastCdpDetailByCdpToken(__p_token, __p_hostName, __p_detail, 0);
    }
    bool queryLastCdpDetailByCdpToken(const ::std::string& __p_token, const ::std::string& __p_hostName, ::BoxLogic::LastCdpDetail& __p_detail, const ::Ice::Context& __ctx)
    {
        return queryLastCdpDetailByCdpToken(__p_token, __p_hostName, __p_detail, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_queryLastCdpDetailByCdpToken(const ::std::string& __p_token, const ::std::string& __p_hostName, const ::IceInternal::Function<void (bool, const ::BoxLogic::LastCdpDetail&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_queryLastCdpDetailByCdpToken(__p_token, __p_hostName, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_queryLastCdpDetailByCdpToken(const ::std::string& __p_token, const ::std::string& __p_hostName, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_queryLastCdpDetailByCdpToken(__p_token, __p_hostName, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_queryLastCdpDetailByCdpToken(const ::std::string& __p_token, const ::std::string& __p_hostName, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (bool, const ::BoxLogic::LastCdpDetail&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_queryLastCdpDetailByCdpToken(__p_token, __p_hostName, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_queryLastCdpDetailByCdpToken(const ::std::string& __p_token, const ::std::string& __p_hostName, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_queryLastCdpDetailByCdpToken(__p_token, __p_hostName, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_queryLastCdpDetailByCdpToken(const ::std::string& __p_token, const ::std::string& __p_hostName, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool, const ::BoxLogic::LastCdpDetail&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_queryLastCdpDetailByCdpToken(const ::std::string& __p_token, const ::std::string& __p_hostName)
    {
        return begin_queryLastCdpDetailByCdpToken(__p_token, __p_hostName, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_queryLastCdpDetailByCdpToken(const ::std::string& __p_token, const ::std::string& __p_hostName, const ::Ice::Context& __ctx)
    {
        return begin_queryLastCdpDetailByCdpToken(__p_token, __p_hostName, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_queryLastCdpDetailByCdpToken(const ::std::string& __p_token, const ::std::string& __p_hostName, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryLastCdpDetailByCdpToken(__p_token, __p_hostName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryLastCdpDetailByCdpToken(const ::std::string& __p_token, const ::std::string& __p_hostName, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryLastCdpDetailByCdpToken(__p_token, __p_hostName, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryLastCdpDetailByCdpToken(const ::std::string& __p_token, const ::std::string& __p_hostName, const ::BoxLogic::Callback_Logic_queryLastCdpDetailByCdpTokenPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryLastCdpDetailByCdpToken(__p_token, __p_hostName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryLastCdpDetailByCdpToken(const ::std::string& __p_token, const ::std::string& __p_hostName, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_Logic_queryLastCdpDetailByCdpTokenPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryLastCdpDetailByCdpToken(__p_token, __p_hostName, &__ctx, __del, __cookie);
    }

    bool end_queryLastCdpDetailByCdpToken(::BoxLogic::LastCdpDetail& __p_detail, const ::Ice::AsyncResultPtr&);
    
private:

    bool queryLastCdpDetailByCdpToken(const ::std::string&, const ::std::string&, ::BoxLogic::LastCdpDetail&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_queryLastCdpDetailByCdpToken(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string queryNetworkTransmissionType(const ::std::string& __p_info)
    {
        return queryNetworkTransmissionType(__p_info, 0);
    }
    ::std::string queryNetworkTransmissionType(const ::std::string& __p_info, const ::Ice::Context& __ctx)
    {
        return queryNetworkTransmissionType(__p_info, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_queryNetworkTransmissionType(const ::std::string& __p_info, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_queryNetworkTransmissionType(__p_info, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_queryNetworkTransmissionType(const ::std::string& __p_info, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_queryNetworkTransmissionType(__p_info, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_queryNetworkTransmissionType(const ::std::string& __p_info, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_queryNetworkTransmissionType(__p_info, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_queryNetworkTransmissionType(const ::std::string& __p_info, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_queryNetworkTransmissionType(__p_info, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_queryNetworkTransmissionType(const ::std::string& __p_info, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_queryNetworkTransmissionType(const ::std::string& __p_info)
    {
        return begin_queryNetworkTransmissionType(__p_info, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_queryNetworkTransmissionType(const ::std::string& __p_info, const ::Ice::Context& __ctx)
    {
        return begin_queryNetworkTransmissionType(__p_info, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_queryNetworkTransmissionType(const ::std::string& __p_info, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryNetworkTransmissionType(__p_info, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryNetworkTransmissionType(const ::std::string& __p_info, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryNetworkTransmissionType(__p_info, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryNetworkTransmissionType(const ::std::string& __p_info, const ::BoxLogic::Callback_Logic_queryNetworkTransmissionTypePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryNetworkTransmissionType(__p_info, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryNetworkTransmissionType(const ::std::string& __p_info, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_Logic_queryNetworkTransmissionTypePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryNetworkTransmissionType(__p_info, &__ctx, __del, __cookie);
    }

    ::std::string end_queryNetworkTransmissionType(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string queryNetworkTransmissionType(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_queryNetworkTransmissionType(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int dataQueuingReport(const ::std::string& __p_jsonContent)
    {
        return dataQueuingReport(__p_jsonContent, 0);
    }
    ::Ice::Int dataQueuingReport(const ::std::string& __p_jsonContent, const ::Ice::Context& __ctx)
    {
        return dataQueuingReport(__p_jsonContent, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_dataQueuingReport(const ::std::string& __p_jsonContent, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_dataQueuingReport(__p_jsonContent, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_dataQueuingReport(const ::std::string& __p_jsonContent, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_dataQueuingReport(__p_jsonContent, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_dataQueuingReport(const ::std::string& __p_jsonContent, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_dataQueuingReport(__p_jsonContent, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_dataQueuingReport(const ::std::string& __p_jsonContent, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_dataQueuingReport(__p_jsonContent, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_dataQueuingReport(const ::std::string& __p_jsonContent, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_dataQueuingReport(const ::std::string& __p_jsonContent)
    {
        return begin_dataQueuingReport(__p_jsonContent, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_dataQueuingReport(const ::std::string& __p_jsonContent, const ::Ice::Context& __ctx)
    {
        return begin_dataQueuingReport(__p_jsonContent, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_dataQueuingReport(const ::std::string& __p_jsonContent, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_dataQueuingReport(__p_jsonContent, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_dataQueuingReport(const ::std::string& __p_jsonContent, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_dataQueuingReport(__p_jsonContent, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_dataQueuingReport(const ::std::string& __p_jsonContent, const ::BoxLogic::Callback_Logic_dataQueuingReportPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_dataQueuingReport(__p_jsonContent, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_dataQueuingReport(const ::std::string& __p_jsonContent, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_Logic_dataQueuingReportPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_dataQueuingReport(__p_jsonContent, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_dataQueuingReport(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int dataQueuingReport(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_dataQueuingReport(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string getHashFilePathByRestoreToken(const ::std::string& __p_token)
    {
        return getHashFilePathByRestoreToken(__p_token, 0);
    }
    ::std::string getHashFilePathByRestoreToken(const ::std::string& __p_token, const ::Ice::Context& __ctx)
    {
        return getHashFilePathByRestoreToken(__p_token, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getHashFilePathByRestoreToken(const ::std::string& __p_token, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getHashFilePathByRestoreToken(__p_token, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getHashFilePathByRestoreToken(const ::std::string& __p_token, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getHashFilePathByRestoreToken(__p_token, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getHashFilePathByRestoreToken(const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getHashFilePathByRestoreToken(__p_token, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getHashFilePathByRestoreToken(const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getHashFilePathByRestoreToken(__p_token, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getHashFilePathByRestoreToken(const ::std::string& __p_token, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getHashFilePathByRestoreToken(const ::std::string& __p_token)
    {
        return begin_getHashFilePathByRestoreToken(__p_token, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getHashFilePathByRestoreToken(const ::std::string& __p_token, const ::Ice::Context& __ctx)
    {
        return begin_getHashFilePathByRestoreToken(__p_token, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getHashFilePathByRestoreToken(const ::std::string& __p_token, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getHashFilePathByRestoreToken(__p_token, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getHashFilePathByRestoreToken(const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getHashFilePathByRestoreToken(__p_token, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getHashFilePathByRestoreToken(const ::std::string& __p_token, const ::BoxLogic::Callback_Logic_getHashFilePathByRestoreTokenPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getHashFilePathByRestoreToken(__p_token, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getHashFilePathByRestoreToken(const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_Logic_getHashFilePathByRestoreTokenPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getHashFilePathByRestoreToken(__p_token, &__ctx, __del, __cookie);
    }

    ::std::string end_getHashFilePathByRestoreToken(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string getHashFilePathByRestoreToken(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getHashFilePathByRestoreToken(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void VmwareAgentReport(const ::std::string& __p_jsonContent)
    {
        VmwareAgentReport(__p_jsonContent, 0);
    }
    void VmwareAgentReport(const ::std::string& __p_jsonContent, const ::Ice::Context& __ctx)
    {
        VmwareAgentReport(__p_jsonContent, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_VmwareAgentReport(const ::std::string& __p_jsonContent, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_VmwareAgentReport(__p_jsonContent, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_VmwareAgentReport(const ::std::string& __p_jsonContent, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_VmwareAgentReport(__p_jsonContent, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_VmwareAgentReport(const ::std::string& __p_jsonContent, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_VmwareAgentReport(__p_jsonContent, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_VmwareAgentReport(const ::std::string& __p_jsonContent, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_VmwareAgentReport(__p_jsonContent, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_VmwareAgentReport(const ::std::string& __p_jsonContent, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_VmwareAgentReport(const ::std::string& __p_jsonContent)
    {
        return begin_VmwareAgentReport(__p_jsonContent, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_VmwareAgentReport(const ::std::string& __p_jsonContent, const ::Ice::Context& __ctx)
    {
        return begin_VmwareAgentReport(__p_jsonContent, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_VmwareAgentReport(const ::std::string& __p_jsonContent, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_VmwareAgentReport(__p_jsonContent, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_VmwareAgentReport(const ::std::string& __p_jsonContent, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_VmwareAgentReport(__p_jsonContent, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_VmwareAgentReport(const ::std::string& __p_jsonContent, const ::BoxLogic::Callback_Logic_VmwareAgentReportPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_VmwareAgentReport(__p_jsonContent, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_VmwareAgentReport(const ::std::string& __p_jsonContent, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_Logic_VmwareAgentReportPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_VmwareAgentReport(__p_jsonContent, &__ctx, __del, __cookie);
    }

    void end_VmwareAgentReport(const ::Ice::AsyncResultPtr&);
    
private:

    void VmwareAgentReport(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_VmwareAgentReport(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<Logic> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<Logic*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<Logic> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<Logic*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Logic> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<Logic*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<Logic> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<Logic*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Logic> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<Logic*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<Logic> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<Logic*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<Logic> ice_secure(bool __secure) const
    {
        return dynamic_cast<Logic*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<Logic> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<Logic*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<Logic> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<Logic*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<Logic> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<Logic*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<Logic> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<Logic*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<Logic> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<Logic*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Logic> ice_twoway() const
    {
        return dynamic_cast<Logic*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<Logic> ice_oneway() const
    {
        return dynamic_cast<Logic*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<Logic> ice_batchOneway() const
    {
        return dynamic_cast<Logic*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<Logic> ice_datagram() const
    {
        return dynamic_cast<Logic*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<Logic> ice_batchDatagram() const
    {
        return dynamic_cast<Logic*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<Logic> ice_compress(bool __compress) const
    {
        return dynamic_cast<Logic*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<Logic> ice_timeout(int __timeout) const
    {
        return dynamic_cast<Logic*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Logic> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<Logic*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Logic> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<Logic*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class LogicInternal : virtual public ::IceProxy::Ice::Object
{
public:

    ::std::string pathJoin(const ::BoxLogic::Paths& __p_paths)
    {
        return pathJoin(__p_paths, 0);
    }
    ::std::string pathJoin(const ::BoxLogic::Paths& __p_paths, const ::Ice::Context& __ctx)
    {
        return pathJoin(__p_paths, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_pathJoin(const ::BoxLogic::Paths& __p_paths, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_pathJoin(__p_paths, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_pathJoin(const ::BoxLogic::Paths& __p_paths, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_pathJoin(__p_paths, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_pathJoin(const ::BoxLogic::Paths& __p_paths, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_pathJoin(__p_paths, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_pathJoin(const ::BoxLogic::Paths& __p_paths, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_pathJoin(__p_paths, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_pathJoin(const ::BoxLogic::Paths& __p_paths, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_pathJoin(const ::BoxLogic::Paths& __p_paths)
    {
        return begin_pathJoin(__p_paths, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_pathJoin(const ::BoxLogic::Paths& __p_paths, const ::Ice::Context& __ctx)
    {
        return begin_pathJoin(__p_paths, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_pathJoin(const ::BoxLogic::Paths& __p_paths, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_pathJoin(__p_paths, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_pathJoin(const ::BoxLogic::Paths& __p_paths, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_pathJoin(__p_paths, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_pathJoin(const ::BoxLogic::Paths& __p_paths, const ::BoxLogic::Callback_LogicInternal_pathJoinPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_pathJoin(__p_paths, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_pathJoin(const ::BoxLogic::Paths& __p_paths, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_pathJoinPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_pathJoin(__p_paths, &__ctx, __del, __cookie);
    }

    ::std::string end_pathJoin(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string pathJoin(const ::BoxLogic::Paths&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_pathJoin(const ::BoxLogic::Paths&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool isFileExist(const ::std::string& __p_path)
    {
        return isFileExist(__p_path, 0);
    }
    bool isFileExist(const ::std::string& __p_path, const ::Ice::Context& __ctx)
    {
        return isFileExist(__p_path, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_isFileExist(const ::std::string& __p_path, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_isFileExist(__p_path, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_isFileExist(const ::std::string& __p_path, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_isFileExist(__p_path, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_isFileExist(const ::std::string& __p_path, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_isFileExist(__p_path, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_isFileExist(const ::std::string& __p_path, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_isFileExist(__p_path, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_isFileExist(const ::std::string& __p_path, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_isFileExist(const ::std::string& __p_path)
    {
        return begin_isFileExist(__p_path, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_isFileExist(const ::std::string& __p_path, const ::Ice::Context& __ctx)
    {
        return begin_isFileExist(__p_path, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_isFileExist(const ::std::string& __p_path, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isFileExist(__p_path, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isFileExist(const ::std::string& __p_path, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isFileExist(__p_path, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isFileExist(const ::std::string& __p_path, const ::BoxLogic::Callback_LogicInternal_isFileExistPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isFileExist(__p_path, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isFileExist(const ::std::string& __p_path, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_isFileExistPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isFileExist(__p_path, &__ctx, __del, __cookie);
    }

    bool end_isFileExist(const ::Ice::AsyncResultPtr&);
    
private:

    bool isFileExist(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_isFileExist(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool AllFilesExist(const ::BoxLogic::Paths& __p_paths)
    {
        return AllFilesExist(__p_paths, 0);
    }
    bool AllFilesExist(const ::BoxLogic::Paths& __p_paths, const ::Ice::Context& __ctx)
    {
        return AllFilesExist(__p_paths, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_AllFilesExist(const ::BoxLogic::Paths& __p_paths, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_AllFilesExist(__p_paths, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_AllFilesExist(const ::BoxLogic::Paths& __p_paths, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_AllFilesExist(__p_paths, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_AllFilesExist(const ::BoxLogic::Paths& __p_paths, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_AllFilesExist(__p_paths, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_AllFilesExist(const ::BoxLogic::Paths& __p_paths, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_AllFilesExist(__p_paths, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_AllFilesExist(const ::BoxLogic::Paths& __p_paths, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_AllFilesExist(const ::BoxLogic::Paths& __p_paths)
    {
        return begin_AllFilesExist(__p_paths, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_AllFilesExist(const ::BoxLogic::Paths& __p_paths, const ::Ice::Context& __ctx)
    {
        return begin_AllFilesExist(__p_paths, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_AllFilesExist(const ::BoxLogic::Paths& __p_paths, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_AllFilesExist(__p_paths, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_AllFilesExist(const ::BoxLogic::Paths& __p_paths, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_AllFilesExist(__p_paths, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_AllFilesExist(const ::BoxLogic::Paths& __p_paths, const ::BoxLogic::Callback_LogicInternal_AllFilesExistPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_AllFilesExist(__p_paths, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_AllFilesExist(const ::BoxLogic::Paths& __p_paths, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_AllFilesExistPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_AllFilesExist(__p_paths, &__ctx, __del, __cookie);
    }

    bool end_AllFilesExist(const ::Ice::AsyncResultPtr&);
    
private:

    bool AllFilesExist(const ::BoxLogic::Paths&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_AllFilesExist(const ::BoxLogic::Paths&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool isFolderExist(const ::std::string& __p_path)
    {
        return isFolderExist(__p_path, 0);
    }
    bool isFolderExist(const ::std::string& __p_path, const ::Ice::Context& __ctx)
    {
        return isFolderExist(__p_path, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_isFolderExist(const ::std::string& __p_path, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_isFolderExist(__p_path, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_isFolderExist(const ::std::string& __p_path, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_isFolderExist(__p_path, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_isFolderExist(const ::std::string& __p_path, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_isFolderExist(__p_path, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_isFolderExist(const ::std::string& __p_path, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_isFolderExist(__p_path, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_isFolderExist(const ::std::string& __p_path, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_isFolderExist(const ::std::string& __p_path)
    {
        return begin_isFolderExist(__p_path, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_isFolderExist(const ::std::string& __p_path, const ::Ice::Context& __ctx)
    {
        return begin_isFolderExist(__p_path, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_isFolderExist(const ::std::string& __p_path, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isFolderExist(__p_path, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isFolderExist(const ::std::string& __p_path, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isFolderExist(__p_path, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isFolderExist(const ::std::string& __p_path, const ::BoxLogic::Callback_LogicInternal_isFolderExistPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isFolderExist(__p_path, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isFolderExist(const ::std::string& __p_path, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_isFolderExistPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isFolderExist(__p_path, &__ctx, __del, __cookie);
    }

    bool end_isFolderExist(const ::Ice::AsyncResultPtr&);
    
private:

    bool isFolderExist(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_isFolderExist(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void makeDirs(const ::std::string& __p_path, bool __p_existOk, ::Ice::Short __p_mode)
    {
        makeDirs(__p_path, __p_existOk, __p_mode, 0);
    }
    void makeDirs(const ::std::string& __p_path, bool __p_existOk, ::Ice::Short __p_mode, const ::Ice::Context& __ctx)
    {
        makeDirs(__p_path, __p_existOk, __p_mode, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_makeDirs(const ::std::string& __p_path, bool __p_existOk, ::Ice::Short __p_mode, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_makeDirs(__p_path, __p_existOk, __p_mode, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_makeDirs(const ::std::string& __p_path, bool __p_existOk, ::Ice::Short __p_mode, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_makeDirs(__p_path, __p_existOk, __p_mode, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_makeDirs(const ::std::string& __p_path, bool __p_existOk, ::Ice::Short __p_mode, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_makeDirs(__p_path, __p_existOk, __p_mode, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_makeDirs(const ::std::string& __p_path, bool __p_existOk, ::Ice::Short __p_mode, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_makeDirs(__p_path, __p_existOk, __p_mode, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_makeDirs(const ::std::string& __p_path, bool __p_existOk, ::Ice::Short __p_mode)
    {
        return begin_makeDirs(__p_path, __p_existOk, __p_mode, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_makeDirs(const ::std::string& __p_path, bool __p_existOk, ::Ice::Short __p_mode, const ::Ice::Context& __ctx)
    {
        return begin_makeDirs(__p_path, __p_existOk, __p_mode, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_makeDirs(const ::std::string& __p_path, bool __p_existOk, ::Ice::Short __p_mode, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_makeDirs(__p_path, __p_existOk, __p_mode, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_makeDirs(const ::std::string& __p_path, bool __p_existOk, ::Ice::Short __p_mode, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_makeDirs(__p_path, __p_existOk, __p_mode, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_makeDirs(const ::std::string& __p_path, bool __p_existOk, ::Ice::Short __p_mode, const ::BoxLogic::Callback_LogicInternal_makeDirsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_makeDirs(__p_path, __p_existOk, __p_mode, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_makeDirs(const ::std::string& __p_path, bool __p_existOk, ::Ice::Short __p_mode, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_makeDirsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_makeDirs(__p_path, __p_existOk, __p_mode, &__ctx, __del, __cookie);
    }

    void end_makeDirs(const ::Ice::AsyncResultPtr&);
    
private:

    void makeDirs(const ::std::string&, bool, ::Ice::Short, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_makeDirs(const ::std::string&, bool, ::Ice::Short, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void remove(const ::std::string& __p_path)
    {
        remove(__p_path, 0);
    }
    void remove(const ::std::string& __p_path, const ::Ice::Context& __ctx)
    {
        remove(__p_path, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_remove(const ::std::string& __p_path, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_remove(__p_path, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_remove(const ::std::string& __p_path, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_remove(__p_path, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_remove(const ::std::string& __p_path, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_remove(__p_path, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_remove(const ::std::string& __p_path, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_remove(__p_path, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_remove(const ::std::string& __p_path)
    {
        return begin_remove(__p_path, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_remove(const ::std::string& __p_path, const ::Ice::Context& __ctx)
    {
        return begin_remove(__p_path, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_remove(const ::std::string& __p_path, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_remove(__p_path, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_remove(const ::std::string& __p_path, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_remove(__p_path, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_remove(const ::std::string& __p_path, const ::BoxLogic::Callback_LogicInternal_removePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_remove(__p_path, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_remove(const ::std::string& __p_path, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_removePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_remove(__p_path, &__ctx, __del, __cookie);
    }

    void end_remove(const ::Ice::AsyncResultPtr&);
    
private:

    void remove(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_remove(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void copy(const ::std::string& __p_params)
    {
        copy(__p_params, 0);
    }
    void copy(const ::std::string& __p_params, const ::Ice::Context& __ctx)
    {
        copy(__p_params, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_copy(const ::std::string& __p_params, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_copy(__p_params, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_copy(const ::std::string& __p_params, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_copy(__p_params, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_copy(const ::std::string& __p_params, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_copy(__p_params, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_copy(const ::std::string& __p_params, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_copy(__p_params, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_copy(const ::std::string& __p_params, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_copy(const ::std::string& __p_params)
    {
        return begin_copy(__p_params, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_copy(const ::std::string& __p_params, const ::Ice::Context& __ctx)
    {
        return begin_copy(__p_params, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_copy(const ::std::string& __p_params, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copy(__p_params, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_copy(const ::std::string& __p_params, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copy(__p_params, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_copy(const ::std::string& __p_params, const ::BoxLogic::Callback_LogicInternal_copyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copy(__p_params, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_copy(const ::std::string& __p_params, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_copyPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_copy(__p_params, &__ctx, __del, __cookie);
    }

    void end_copy(const ::Ice::AsyncResultPtr&);
    
private:

    void copy(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_copy(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void findFiles(const ::std::string& __p_params, ::BoxLogic::Paths& __p_paths)
    {
        findFiles(__p_params, __p_paths, 0);
    }
    void findFiles(const ::std::string& __p_params, ::BoxLogic::Paths& __p_paths, const ::Ice::Context& __ctx)
    {
        findFiles(__p_params, __p_paths, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_findFiles(const ::std::string& __p_params, const ::IceInternal::Function<void (const ::BoxLogic::Paths&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_findFiles(__p_params, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_findFiles(const ::std::string& __p_params, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_findFiles(__p_params, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_findFiles(const ::std::string& __p_params, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::BoxLogic::Paths&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_findFiles(__p_params, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_findFiles(const ::std::string& __p_params, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_findFiles(__p_params, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_findFiles(const ::std::string& __p_params, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::BoxLogic::Paths&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_findFiles(const ::std::string& __p_params)
    {
        return begin_findFiles(__p_params, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_findFiles(const ::std::string& __p_params, const ::Ice::Context& __ctx)
    {
        return begin_findFiles(__p_params, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_findFiles(const ::std::string& __p_params, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findFiles(__p_params, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_findFiles(const ::std::string& __p_params, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findFiles(__p_params, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_findFiles(const ::std::string& __p_params, const ::BoxLogic::Callback_LogicInternal_findFilesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findFiles(__p_params, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_findFiles(const ::std::string& __p_params, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_findFilesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findFiles(__p_params, &__ctx, __del, __cookie);
    }

    void end_findFiles(::BoxLogic::Paths& __p_paths, const ::Ice::AsyncResultPtr&);
    
private:

    void findFiles(const ::std::string&, ::BoxLogic::Paths&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_findFiles(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string queryCdpTimestampRange(const ::std::string& __p_path, bool __p_discardDirtyData)
    {
        return queryCdpTimestampRange(__p_path, __p_discardDirtyData, 0);
    }
    ::std::string queryCdpTimestampRange(const ::std::string& __p_path, bool __p_discardDirtyData, const ::Ice::Context& __ctx)
    {
        return queryCdpTimestampRange(__p_path, __p_discardDirtyData, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_queryCdpTimestampRange(const ::std::string& __p_path, bool __p_discardDirtyData, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_queryCdpTimestampRange(__p_path, __p_discardDirtyData, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_queryCdpTimestampRange(const ::std::string& __p_path, bool __p_discardDirtyData, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_queryCdpTimestampRange(__p_path, __p_discardDirtyData, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_queryCdpTimestampRange(const ::std::string& __p_path, bool __p_discardDirtyData, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_queryCdpTimestampRange(__p_path, __p_discardDirtyData, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_queryCdpTimestampRange(const ::std::string& __p_path, bool __p_discardDirtyData, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_queryCdpTimestampRange(__p_path, __p_discardDirtyData, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_queryCdpTimestampRange(const ::std::string& __p_path, bool __p_discardDirtyData, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_queryCdpTimestampRange(const ::std::string& __p_path, bool __p_discardDirtyData)
    {
        return begin_queryCdpTimestampRange(__p_path, __p_discardDirtyData, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_queryCdpTimestampRange(const ::std::string& __p_path, bool __p_discardDirtyData, const ::Ice::Context& __ctx)
    {
        return begin_queryCdpTimestampRange(__p_path, __p_discardDirtyData, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_queryCdpTimestampRange(const ::std::string& __p_path, bool __p_discardDirtyData, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryCdpTimestampRange(__p_path, __p_discardDirtyData, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryCdpTimestampRange(const ::std::string& __p_path, bool __p_discardDirtyData, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryCdpTimestampRange(__p_path, __p_discardDirtyData, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryCdpTimestampRange(const ::std::string& __p_path, bool __p_discardDirtyData, const ::BoxLogic::Callback_LogicInternal_queryCdpTimestampRangePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryCdpTimestampRange(__p_path, __p_discardDirtyData, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryCdpTimestampRange(const ::std::string& __p_path, bool __p_discardDirtyData, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_queryCdpTimestampRangePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryCdpTimestampRange(__p_path, __p_discardDirtyData, &__ctx, __del, __cookie);
    }

    ::std::string end_queryCdpTimestampRange(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string queryCdpTimestampRange(const ::std::string&, bool, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_queryCdpTimestampRange(const ::std::string&, bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string queryCdpTimestamp(const ::std::string& __p_path, const ::std::string& __p_timestamp)
    {
        return queryCdpTimestamp(__p_path, __p_timestamp, 0);
    }
    ::std::string queryCdpTimestamp(const ::std::string& __p_path, const ::std::string& __p_timestamp, const ::Ice::Context& __ctx)
    {
        return queryCdpTimestamp(__p_path, __p_timestamp, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_queryCdpTimestamp(const ::std::string& __p_path, const ::std::string& __p_timestamp, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_queryCdpTimestamp(__p_path, __p_timestamp, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_queryCdpTimestamp(const ::std::string& __p_path, const ::std::string& __p_timestamp, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_queryCdpTimestamp(__p_path, __p_timestamp, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_queryCdpTimestamp(const ::std::string& __p_path, const ::std::string& __p_timestamp, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_queryCdpTimestamp(__p_path, __p_timestamp, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_queryCdpTimestamp(const ::std::string& __p_path, const ::std::string& __p_timestamp, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_queryCdpTimestamp(__p_path, __p_timestamp, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_queryCdpTimestamp(const ::std::string& __p_path, const ::std::string& __p_timestamp, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_queryCdpTimestamp(const ::std::string& __p_path, const ::std::string& __p_timestamp)
    {
        return begin_queryCdpTimestamp(__p_path, __p_timestamp, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_queryCdpTimestamp(const ::std::string& __p_path, const ::std::string& __p_timestamp, const ::Ice::Context& __ctx)
    {
        return begin_queryCdpTimestamp(__p_path, __p_timestamp, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_queryCdpTimestamp(const ::std::string& __p_path, const ::std::string& __p_timestamp, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryCdpTimestamp(__p_path, __p_timestamp, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryCdpTimestamp(const ::std::string& __p_path, const ::std::string& __p_timestamp, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryCdpTimestamp(__p_path, __p_timestamp, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryCdpTimestamp(const ::std::string& __p_path, const ::std::string& __p_timestamp, const ::BoxLogic::Callback_LogicInternal_queryCdpTimestampPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryCdpTimestamp(__p_path, __p_timestamp, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryCdpTimestamp(const ::std::string& __p_path, const ::std::string& __p_timestamp, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_queryCdpTimestampPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryCdpTimestamp(__p_path, __p_timestamp, &__ctx, __del, __cookie);
    }

    ::std::string end_queryCdpTimestamp(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string queryCdpTimestamp(const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_queryCdpTimestamp(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string formatCdpTimestamp(const ::std::string& __p_timestamp)
    {
        return formatCdpTimestamp(__p_timestamp, 0);
    }
    ::std::string formatCdpTimestamp(const ::std::string& __p_timestamp, const ::Ice::Context& __ctx)
    {
        return formatCdpTimestamp(__p_timestamp, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_formatCdpTimestamp(const ::std::string& __p_timestamp, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_formatCdpTimestamp(__p_timestamp, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_formatCdpTimestamp(const ::std::string& __p_timestamp, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_formatCdpTimestamp(__p_timestamp, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_formatCdpTimestamp(const ::std::string& __p_timestamp, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_formatCdpTimestamp(__p_timestamp, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_formatCdpTimestamp(const ::std::string& __p_timestamp, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_formatCdpTimestamp(__p_timestamp, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_formatCdpTimestamp(const ::std::string& __p_timestamp, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_formatCdpTimestamp(const ::std::string& __p_timestamp)
    {
        return begin_formatCdpTimestamp(__p_timestamp, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_formatCdpTimestamp(const ::std::string& __p_timestamp, const ::Ice::Context& __ctx)
    {
        return begin_formatCdpTimestamp(__p_timestamp, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_formatCdpTimestamp(const ::std::string& __p_timestamp, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_formatCdpTimestamp(__p_timestamp, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_formatCdpTimestamp(const ::std::string& __p_timestamp, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_formatCdpTimestamp(__p_timestamp, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_formatCdpTimestamp(const ::std::string& __p_timestamp, const ::BoxLogic::Callback_LogicInternal_formatCdpTimestampPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_formatCdpTimestamp(__p_timestamp, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_formatCdpTimestamp(const ::std::string& __p_timestamp, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_formatCdpTimestampPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_formatCdpTimestamp(__p_timestamp, &__ctx, __del, __cookie);
    }

    ::std::string end_formatCdpTimestamp(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string formatCdpTimestamp(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_formatCdpTimestamp(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void mergeCdpFile(const ::std::string& __p_params)
    {
        mergeCdpFile(__p_params, 0);
    }
    void mergeCdpFile(const ::std::string& __p_params, const ::Ice::Context& __ctx)
    {
        mergeCdpFile(__p_params, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_mergeCdpFile(const ::std::string& __p_params, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_mergeCdpFile(__p_params, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_mergeCdpFile(const ::std::string& __p_params, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_mergeCdpFile(__p_params, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_mergeCdpFile(const ::std::string& __p_params, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_mergeCdpFile(__p_params, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_mergeCdpFile(const ::std::string& __p_params, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_mergeCdpFile(__p_params, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_mergeCdpFile(const ::std::string& __p_params, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_mergeCdpFile(const ::std::string& __p_params)
    {
        return begin_mergeCdpFile(__p_params, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_mergeCdpFile(const ::std::string& __p_params, const ::Ice::Context& __ctx)
    {
        return begin_mergeCdpFile(__p_params, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_mergeCdpFile(const ::std::string& __p_params, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mergeCdpFile(__p_params, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_mergeCdpFile(const ::std::string& __p_params, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mergeCdpFile(__p_params, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_mergeCdpFile(const ::std::string& __p_params, const ::BoxLogic::Callback_LogicInternal_mergeCdpFilePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mergeCdpFile(__p_params, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_mergeCdpFile(const ::std::string& __p_params, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_mergeCdpFilePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mergeCdpFile(__p_params, &__ctx, __del, __cookie);
    }

    void end_mergeCdpFile(const ::Ice::AsyncResultPtr&);
    
private:

    void mergeCdpFile(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_mergeCdpFile(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool isHardwareDriverExist(const ::BoxLogic::Hardware& __p_hardware, const ::std::string& __p_osType, const ::std::string& __p_osBit)
    {
        return isHardwareDriverExist(__p_hardware, __p_osType, __p_osBit, 0);
    }
    bool isHardwareDriverExist(const ::BoxLogic::Hardware& __p_hardware, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::Ice::Context& __ctx)
    {
        return isHardwareDriverExist(__p_hardware, __p_osType, __p_osBit, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_isHardwareDriverExist(const ::BoxLogic::Hardware& __p_hardware, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_isHardwareDriverExist(__p_hardware, __p_osType, __p_osBit, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_isHardwareDriverExist(const ::BoxLogic::Hardware& __p_hardware, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_isHardwareDriverExist(__p_hardware, __p_osType, __p_osBit, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_isHardwareDriverExist(const ::BoxLogic::Hardware& __p_hardware, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_isHardwareDriverExist(__p_hardware, __p_osType, __p_osBit, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_isHardwareDriverExist(const ::BoxLogic::Hardware& __p_hardware, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_isHardwareDriverExist(__p_hardware, __p_osType, __p_osBit, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_isHardwareDriverExist(const ::BoxLogic::Hardware& __p_hardware, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_isHardwareDriverExist(const ::BoxLogic::Hardware& __p_hardware, const ::std::string& __p_osType, const ::std::string& __p_osBit)
    {
        return begin_isHardwareDriverExist(__p_hardware, __p_osType, __p_osBit, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_isHardwareDriverExist(const ::BoxLogic::Hardware& __p_hardware, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::Ice::Context& __ctx)
    {
        return begin_isHardwareDriverExist(__p_hardware, __p_osType, __p_osBit, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_isHardwareDriverExist(const ::BoxLogic::Hardware& __p_hardware, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isHardwareDriverExist(__p_hardware, __p_osType, __p_osBit, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isHardwareDriverExist(const ::BoxLogic::Hardware& __p_hardware, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isHardwareDriverExist(__p_hardware, __p_osType, __p_osBit, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isHardwareDriverExist(const ::BoxLogic::Hardware& __p_hardware, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::BoxLogic::Callback_LogicInternal_isHardwareDriverExistPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isHardwareDriverExist(__p_hardware, __p_osType, __p_osBit, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isHardwareDriverExist(const ::BoxLogic::Hardware& __p_hardware, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_isHardwareDriverExistPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isHardwareDriverExist(__p_hardware, __p_osType, __p_osBit, &__ctx, __del, __cookie);
    }

    bool end_isHardwareDriverExist(const ::Ice::AsyncResultPtr&);
    
private:

    bool isHardwareDriverExist(const ::BoxLogic::Hardware&, const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_isHardwareDriverExist(const ::BoxLogic::Hardware&, const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string GetDriversVersions(const ::BoxLogic::Hardware& __p_hardware, const ::std::string& __p_osType, const ::std::string& __p_osBit)
    {
        return GetDriversVersions(__p_hardware, __p_osType, __p_osBit, 0);
    }
    ::std::string GetDriversVersions(const ::BoxLogic::Hardware& __p_hardware, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::Ice::Context& __ctx)
    {
        return GetDriversVersions(__p_hardware, __p_osType, __p_osBit, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_GetDriversVersions(const ::BoxLogic::Hardware& __p_hardware, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_GetDriversVersions(__p_hardware, __p_osType, __p_osBit, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_GetDriversVersions(const ::BoxLogic::Hardware& __p_hardware, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_GetDriversVersions(__p_hardware, __p_osType, __p_osBit, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_GetDriversVersions(const ::BoxLogic::Hardware& __p_hardware, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_GetDriversVersions(__p_hardware, __p_osType, __p_osBit, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_GetDriversVersions(const ::BoxLogic::Hardware& __p_hardware, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_GetDriversVersions(__p_hardware, __p_osType, __p_osBit, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_GetDriversVersions(const ::BoxLogic::Hardware& __p_hardware, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_GetDriversVersions(const ::BoxLogic::Hardware& __p_hardware, const ::std::string& __p_osType, const ::std::string& __p_osBit)
    {
        return begin_GetDriversVersions(__p_hardware, __p_osType, __p_osBit, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetDriversVersions(const ::BoxLogic::Hardware& __p_hardware, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::Ice::Context& __ctx)
    {
        return begin_GetDriversVersions(__p_hardware, __p_osType, __p_osBit, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetDriversVersions(const ::BoxLogic::Hardware& __p_hardware, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetDriversVersions(__p_hardware, __p_osType, __p_osBit, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetDriversVersions(const ::BoxLogic::Hardware& __p_hardware, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetDriversVersions(__p_hardware, __p_osType, __p_osBit, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetDriversVersions(const ::BoxLogic::Hardware& __p_hardware, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::BoxLogic::Callback_LogicInternal_GetDriversVersionsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetDriversVersions(__p_hardware, __p_osType, __p_osBit, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetDriversVersions(const ::BoxLogic::Hardware& __p_hardware, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_GetDriversVersionsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetDriversVersions(__p_hardware, __p_osType, __p_osBit, &__ctx, __del, __cookie);
    }

    ::std::string end_GetDriversVersions(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string GetDriversVersions(const ::BoxLogic::Hardware&, const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_GetDriversVersions(const ::BoxLogic::Hardware&, const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool ChkIsSubId(const ::BoxLogic::Hardware& __p_hardware)
    {
        return ChkIsSubId(__p_hardware, 0);
    }
    bool ChkIsSubId(const ::BoxLogic::Hardware& __p_hardware, const ::Ice::Context& __ctx)
    {
        return ChkIsSubId(__p_hardware, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_ChkIsSubId(const ::BoxLogic::Hardware& __p_hardware, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_ChkIsSubId(__p_hardware, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_ChkIsSubId(const ::BoxLogic::Hardware& __p_hardware, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_ChkIsSubId(__p_hardware, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_ChkIsSubId(const ::BoxLogic::Hardware& __p_hardware, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_ChkIsSubId(__p_hardware, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_ChkIsSubId(const ::BoxLogic::Hardware& __p_hardware, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_ChkIsSubId(__p_hardware, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_ChkIsSubId(const ::BoxLogic::Hardware& __p_hardware, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_ChkIsSubId(const ::BoxLogic::Hardware& __p_hardware)
    {
        return begin_ChkIsSubId(__p_hardware, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ChkIsSubId(const ::BoxLogic::Hardware& __p_hardware, const ::Ice::Context& __ctx)
    {
        return begin_ChkIsSubId(__p_hardware, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ChkIsSubId(const ::BoxLogic::Hardware& __p_hardware, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ChkIsSubId(__p_hardware, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ChkIsSubId(const ::BoxLogic::Hardware& __p_hardware, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ChkIsSubId(__p_hardware, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ChkIsSubId(const ::BoxLogic::Hardware& __p_hardware, const ::BoxLogic::Callback_LogicInternal_ChkIsSubIdPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ChkIsSubId(__p_hardware, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_ChkIsSubId(const ::BoxLogic::Hardware& __p_hardware, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_ChkIsSubIdPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_ChkIsSubId(__p_hardware, &__ctx, __del, __cookie);
    }

    bool end_ChkIsSubId(const ::Ice::AsyncResultPtr&);
    
private:

    bool ChkIsSubId(const ::BoxLogic::Hardware&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_ChkIsSubId(const ::BoxLogic::Hardware&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string GetDriversSubList(const ::std::string& __p_userSelect)
    {
        return GetDriversSubList(__p_userSelect, 0);
    }
    ::std::string GetDriversSubList(const ::std::string& __p_userSelect, const ::Ice::Context& __ctx)
    {
        return GetDriversSubList(__p_userSelect, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_GetDriversSubList(const ::std::string& __p_userSelect, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_GetDriversSubList(__p_userSelect, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_GetDriversSubList(const ::std::string& __p_userSelect, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_GetDriversSubList(__p_userSelect, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_GetDriversSubList(const ::std::string& __p_userSelect, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_GetDriversSubList(__p_userSelect, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_GetDriversSubList(const ::std::string& __p_userSelect, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_GetDriversSubList(__p_userSelect, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_GetDriversSubList(const ::std::string& __p_userSelect, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_GetDriversSubList(const ::std::string& __p_userSelect)
    {
        return begin_GetDriversSubList(__p_userSelect, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetDriversSubList(const ::std::string& __p_userSelect, const ::Ice::Context& __ctx)
    {
        return begin_GetDriversSubList(__p_userSelect, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetDriversSubList(const ::std::string& __p_userSelect, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetDriversSubList(__p_userSelect, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetDriversSubList(const ::std::string& __p_userSelect, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetDriversSubList(__p_userSelect, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetDriversSubList(const ::std::string& __p_userSelect, const ::BoxLogic::Callback_LogicInternal_GetDriversSubListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetDriversSubList(__p_userSelect, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetDriversSubList(const ::std::string& __p_userSelect, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_GetDriversSubListPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetDriversSubList(__p_userSelect, &__ctx, __del, __cookie);
    }

    ::std::string end_GetDriversSubList(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string GetDriversSubList(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_GetDriversSubList(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void generatePeStageIso(const ::std::string& __p_isoWorkerFolderPath, const ::std::string& __p_isoFilePath, const ::BoxLogic::Hardwares& __p_hardwares, const ::BoxLogic::IPConfigs& __p_ipconfigs, const ::BoxLogic::StringList& __p_pciBusDeviceIds, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::std::string& __p_driverIds, const ::std::string& __p_jsonConfigure)
    {
        generatePeStageIso(__p_isoWorkerFolderPath, __p_isoFilePath, __p_hardwares, __p_ipconfigs, __p_pciBusDeviceIds, __p_osType, __p_osBit, __p_driverIds, __p_jsonConfigure, 0);
    }
    void generatePeStageIso(const ::std::string& __p_isoWorkerFolderPath, const ::std::string& __p_isoFilePath, const ::BoxLogic::Hardwares& __p_hardwares, const ::BoxLogic::IPConfigs& __p_ipconfigs, const ::BoxLogic::StringList& __p_pciBusDeviceIds, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::std::string& __p_driverIds, const ::std::string& __p_jsonConfigure, const ::Ice::Context& __ctx)
    {
        generatePeStageIso(__p_isoWorkerFolderPath, __p_isoFilePath, __p_hardwares, __p_ipconfigs, __p_pciBusDeviceIds, __p_osType, __p_osBit, __p_driverIds, __p_jsonConfigure, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_generatePeStageIso(const ::std::string& __p_isoWorkerFolderPath, const ::std::string& __p_isoFilePath, const ::BoxLogic::Hardwares& __p_hardwares, const ::BoxLogic::IPConfigs& __p_ipconfigs, const ::BoxLogic::StringList& __p_pciBusDeviceIds, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::std::string& __p_driverIds, const ::std::string& __p_jsonConfigure, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_generatePeStageIso(__p_isoWorkerFolderPath, __p_isoFilePath, __p_hardwares, __p_ipconfigs, __p_pciBusDeviceIds, __p_osType, __p_osBit, __p_driverIds, __p_jsonConfigure, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_generatePeStageIso(const ::std::string& __p_isoWorkerFolderPath, const ::std::string& __p_isoFilePath, const ::BoxLogic::Hardwares& __p_hardwares, const ::BoxLogic::IPConfigs& __p_ipconfigs, const ::BoxLogic::StringList& __p_pciBusDeviceIds, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::std::string& __p_driverIds, const ::std::string& __p_jsonConfigure, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_generatePeStageIso(__p_isoWorkerFolderPath, __p_isoFilePath, __p_hardwares, __p_ipconfigs, __p_pciBusDeviceIds, __p_osType, __p_osBit, __p_driverIds, __p_jsonConfigure, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_generatePeStageIso(const ::std::string& __p_isoWorkerFolderPath, const ::std::string& __p_isoFilePath, const ::BoxLogic::Hardwares& __p_hardwares, const ::BoxLogic::IPConfigs& __p_ipconfigs, const ::BoxLogic::StringList& __p_pciBusDeviceIds, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::std::string& __p_driverIds, const ::std::string& __p_jsonConfigure, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_generatePeStageIso(__p_isoWorkerFolderPath, __p_isoFilePath, __p_hardwares, __p_ipconfigs, __p_pciBusDeviceIds, __p_osType, __p_osBit, __p_driverIds, __p_jsonConfigure, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_generatePeStageIso(const ::std::string& __p_isoWorkerFolderPath, const ::std::string& __p_isoFilePath, const ::BoxLogic::Hardwares& __p_hardwares, const ::BoxLogic::IPConfigs& __p_ipconfigs, const ::BoxLogic::StringList& __p_pciBusDeviceIds, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::std::string& __p_driverIds, const ::std::string& __p_jsonConfigure, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_generatePeStageIso(__p_isoWorkerFolderPath, __p_isoFilePath, __p_hardwares, __p_ipconfigs, __p_pciBusDeviceIds, __p_osType, __p_osBit, __p_driverIds, __p_jsonConfigure, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_generatePeStageIso(const ::std::string& __p_isoWorkerFolderPath, const ::std::string& __p_isoFilePath, const ::BoxLogic::Hardwares& __p_hardwares, const ::BoxLogic::IPConfigs& __p_ipconfigs, const ::BoxLogic::StringList& __p_pciBusDeviceIds, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::std::string& __p_driverIds, const ::std::string& __p_jsonConfigure, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_generatePeStageIso(const ::std::string& __p_isoWorkerFolderPath, const ::std::string& __p_isoFilePath, const ::BoxLogic::Hardwares& __p_hardwares, const ::BoxLogic::IPConfigs& __p_ipconfigs, const ::BoxLogic::StringList& __p_pciBusDeviceIds, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::std::string& __p_driverIds, const ::std::string& __p_jsonConfigure)
    {
        return begin_generatePeStageIso(__p_isoWorkerFolderPath, __p_isoFilePath, __p_hardwares, __p_ipconfigs, __p_pciBusDeviceIds, __p_osType, __p_osBit, __p_driverIds, __p_jsonConfigure, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_generatePeStageIso(const ::std::string& __p_isoWorkerFolderPath, const ::std::string& __p_isoFilePath, const ::BoxLogic::Hardwares& __p_hardwares, const ::BoxLogic::IPConfigs& __p_ipconfigs, const ::BoxLogic::StringList& __p_pciBusDeviceIds, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::std::string& __p_driverIds, const ::std::string& __p_jsonConfigure, const ::Ice::Context& __ctx)
    {
        return begin_generatePeStageIso(__p_isoWorkerFolderPath, __p_isoFilePath, __p_hardwares, __p_ipconfigs, __p_pciBusDeviceIds, __p_osType, __p_osBit, __p_driverIds, __p_jsonConfigure, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_generatePeStageIso(const ::std::string& __p_isoWorkerFolderPath, const ::std::string& __p_isoFilePath, const ::BoxLogic::Hardwares& __p_hardwares, const ::BoxLogic::IPConfigs& __p_ipconfigs, const ::BoxLogic::StringList& __p_pciBusDeviceIds, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::std::string& __p_driverIds, const ::std::string& __p_jsonConfigure, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_generatePeStageIso(__p_isoWorkerFolderPath, __p_isoFilePath, __p_hardwares, __p_ipconfigs, __p_pciBusDeviceIds, __p_osType, __p_osBit, __p_driverIds, __p_jsonConfigure, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_generatePeStageIso(const ::std::string& __p_isoWorkerFolderPath, const ::std::string& __p_isoFilePath, const ::BoxLogic::Hardwares& __p_hardwares, const ::BoxLogic::IPConfigs& __p_ipconfigs, const ::BoxLogic::StringList& __p_pciBusDeviceIds, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::std::string& __p_driverIds, const ::std::string& __p_jsonConfigure, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_generatePeStageIso(__p_isoWorkerFolderPath, __p_isoFilePath, __p_hardwares, __p_ipconfigs, __p_pciBusDeviceIds, __p_osType, __p_osBit, __p_driverIds, __p_jsonConfigure, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_generatePeStageIso(const ::std::string& __p_isoWorkerFolderPath, const ::std::string& __p_isoFilePath, const ::BoxLogic::Hardwares& __p_hardwares, const ::BoxLogic::IPConfigs& __p_ipconfigs, const ::BoxLogic::StringList& __p_pciBusDeviceIds, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::std::string& __p_driverIds, const ::std::string& __p_jsonConfigure, const ::BoxLogic::Callback_LogicInternal_generatePeStageIsoPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_generatePeStageIso(__p_isoWorkerFolderPath, __p_isoFilePath, __p_hardwares, __p_ipconfigs, __p_pciBusDeviceIds, __p_osType, __p_osBit, __p_driverIds, __p_jsonConfigure, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_generatePeStageIso(const ::std::string& __p_isoWorkerFolderPath, const ::std::string& __p_isoFilePath, const ::BoxLogic::Hardwares& __p_hardwares, const ::BoxLogic::IPConfigs& __p_ipconfigs, const ::BoxLogic::StringList& __p_pciBusDeviceIds, const ::std::string& __p_osType, const ::std::string& __p_osBit, const ::std::string& __p_driverIds, const ::std::string& __p_jsonConfigure, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_generatePeStageIsoPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_generatePeStageIso(__p_isoWorkerFolderPath, __p_isoFilePath, __p_hardwares, __p_ipconfigs, __p_pciBusDeviceIds, __p_osType, __p_osBit, __p_driverIds, __p_jsonConfigure, &__ctx, __del, __cookie);
    }

    void end_generatePeStageIso(const ::Ice::AsyncResultPtr&);
    
private:

    void generatePeStageIso(const ::std::string&, const ::std::string&, const ::BoxLogic::Hardwares&, const ::BoxLogic::IPConfigs&, const ::BoxLogic::StringList&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_generatePeStageIso(const ::std::string&, const ::std::string&, const ::BoxLogic::Hardwares&, const ::BoxLogic::IPConfigs&, const ::BoxLogic::StringList&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string runRestoreKvm(const ::std::string& __p_params)
    {
        return runRestoreKvm(__p_params, 0);
    }
    ::std::string runRestoreKvm(const ::std::string& __p_params, const ::Ice::Context& __ctx)
    {
        return runRestoreKvm(__p_params, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_runRestoreKvm(const ::std::string& __p_params, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_runRestoreKvm(__p_params, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_runRestoreKvm(const ::std::string& __p_params, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_runRestoreKvm(__p_params, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_runRestoreKvm(const ::std::string& __p_params, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_runRestoreKvm(__p_params, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_runRestoreKvm(const ::std::string& __p_params, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_runRestoreKvm(__p_params, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_runRestoreKvm(const ::std::string& __p_params, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_runRestoreKvm(const ::std::string& __p_params)
    {
        return begin_runRestoreKvm(__p_params, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_runRestoreKvm(const ::std::string& __p_params, const ::Ice::Context& __ctx)
    {
        return begin_runRestoreKvm(__p_params, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_runRestoreKvm(const ::std::string& __p_params, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_runRestoreKvm(__p_params, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_runRestoreKvm(const ::std::string& __p_params, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_runRestoreKvm(__p_params, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_runRestoreKvm(const ::std::string& __p_params, const ::BoxLogic::Callback_LogicInternal_runRestoreKvmPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_runRestoreKvm(__p_params, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_runRestoreKvm(const ::std::string& __p_params, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_runRestoreKvmPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_runRestoreKvm(__p_params, &__ctx, __del, __cookie);
    }

    ::std::string end_runRestoreKvm(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string runRestoreKvm(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_runRestoreKvm(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string getCurrentNetworkInfos()
    {
        return getCurrentNetworkInfos(0);
    }
    ::std::string getCurrentNetworkInfos(const ::Ice::Context& __ctx)
    {
        return getCurrentNetworkInfos(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getCurrentNetworkInfos(const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getCurrentNetworkInfos(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getCurrentNetworkInfos(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getCurrentNetworkInfos(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getCurrentNetworkInfos(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getCurrentNetworkInfos(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getCurrentNetworkInfos(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getCurrentNetworkInfos(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getCurrentNetworkInfos(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getCurrentNetworkInfos()
    {
        return begin_getCurrentNetworkInfos(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getCurrentNetworkInfos(const ::Ice::Context& __ctx)
    {
        return begin_getCurrentNetworkInfos(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getCurrentNetworkInfos(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getCurrentNetworkInfos(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getCurrentNetworkInfos(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getCurrentNetworkInfos(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getCurrentNetworkInfos(const ::BoxLogic::Callback_LogicInternal_getCurrentNetworkInfosPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getCurrentNetworkInfos(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getCurrentNetworkInfos(const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_getCurrentNetworkInfosPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getCurrentNetworkInfos(&__ctx, __del, __cookie);
    }

    ::std::string end_getCurrentNetworkInfos(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string getCurrentNetworkInfos(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getCurrentNetworkInfos(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setNetwork(const ::std::string& __p_setting)
    {
        setNetwork(__p_setting, 0);
    }
    void setNetwork(const ::std::string& __p_setting, const ::Ice::Context& __ctx)
    {
        setNetwork(__p_setting, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_setNetwork(const ::std::string& __p_setting, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_setNetwork(__p_setting, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_setNetwork(const ::std::string& __p_setting, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setNetwork(__p_setting, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_setNetwork(const ::std::string& __p_setting, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_setNetwork(__p_setting, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_setNetwork(const ::std::string& __p_setting, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setNetwork(__p_setting, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_setNetwork(const ::std::string& __p_setting, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_setNetwork(const ::std::string& __p_setting)
    {
        return begin_setNetwork(__p_setting, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setNetwork(const ::std::string& __p_setting, const ::Ice::Context& __ctx)
    {
        return begin_setNetwork(__p_setting, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setNetwork(const ::std::string& __p_setting, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNetwork(__p_setting, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setNetwork(const ::std::string& __p_setting, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNetwork(__p_setting, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setNetwork(const ::std::string& __p_setting, const ::BoxLogic::Callback_LogicInternal_setNetworkPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNetwork(__p_setting, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setNetwork(const ::std::string& __p_setting, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_setNetworkPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setNetwork(__p_setting, &__ctx, __del, __cookie);
    }

    void end_setNetwork(const ::Ice::AsyncResultPtr&);
    
private:

    void setNetwork(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setNetwork(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string enumStorageNodes()
    {
        return enumStorageNodes(0);
    }
    ::std::string enumStorageNodes(const ::Ice::Context& __ctx)
    {
        return enumStorageNodes(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_enumStorageNodes(const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_enumStorageNodes(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_enumStorageNodes(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_enumStorageNodes(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_enumStorageNodes(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_enumStorageNodes(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_enumStorageNodes(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_enumStorageNodes(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_enumStorageNodes(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_enumStorageNodes()
    {
        return begin_enumStorageNodes(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_enumStorageNodes(const ::Ice::Context& __ctx)
    {
        return begin_enumStorageNodes(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_enumStorageNodes(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_enumStorageNodes(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_enumStorageNodes(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_enumStorageNodes(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_enumStorageNodes(const ::BoxLogic::Callback_LogicInternal_enumStorageNodesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_enumStorageNodes(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_enumStorageNodes(const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_enumStorageNodesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_enumStorageNodes(&__ctx, __del, __cookie);
    }

    ::std::string end_enumStorageNodes(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string enumStorageNodes(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_enumStorageNodes(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string getLocalIqn()
    {
        return getLocalIqn(0);
    }
    ::std::string getLocalIqn(const ::Ice::Context& __ctx)
    {
        return getLocalIqn(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getLocalIqn(const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getLocalIqn(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getLocalIqn(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getLocalIqn(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getLocalIqn(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getLocalIqn(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getLocalIqn(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getLocalIqn(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getLocalIqn(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getLocalIqn()
    {
        return begin_getLocalIqn(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getLocalIqn(const ::Ice::Context& __ctx)
    {
        return begin_getLocalIqn(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getLocalIqn(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLocalIqn(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getLocalIqn(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLocalIqn(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getLocalIqn(const ::BoxLogic::Callback_LogicInternal_getLocalIqnPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLocalIqn(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getLocalIqn(const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_getLocalIqnPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getLocalIqn(&__ctx, __del, __cookie);
    }

    ::std::string end_getLocalIqn(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string getLocalIqn(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getLocalIqn(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setLocalIqn(const ::std::string& __p_iqn)
    {
        setLocalIqn(__p_iqn, 0);
    }
    void setLocalIqn(const ::std::string& __p_iqn, const ::Ice::Context& __ctx)
    {
        setLocalIqn(__p_iqn, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_setLocalIqn(const ::std::string& __p_iqn, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_setLocalIqn(__p_iqn, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_setLocalIqn(const ::std::string& __p_iqn, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setLocalIqn(__p_iqn, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_setLocalIqn(const ::std::string& __p_iqn, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_setLocalIqn(__p_iqn, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_setLocalIqn(const ::std::string& __p_iqn, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setLocalIqn(__p_iqn, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_setLocalIqn(const ::std::string& __p_iqn, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_setLocalIqn(const ::std::string& __p_iqn)
    {
        return begin_setLocalIqn(__p_iqn, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setLocalIqn(const ::std::string& __p_iqn, const ::Ice::Context& __ctx)
    {
        return begin_setLocalIqn(__p_iqn, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setLocalIqn(const ::std::string& __p_iqn, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setLocalIqn(__p_iqn, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setLocalIqn(const ::std::string& __p_iqn, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setLocalIqn(__p_iqn, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setLocalIqn(const ::std::string& __p_iqn, const ::BoxLogic::Callback_LogicInternal_setLocalIqnPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setLocalIqn(__p_iqn, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setLocalIqn(const ::std::string& __p_iqn, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_setLocalIqnPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setLocalIqn(__p_iqn, &__ctx, __del, __cookie);
    }

    void end_setLocalIqn(const ::Ice::AsyncResultPtr&);
    
private:

    void setLocalIqn(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setLocalIqn(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setGlobalDoubleChap(const ::std::string& __p_userName, const ::std::string& __p_password)
    {
        setGlobalDoubleChap(__p_userName, __p_password, 0);
    }
    void setGlobalDoubleChap(const ::std::string& __p_userName, const ::std::string& __p_password, const ::Ice::Context& __ctx)
    {
        setGlobalDoubleChap(__p_userName, __p_password, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_setGlobalDoubleChap(const ::std::string& __p_userName, const ::std::string& __p_password, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_setGlobalDoubleChap(__p_userName, __p_password, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_setGlobalDoubleChap(const ::std::string& __p_userName, const ::std::string& __p_password, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setGlobalDoubleChap(__p_userName, __p_password, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_setGlobalDoubleChap(const ::std::string& __p_userName, const ::std::string& __p_password, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_setGlobalDoubleChap(__p_userName, __p_password, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_setGlobalDoubleChap(const ::std::string& __p_userName, const ::std::string& __p_password, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setGlobalDoubleChap(__p_userName, __p_password, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_setGlobalDoubleChap(const ::std::string& __p_userName, const ::std::string& __p_password, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_setGlobalDoubleChap(const ::std::string& __p_userName, const ::std::string& __p_password)
    {
        return begin_setGlobalDoubleChap(__p_userName, __p_password, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setGlobalDoubleChap(const ::std::string& __p_userName, const ::std::string& __p_password, const ::Ice::Context& __ctx)
    {
        return begin_setGlobalDoubleChap(__p_userName, __p_password, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setGlobalDoubleChap(const ::std::string& __p_userName, const ::std::string& __p_password, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setGlobalDoubleChap(__p_userName, __p_password, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setGlobalDoubleChap(const ::std::string& __p_userName, const ::std::string& __p_password, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setGlobalDoubleChap(__p_userName, __p_password, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setGlobalDoubleChap(const ::std::string& __p_userName, const ::std::string& __p_password, const ::BoxLogic::Callback_LogicInternal_setGlobalDoubleChapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setGlobalDoubleChap(__p_userName, __p_password, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setGlobalDoubleChap(const ::std::string& __p_userName, const ::std::string& __p_password, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_setGlobalDoubleChapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setGlobalDoubleChap(__p_userName, __p_password, &__ctx, __del, __cookie);
    }

    void end_setGlobalDoubleChap(const ::Ice::AsyncResultPtr&);
    
private:

    void setGlobalDoubleChap(const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setGlobalDoubleChap(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool getGlobalDoubleChap(::std::string& __p_userName, ::std::string& __p_password)
    {
        return getGlobalDoubleChap(__p_userName, __p_password, 0);
    }
    bool getGlobalDoubleChap(::std::string& __p_userName, ::std::string& __p_password, const ::Ice::Context& __ctx)
    {
        return getGlobalDoubleChap(__p_userName, __p_password, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getGlobalDoubleChap(const ::IceInternal::Function<void (bool, const ::std::string&, const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getGlobalDoubleChap(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getGlobalDoubleChap(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getGlobalDoubleChap(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getGlobalDoubleChap(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (bool, const ::std::string&, const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getGlobalDoubleChap(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getGlobalDoubleChap(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getGlobalDoubleChap(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getGlobalDoubleChap(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool, const ::std::string&, const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getGlobalDoubleChap()
    {
        return begin_getGlobalDoubleChap(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getGlobalDoubleChap(const ::Ice::Context& __ctx)
    {
        return begin_getGlobalDoubleChap(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getGlobalDoubleChap(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getGlobalDoubleChap(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getGlobalDoubleChap(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getGlobalDoubleChap(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getGlobalDoubleChap(const ::BoxLogic::Callback_LogicInternal_getGlobalDoubleChapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getGlobalDoubleChap(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getGlobalDoubleChap(const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_getGlobalDoubleChapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getGlobalDoubleChap(&__ctx, __del, __cookie);
    }

    bool end_getGlobalDoubleChap(::std::string& __p_userName, ::std::string& __p_password, const ::Ice::AsyncResultPtr&);
    
private:

    bool getGlobalDoubleChap(::std::string&, ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getGlobalDoubleChap(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string loginExternalDevice(const ::std::string& __p_remoteIp, ::Ice::Int __p_remotePort, bool __p_useChap, const ::std::string& __p_userName, const ::std::string& __p_password)
    {
        return loginExternalDevice(__p_remoteIp, __p_remotePort, __p_useChap, __p_userName, __p_password, 0);
    }
    ::std::string loginExternalDevice(const ::std::string& __p_remoteIp, ::Ice::Int __p_remotePort, bool __p_useChap, const ::std::string& __p_userName, const ::std::string& __p_password, const ::Ice::Context& __ctx)
    {
        return loginExternalDevice(__p_remoteIp, __p_remotePort, __p_useChap, __p_userName, __p_password, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_loginExternalDevice(const ::std::string& __p_remoteIp, ::Ice::Int __p_remotePort, bool __p_useChap, const ::std::string& __p_userName, const ::std::string& __p_password, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_loginExternalDevice(__p_remoteIp, __p_remotePort, __p_useChap, __p_userName, __p_password, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_loginExternalDevice(const ::std::string& __p_remoteIp, ::Ice::Int __p_remotePort, bool __p_useChap, const ::std::string& __p_userName, const ::std::string& __p_password, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_loginExternalDevice(__p_remoteIp, __p_remotePort, __p_useChap, __p_userName, __p_password, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_loginExternalDevice(const ::std::string& __p_remoteIp, ::Ice::Int __p_remotePort, bool __p_useChap, const ::std::string& __p_userName, const ::std::string& __p_password, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_loginExternalDevice(__p_remoteIp, __p_remotePort, __p_useChap, __p_userName, __p_password, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_loginExternalDevice(const ::std::string& __p_remoteIp, ::Ice::Int __p_remotePort, bool __p_useChap, const ::std::string& __p_userName, const ::std::string& __p_password, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_loginExternalDevice(__p_remoteIp, __p_remotePort, __p_useChap, __p_userName, __p_password, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_loginExternalDevice(const ::std::string& __p_remoteIp, ::Ice::Int __p_remotePort, bool __p_useChap, const ::std::string& __p_userName, const ::std::string& __p_password, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_loginExternalDevice(const ::std::string& __p_remoteIp, ::Ice::Int __p_remotePort, bool __p_useChap, const ::std::string& __p_userName, const ::std::string& __p_password)
    {
        return begin_loginExternalDevice(__p_remoteIp, __p_remotePort, __p_useChap, __p_userName, __p_password, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_loginExternalDevice(const ::std::string& __p_remoteIp, ::Ice::Int __p_remotePort, bool __p_useChap, const ::std::string& __p_userName, const ::std::string& __p_password, const ::Ice::Context& __ctx)
    {
        return begin_loginExternalDevice(__p_remoteIp, __p_remotePort, __p_useChap, __p_userName, __p_password, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_loginExternalDevice(const ::std::string& __p_remoteIp, ::Ice::Int __p_remotePort, bool __p_useChap, const ::std::string& __p_userName, const ::std::string& __p_password, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_loginExternalDevice(__p_remoteIp, __p_remotePort, __p_useChap, __p_userName, __p_password, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_loginExternalDevice(const ::std::string& __p_remoteIp, ::Ice::Int __p_remotePort, bool __p_useChap, const ::std::string& __p_userName, const ::std::string& __p_password, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_loginExternalDevice(__p_remoteIp, __p_remotePort, __p_useChap, __p_userName, __p_password, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_loginExternalDevice(const ::std::string& __p_remoteIp, ::Ice::Int __p_remotePort, bool __p_useChap, const ::std::string& __p_userName, const ::std::string& __p_password, const ::BoxLogic::Callback_LogicInternal_loginExternalDevicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_loginExternalDevice(__p_remoteIp, __p_remotePort, __p_useChap, __p_userName, __p_password, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_loginExternalDevice(const ::std::string& __p_remoteIp, ::Ice::Int __p_remotePort, bool __p_useChap, const ::std::string& __p_userName, const ::std::string& __p_password, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_loginExternalDevicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_loginExternalDevice(__p_remoteIp, __p_remotePort, __p_useChap, __p_userName, __p_password, &__ctx, __del, __cookie);
    }

    ::std::string end_loginExternalDevice(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string loginExternalDevice(const ::std::string&, ::Ice::Int, bool, const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_loginExternalDevice(const ::std::string&, ::Ice::Int, bool, const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void logoutExternalDevice(const ::std::string& __p_iqn)
    {
        logoutExternalDevice(__p_iqn, 0);
    }
    void logoutExternalDevice(const ::std::string& __p_iqn, const ::Ice::Context& __ctx)
    {
        logoutExternalDevice(__p_iqn, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_logoutExternalDevice(const ::std::string& __p_iqn, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_logoutExternalDevice(__p_iqn, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_logoutExternalDevice(const ::std::string& __p_iqn, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_logoutExternalDevice(__p_iqn, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_logoutExternalDevice(const ::std::string& __p_iqn, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_logoutExternalDevice(__p_iqn, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_logoutExternalDevice(const ::std::string& __p_iqn, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_logoutExternalDevice(__p_iqn, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_logoutExternalDevice(const ::std::string& __p_iqn, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_logoutExternalDevice(const ::std::string& __p_iqn)
    {
        return begin_logoutExternalDevice(__p_iqn, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_logoutExternalDevice(const ::std::string& __p_iqn, const ::Ice::Context& __ctx)
    {
        return begin_logoutExternalDevice(__p_iqn, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_logoutExternalDevice(const ::std::string& __p_iqn, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_logoutExternalDevice(__p_iqn, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_logoutExternalDevice(const ::std::string& __p_iqn, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_logoutExternalDevice(__p_iqn, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_logoutExternalDevice(const ::std::string& __p_iqn, const ::BoxLogic::Callback_LogicInternal_logoutExternalDevicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_logoutExternalDevice(__p_iqn, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_logoutExternalDevice(const ::std::string& __p_iqn, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_logoutExternalDevicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_logoutExternalDevice(__p_iqn, &__ctx, __del, __cookie);
    }

    void end_logoutExternalDevice(const ::Ice::AsyncResultPtr&);
    
private:

    void logoutExternalDevice(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_logoutExternalDevice(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void refreshExternalDevice(const ::std::string& __p_iqn)
    {
        refreshExternalDevice(__p_iqn, 0);
    }
    void refreshExternalDevice(const ::std::string& __p_iqn, const ::Ice::Context& __ctx)
    {
        refreshExternalDevice(__p_iqn, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_refreshExternalDevice(const ::std::string& __p_iqn, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_refreshExternalDevice(__p_iqn, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_refreshExternalDevice(const ::std::string& __p_iqn, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_refreshExternalDevice(__p_iqn, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_refreshExternalDevice(const ::std::string& __p_iqn, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_refreshExternalDevice(__p_iqn, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_refreshExternalDevice(const ::std::string& __p_iqn, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_refreshExternalDevice(__p_iqn, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_refreshExternalDevice(const ::std::string& __p_iqn, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_refreshExternalDevice(const ::std::string& __p_iqn)
    {
        return begin_refreshExternalDevice(__p_iqn, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_refreshExternalDevice(const ::std::string& __p_iqn, const ::Ice::Context& __ctx)
    {
        return begin_refreshExternalDevice(__p_iqn, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_refreshExternalDevice(const ::std::string& __p_iqn, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_refreshExternalDevice(__p_iqn, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_refreshExternalDevice(const ::std::string& __p_iqn, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_refreshExternalDevice(__p_iqn, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_refreshExternalDevice(const ::std::string& __p_iqn, const ::BoxLogic::Callback_LogicInternal_refreshExternalDevicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_refreshExternalDevice(__p_iqn, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_refreshExternalDevice(const ::std::string& __p_iqn, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_refreshExternalDevicePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_refreshExternalDevice(__p_iqn, &__ctx, __del, __cookie);
    }

    void end_refreshExternalDevice(const ::Ice::AsyncResultPtr&);
    
private:

    void refreshExternalDevice(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_refreshExternalDevice(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void formatAndInitializeStorageNode(const ::std::string& __p_node)
    {
        formatAndInitializeStorageNode(__p_node, 0);
    }
    void formatAndInitializeStorageNode(const ::std::string& __p_node, const ::Ice::Context& __ctx)
    {
        formatAndInitializeStorageNode(__p_node, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_formatAndInitializeStorageNode(const ::std::string& __p_node, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_formatAndInitializeStorageNode(__p_node, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_formatAndInitializeStorageNode(const ::std::string& __p_node, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_formatAndInitializeStorageNode(__p_node, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_formatAndInitializeStorageNode(const ::std::string& __p_node, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_formatAndInitializeStorageNode(__p_node, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_formatAndInitializeStorageNode(const ::std::string& __p_node, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_formatAndInitializeStorageNode(__p_node, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_formatAndInitializeStorageNode(const ::std::string& __p_node, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_formatAndInitializeStorageNode(const ::std::string& __p_node)
    {
        return begin_formatAndInitializeStorageNode(__p_node, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_formatAndInitializeStorageNode(const ::std::string& __p_node, const ::Ice::Context& __ctx)
    {
        return begin_formatAndInitializeStorageNode(__p_node, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_formatAndInitializeStorageNode(const ::std::string& __p_node, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_formatAndInitializeStorageNode(__p_node, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_formatAndInitializeStorageNode(const ::std::string& __p_node, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_formatAndInitializeStorageNode(__p_node, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_formatAndInitializeStorageNode(const ::std::string& __p_node, const ::BoxLogic::Callback_LogicInternal_formatAndInitializeStorageNodePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_formatAndInitializeStorageNode(__p_node, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_formatAndInitializeStorageNode(const ::std::string& __p_node, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_formatAndInitializeStorageNodePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_formatAndInitializeStorageNode(__p_node, &__ctx, __del, __cookie);
    }

    void end_formatAndInitializeStorageNode(const ::Ice::AsyncResultPtr&);
    
private:

    void formatAndInitializeStorageNode(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_formatAndInitializeStorageNode(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void mountStorageNode(const ::std::string& __p_node)
    {
        mountStorageNode(__p_node, 0);
    }
    void mountStorageNode(const ::std::string& __p_node, const ::Ice::Context& __ctx)
    {
        mountStorageNode(__p_node, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_mountStorageNode(const ::std::string& __p_node, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_mountStorageNode(__p_node, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_mountStorageNode(const ::std::string& __p_node, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_mountStorageNode(__p_node, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_mountStorageNode(const ::std::string& __p_node, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_mountStorageNode(__p_node, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_mountStorageNode(const ::std::string& __p_node, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_mountStorageNode(__p_node, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_mountStorageNode(const ::std::string& __p_node, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_mountStorageNode(const ::std::string& __p_node)
    {
        return begin_mountStorageNode(__p_node, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_mountStorageNode(const ::std::string& __p_node, const ::Ice::Context& __ctx)
    {
        return begin_mountStorageNode(__p_node, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_mountStorageNode(const ::std::string& __p_node, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mountStorageNode(__p_node, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_mountStorageNode(const ::std::string& __p_node, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mountStorageNode(__p_node, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_mountStorageNode(const ::std::string& __p_node, const ::BoxLogic::Callback_LogicInternal_mountStorageNodePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mountStorageNode(__p_node, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_mountStorageNode(const ::std::string& __p_node, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_mountStorageNodePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mountStorageNode(__p_node, &__ctx, __del, __cookie);
    }

    void end_mountStorageNode(const ::Ice::AsyncResultPtr&);
    
private:

    void mountStorageNode(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_mountStorageNode(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void unmountStorageNode(const ::std::string& __p_node)
    {
        unmountStorageNode(__p_node, 0);
    }
    void unmountStorageNode(const ::std::string& __p_node, const ::Ice::Context& __ctx)
    {
        unmountStorageNode(__p_node, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_unmountStorageNode(const ::std::string& __p_node, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_unmountStorageNode(__p_node, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_unmountStorageNode(const ::std::string& __p_node, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_unmountStorageNode(__p_node, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_unmountStorageNode(const ::std::string& __p_node, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_unmountStorageNode(__p_node, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_unmountStorageNode(const ::std::string& __p_node, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_unmountStorageNode(__p_node, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_unmountStorageNode(const ::std::string& __p_node, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_unmountStorageNode(const ::std::string& __p_node)
    {
        return begin_unmountStorageNode(__p_node, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unmountStorageNode(const ::std::string& __p_node, const ::Ice::Context& __ctx)
    {
        return begin_unmountStorageNode(__p_node, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unmountStorageNode(const ::std::string& __p_node, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unmountStorageNode(__p_node, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unmountStorageNode(const ::std::string& __p_node, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unmountStorageNode(__p_node, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unmountStorageNode(const ::std::string& __p_node, const ::BoxLogic::Callback_LogicInternal_unmountStorageNodePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unmountStorageNode(__p_node, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_unmountStorageNode(const ::std::string& __p_node, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_unmountStorageNodePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_unmountStorageNode(__p_node, &__ctx, __del, __cookie);
    }

    void end_unmountStorageNode(const ::Ice::AsyncResultPtr&);
    
private:

    void unmountStorageNode(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_unmountStorageNode(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int runCmd(const ::std::string& __p_cmd, bool __p_shell, ::BoxLogic::StringList& __p_lines)
    {
        return runCmd(__p_cmd, __p_shell, __p_lines, 0);
    }
    ::Ice::Int runCmd(const ::std::string& __p_cmd, bool __p_shell, ::BoxLogic::StringList& __p_lines, const ::Ice::Context& __ctx)
    {
        return runCmd(__p_cmd, __p_shell, __p_lines, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_runCmd(const ::std::string& __p_cmd, bool __p_shell, const ::IceInternal::Function<void (::Ice::Int, const ::BoxLogic::StringList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_runCmd(__p_cmd, __p_shell, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_runCmd(const ::std::string& __p_cmd, bool __p_shell, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_runCmd(__p_cmd, __p_shell, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_runCmd(const ::std::string& __p_cmd, bool __p_shell, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int, const ::BoxLogic::StringList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_runCmd(__p_cmd, __p_shell, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_runCmd(const ::std::string& __p_cmd, bool __p_shell, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_runCmd(__p_cmd, __p_shell, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_runCmd(const ::std::string& __p_cmd, bool __p_shell, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int, const ::BoxLogic::StringList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_runCmd(const ::std::string& __p_cmd, bool __p_shell)
    {
        return begin_runCmd(__p_cmd, __p_shell, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_runCmd(const ::std::string& __p_cmd, bool __p_shell, const ::Ice::Context& __ctx)
    {
        return begin_runCmd(__p_cmd, __p_shell, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_runCmd(const ::std::string& __p_cmd, bool __p_shell, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_runCmd(__p_cmd, __p_shell, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_runCmd(const ::std::string& __p_cmd, bool __p_shell, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_runCmd(__p_cmd, __p_shell, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_runCmd(const ::std::string& __p_cmd, bool __p_shell, const ::BoxLogic::Callback_LogicInternal_runCmdPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_runCmd(__p_cmd, __p_shell, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_runCmd(const ::std::string& __p_cmd, bool __p_shell, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_runCmdPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_runCmd(__p_cmd, __p_shell, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_runCmd(::BoxLogic::StringList& __p_lines, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int runCmd(const ::std::string&, bool, ::BoxLogic::StringList&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_runCmd(const ::std::string&, bool, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string CmdCtrl(const ::std::string& __p_cmdinfo)
    {
        return CmdCtrl(__p_cmdinfo, 0);
    }
    ::std::string CmdCtrl(const ::std::string& __p_cmdinfo, const ::Ice::Context& __ctx)
    {
        return CmdCtrl(__p_cmdinfo, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_CmdCtrl(const ::std::string& __p_cmdinfo, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_CmdCtrl(__p_cmdinfo, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_CmdCtrl(const ::std::string& __p_cmdinfo, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_CmdCtrl(__p_cmdinfo, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_CmdCtrl(const ::std::string& __p_cmdinfo, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_CmdCtrl(__p_cmdinfo, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_CmdCtrl(const ::std::string& __p_cmdinfo, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_CmdCtrl(__p_cmdinfo, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_CmdCtrl(const ::std::string& __p_cmdinfo, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_CmdCtrl(const ::std::string& __p_cmdinfo)
    {
        return begin_CmdCtrl(__p_cmdinfo, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_CmdCtrl(const ::std::string& __p_cmdinfo, const ::Ice::Context& __ctx)
    {
        return begin_CmdCtrl(__p_cmdinfo, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_CmdCtrl(const ::std::string& __p_cmdinfo, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_CmdCtrl(__p_cmdinfo, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_CmdCtrl(const ::std::string& __p_cmdinfo, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_CmdCtrl(__p_cmdinfo, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_CmdCtrl(const ::std::string& __p_cmdinfo, const ::BoxLogic::Callback_LogicInternal_CmdCtrlPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_CmdCtrl(__p_cmdinfo, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_CmdCtrl(const ::std::string& __p_cmdinfo, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_CmdCtrlPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_CmdCtrl(__p_cmdinfo, &__ctx, __del, __cookie);
    }

    ::std::string end_CmdCtrl(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string CmdCtrl(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_CmdCtrl(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setPasswd(const ::std::string& __p_passwd)
    {
        setPasswd(__p_passwd, 0);
    }
    void setPasswd(const ::std::string& __p_passwd, const ::Ice::Context& __ctx)
    {
        setPasswd(__p_passwd, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_setPasswd(const ::std::string& __p_passwd, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_setPasswd(__p_passwd, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_setPasswd(const ::std::string& __p_passwd, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setPasswd(__p_passwd, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_setPasswd(const ::std::string& __p_passwd, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_setPasswd(__p_passwd, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_setPasswd(const ::std::string& __p_passwd, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setPasswd(__p_passwd, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_setPasswd(const ::std::string& __p_passwd, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_setPasswd(const ::std::string& __p_passwd)
    {
        return begin_setPasswd(__p_passwd, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setPasswd(const ::std::string& __p_passwd, const ::Ice::Context& __ctx)
    {
        return begin_setPasswd(__p_passwd, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setPasswd(const ::std::string& __p_passwd, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPasswd(__p_passwd, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPasswd(const ::std::string& __p_passwd, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPasswd(__p_passwd, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPasswd(const ::std::string& __p_passwd, const ::BoxLogic::Callback_LogicInternal_setPasswdPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPasswd(__p_passwd, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPasswd(const ::std::string& __p_passwd, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_setPasswdPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPasswd(__p_passwd, &__ctx, __del, __cookie);
    }

    void end_setPasswd(const ::Ice::AsyncResultPtr&);
    
private:

    void setPasswd(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setPasswd(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string getPasswd()
    {
        return getPasswd(0);
    }
    ::std::string getPasswd(const ::Ice::Context& __ctx)
    {
        return getPasswd(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getPasswd(const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getPasswd(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getPasswd(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getPasswd(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getPasswd(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getPasswd(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getPasswd(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getPasswd(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getPasswd(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getPasswd()
    {
        return begin_getPasswd(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPasswd(const ::Ice::Context& __ctx)
    {
        return begin_getPasswd(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getPasswd(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPasswd(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPasswd(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPasswd(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPasswd(const ::BoxLogic::Callback_LogicInternal_getPasswdPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPasswd(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getPasswd(const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_getPasswdPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getPasswd(&__ctx, __del, __cookie);
    }

    ::std::string end_getPasswd(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string getPasswd(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getPasswd(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void calcClusterTime0Hash(const ::std::string& __p_config)
    {
        calcClusterTime0Hash(__p_config, 0);
    }
    void calcClusterTime0Hash(const ::std::string& __p_config, const ::Ice::Context& __ctx)
    {
        calcClusterTime0Hash(__p_config, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_calcClusterTime0Hash(const ::std::string& __p_config, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_calcClusterTime0Hash(__p_config, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_calcClusterTime0Hash(const ::std::string& __p_config, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_calcClusterTime0Hash(__p_config, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_calcClusterTime0Hash(const ::std::string& __p_config, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_calcClusterTime0Hash(__p_config, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_calcClusterTime0Hash(const ::std::string& __p_config, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_calcClusterTime0Hash(__p_config, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_calcClusterTime0Hash(const ::std::string& __p_config, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_calcClusterTime0Hash(const ::std::string& __p_config)
    {
        return begin_calcClusterTime0Hash(__p_config, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_calcClusterTime0Hash(const ::std::string& __p_config, const ::Ice::Context& __ctx)
    {
        return begin_calcClusterTime0Hash(__p_config, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_calcClusterTime0Hash(const ::std::string& __p_config, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_calcClusterTime0Hash(__p_config, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_calcClusterTime0Hash(const ::std::string& __p_config, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_calcClusterTime0Hash(__p_config, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_calcClusterTime0Hash(const ::std::string& __p_config, const ::BoxLogic::Callback_LogicInternal_calcClusterTime0HashPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_calcClusterTime0Hash(__p_config, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_calcClusterTime0Hash(const ::std::string& __p_config, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_calcClusterTime0HashPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_calcClusterTime0Hash(__p_config, &__ctx, __del, __cookie);
    }

    void end_calcClusterTime0Hash(const ::Ice::AsyncResultPtr&);
    
private:

    void calcClusterTime0Hash(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_calcClusterTime0Hash(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void generateClusterDiffImages(const ::std::string& __p_config)
    {
        generateClusterDiffImages(__p_config, 0);
    }
    void generateClusterDiffImages(const ::std::string& __p_config, const ::Ice::Context& __ctx)
    {
        generateClusterDiffImages(__p_config, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_generateClusterDiffImages(const ::std::string& __p_config, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_generateClusterDiffImages(__p_config, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_generateClusterDiffImages(const ::std::string& __p_config, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_generateClusterDiffImages(__p_config, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_generateClusterDiffImages(const ::std::string& __p_config, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_generateClusterDiffImages(__p_config, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_generateClusterDiffImages(const ::std::string& __p_config, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_generateClusterDiffImages(__p_config, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_generateClusterDiffImages(const ::std::string& __p_config, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_generateClusterDiffImages(const ::std::string& __p_config)
    {
        return begin_generateClusterDiffImages(__p_config, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_generateClusterDiffImages(const ::std::string& __p_config, const ::Ice::Context& __ctx)
    {
        return begin_generateClusterDiffImages(__p_config, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_generateClusterDiffImages(const ::std::string& __p_config, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_generateClusterDiffImages(__p_config, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_generateClusterDiffImages(const ::std::string& __p_config, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_generateClusterDiffImages(__p_config, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_generateClusterDiffImages(const ::std::string& __p_config, const ::BoxLogic::Callback_LogicInternal_generateClusterDiffImagesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_generateClusterDiffImages(__p_config, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_generateClusterDiffImages(const ::std::string& __p_config, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_generateClusterDiffImagesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_generateClusterDiffImages(__p_config, &__ctx, __del, __cookie);
    }

    void end_generateClusterDiffImages(const ::Ice::AsyncResultPtr&);
    
private:

    void generateClusterDiffImages(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_generateClusterDiffImages(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void mergeCdpFiles(const ::std::string& __p_config)
    {
        mergeCdpFiles(__p_config, 0);
    }
    void mergeCdpFiles(const ::std::string& __p_config, const ::Ice::Context& __ctx)
    {
        mergeCdpFiles(__p_config, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_mergeCdpFiles(const ::std::string& __p_config, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_mergeCdpFiles(__p_config, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_mergeCdpFiles(const ::std::string& __p_config, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_mergeCdpFiles(__p_config, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_mergeCdpFiles(const ::std::string& __p_config, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_mergeCdpFiles(__p_config, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_mergeCdpFiles(const ::std::string& __p_config, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_mergeCdpFiles(__p_config, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_mergeCdpFiles(const ::std::string& __p_config, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_mergeCdpFiles(const ::std::string& __p_config)
    {
        return begin_mergeCdpFiles(__p_config, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_mergeCdpFiles(const ::std::string& __p_config, const ::Ice::Context& __ctx)
    {
        return begin_mergeCdpFiles(__p_config, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_mergeCdpFiles(const ::std::string& __p_config, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mergeCdpFiles(__p_config, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_mergeCdpFiles(const ::std::string& __p_config, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mergeCdpFiles(__p_config, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_mergeCdpFiles(const ::std::string& __p_config, const ::BoxLogic::Callback_LogicInternal_mergeCdpFilesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mergeCdpFiles(__p_config, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_mergeCdpFiles(const ::std::string& __p_config, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_mergeCdpFilesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mergeCdpFiles(__p_config, &__ctx, __del, __cookie);
    }

    void end_mergeCdpFiles(const ::Ice::AsyncResultPtr&);
    
private:

    void mergeCdpFiles(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_mergeCdpFiles(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void cutCdpFile(const ::std::string& __p_config)
    {
        cutCdpFile(__p_config, 0);
    }
    void cutCdpFile(const ::std::string& __p_config, const ::Ice::Context& __ctx)
    {
        cutCdpFile(__p_config, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_cutCdpFile(const ::std::string& __p_config, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_cutCdpFile(__p_config, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_cutCdpFile(const ::std::string& __p_config, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_cutCdpFile(__p_config, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_cutCdpFile(const ::std::string& __p_config, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_cutCdpFile(__p_config, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_cutCdpFile(const ::std::string& __p_config, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_cutCdpFile(__p_config, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_cutCdpFile(const ::std::string& __p_config, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_cutCdpFile(const ::std::string& __p_config)
    {
        return begin_cutCdpFile(__p_config, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_cutCdpFile(const ::std::string& __p_config, const ::Ice::Context& __ctx)
    {
        return begin_cutCdpFile(__p_config, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_cutCdpFile(const ::std::string& __p_config, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_cutCdpFile(__p_config, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_cutCdpFile(const ::std::string& __p_config, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_cutCdpFile(__p_config, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_cutCdpFile(const ::std::string& __p_config, const ::BoxLogic::Callback_LogicInternal_cutCdpFilePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_cutCdpFile(__p_config, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_cutCdpFile(const ::std::string& __p_config, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_cutCdpFilePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_cutCdpFile(__p_config, &__ctx, __del, __cookie);
    }

    void end_cutCdpFile(const ::Ice::AsyncResultPtr&);
    
private:

    void cutCdpFile(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_cutCdpFile(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int getRawDiskFiles(const ::std::string& __p_binpath, const ::std::string& __p_destpath)
    {
        return getRawDiskFiles(__p_binpath, __p_destpath, 0);
    }
    ::Ice::Int getRawDiskFiles(const ::std::string& __p_binpath, const ::std::string& __p_destpath, const ::Ice::Context& __ctx)
    {
        return getRawDiskFiles(__p_binpath, __p_destpath, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getRawDiskFiles(const ::std::string& __p_binpath, const ::std::string& __p_destpath, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getRawDiskFiles(__p_binpath, __p_destpath, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getRawDiskFiles(const ::std::string& __p_binpath, const ::std::string& __p_destpath, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getRawDiskFiles(__p_binpath, __p_destpath, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getRawDiskFiles(const ::std::string& __p_binpath, const ::std::string& __p_destpath, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getRawDiskFiles(__p_binpath, __p_destpath, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getRawDiskFiles(const ::std::string& __p_binpath, const ::std::string& __p_destpath, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getRawDiskFiles(__p_binpath, __p_destpath, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getRawDiskFiles(const ::std::string& __p_binpath, const ::std::string& __p_destpath, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getRawDiskFiles(const ::std::string& __p_binpath, const ::std::string& __p_destpath)
    {
        return begin_getRawDiskFiles(__p_binpath, __p_destpath, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRawDiskFiles(const ::std::string& __p_binpath, const ::std::string& __p_destpath, const ::Ice::Context& __ctx)
    {
        return begin_getRawDiskFiles(__p_binpath, __p_destpath, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRawDiskFiles(const ::std::string& __p_binpath, const ::std::string& __p_destpath, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRawDiskFiles(__p_binpath, __p_destpath, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRawDiskFiles(const ::std::string& __p_binpath, const ::std::string& __p_destpath, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRawDiskFiles(__p_binpath, __p_destpath, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRawDiskFiles(const ::std::string& __p_binpath, const ::std::string& __p_destpath, const ::BoxLogic::Callback_LogicInternal_getRawDiskFilesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRawDiskFiles(__p_binpath, __p_destpath, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRawDiskFiles(const ::std::string& __p_binpath, const ::std::string& __p_destpath, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_getRawDiskFilesPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRawDiskFiles(__p_binpath, __p_destpath, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_getRawDiskFiles(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int getRawDiskFiles(const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getRawDiskFiles(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string NbdFindUnusedReverse()
    {
        return NbdFindUnusedReverse(0);
    }
    ::std::string NbdFindUnusedReverse(const ::Ice::Context& __ctx)
    {
        return NbdFindUnusedReverse(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_NbdFindUnusedReverse(const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_NbdFindUnusedReverse(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_NbdFindUnusedReverse(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_NbdFindUnusedReverse(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_NbdFindUnusedReverse(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_NbdFindUnusedReverse(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_NbdFindUnusedReverse(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_NbdFindUnusedReverse(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_NbdFindUnusedReverse(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_NbdFindUnusedReverse()
    {
        return begin_NbdFindUnusedReverse(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_NbdFindUnusedReverse(const ::Ice::Context& __ctx)
    {
        return begin_NbdFindUnusedReverse(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_NbdFindUnusedReverse(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_NbdFindUnusedReverse(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_NbdFindUnusedReverse(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_NbdFindUnusedReverse(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_NbdFindUnusedReverse(const ::BoxLogic::Callback_LogicInternal_NbdFindUnusedReversePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_NbdFindUnusedReverse(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_NbdFindUnusedReverse(const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_NbdFindUnusedReversePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_NbdFindUnusedReverse(&__ctx, __del, __cookie);
    }

    ::std::string end_NbdFindUnusedReverse(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string NbdFindUnusedReverse(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_NbdFindUnusedReverse(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void NbdSetUnused(const ::std::string& __p_deviceName)
    {
        NbdSetUnused(__p_deviceName, 0);
    }
    void NbdSetUnused(const ::std::string& __p_deviceName, const ::Ice::Context& __ctx)
    {
        NbdSetUnused(__p_deviceName, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_NbdSetUnused(const ::std::string& __p_deviceName, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_NbdSetUnused(__p_deviceName, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_NbdSetUnused(const ::std::string& __p_deviceName, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_NbdSetUnused(__p_deviceName, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_NbdSetUnused(const ::std::string& __p_deviceName, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_NbdSetUnused(__p_deviceName, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_NbdSetUnused(const ::std::string& __p_deviceName, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_NbdSetUnused(__p_deviceName, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_NbdSetUnused(const ::std::string& __p_deviceName, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_NbdSetUnused(const ::std::string& __p_deviceName)
    {
        return begin_NbdSetUnused(__p_deviceName, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_NbdSetUnused(const ::std::string& __p_deviceName, const ::Ice::Context& __ctx)
    {
        return begin_NbdSetUnused(__p_deviceName, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_NbdSetUnused(const ::std::string& __p_deviceName, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_NbdSetUnused(__p_deviceName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_NbdSetUnused(const ::std::string& __p_deviceName, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_NbdSetUnused(__p_deviceName, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_NbdSetUnused(const ::std::string& __p_deviceName, const ::BoxLogic::Callback_LogicInternal_NbdSetUnusedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_NbdSetUnused(__p_deviceName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_NbdSetUnused(const ::std::string& __p_deviceName, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_NbdSetUnusedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_NbdSetUnused(__p_deviceName, &__ctx, __del, __cookie);
    }

    void end_NbdSetUnused(const ::Ice::AsyncResultPtr&);
    
private:

    void NbdSetUnused(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_NbdSetUnused(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void NbdSetUsed(const ::std::string& __p_deviceName)
    {
        NbdSetUsed(__p_deviceName, 0);
    }
    void NbdSetUsed(const ::std::string& __p_deviceName, const ::Ice::Context& __ctx)
    {
        NbdSetUsed(__p_deviceName, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_NbdSetUsed(const ::std::string& __p_deviceName, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_NbdSetUsed(__p_deviceName, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_NbdSetUsed(const ::std::string& __p_deviceName, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_NbdSetUsed(__p_deviceName, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_NbdSetUsed(const ::std::string& __p_deviceName, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_NbdSetUsed(__p_deviceName, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_NbdSetUsed(const ::std::string& __p_deviceName, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_NbdSetUsed(__p_deviceName, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_NbdSetUsed(const ::std::string& __p_deviceName, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_NbdSetUsed(const ::std::string& __p_deviceName)
    {
        return begin_NbdSetUsed(__p_deviceName, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_NbdSetUsed(const ::std::string& __p_deviceName, const ::Ice::Context& __ctx)
    {
        return begin_NbdSetUsed(__p_deviceName, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_NbdSetUsed(const ::std::string& __p_deviceName, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_NbdSetUsed(__p_deviceName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_NbdSetUsed(const ::std::string& __p_deviceName, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_NbdSetUsed(__p_deviceName, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_NbdSetUsed(const ::std::string& __p_deviceName, const ::BoxLogic::Callback_LogicInternal_NbdSetUsedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_NbdSetUsed(__p_deviceName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_NbdSetUsed(const ::std::string& __p_deviceName, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_NbdSetUsedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_NbdSetUsed(__p_deviceName, &__ctx, __del, __cookie);
    }

    void end_NbdSetUsed(const ::Ice::AsyncResultPtr&);
    
private:

    void NbdSetUsed(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_NbdSetUsed(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string queryTakeOverHostInfo(const ::std::string& __p_queryString)
    {
        return queryTakeOverHostInfo(__p_queryString, 0);
    }
    ::std::string queryTakeOverHostInfo(const ::std::string& __p_queryString, const ::Ice::Context& __ctx)
    {
        return queryTakeOverHostInfo(__p_queryString, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_queryTakeOverHostInfo(const ::std::string& __p_queryString, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_queryTakeOverHostInfo(__p_queryString, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_queryTakeOverHostInfo(const ::std::string& __p_queryString, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_queryTakeOverHostInfo(__p_queryString, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_queryTakeOverHostInfo(const ::std::string& __p_queryString, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_queryTakeOverHostInfo(__p_queryString, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_queryTakeOverHostInfo(const ::std::string& __p_queryString, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_queryTakeOverHostInfo(__p_queryString, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_queryTakeOverHostInfo(const ::std::string& __p_queryString, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_queryTakeOverHostInfo(const ::std::string& __p_queryString)
    {
        return begin_queryTakeOverHostInfo(__p_queryString, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_queryTakeOverHostInfo(const ::std::string& __p_queryString, const ::Ice::Context& __ctx)
    {
        return begin_queryTakeOverHostInfo(__p_queryString, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_queryTakeOverHostInfo(const ::std::string& __p_queryString, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryTakeOverHostInfo(__p_queryString, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryTakeOverHostInfo(const ::std::string& __p_queryString, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryTakeOverHostInfo(__p_queryString, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryTakeOverHostInfo(const ::std::string& __p_queryString, const ::BoxLogic::Callback_LogicInternal_queryTakeOverHostInfoPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryTakeOverHostInfo(__p_queryString, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_queryTakeOverHostInfo(const ::std::string& __p_queryString, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_queryTakeOverHostInfoPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_queryTakeOverHostInfo(__p_queryString, &__ctx, __del, __cookie);
    }

    ::std::string end_queryTakeOverHostInfo(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string queryTakeOverHostInfo(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_queryTakeOverHostInfo(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void mergeQcowFile(const ::std::string& __p_jsonInput)
    {
        mergeQcowFile(__p_jsonInput, 0);
    }
    void mergeQcowFile(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx)
    {
        mergeQcowFile(__p_jsonInput, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_mergeQcowFile(const ::std::string& __p_jsonInput, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_mergeQcowFile(__p_jsonInput, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_mergeQcowFile(const ::std::string& __p_jsonInput, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_mergeQcowFile(__p_jsonInput, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_mergeQcowFile(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_mergeQcowFile(__p_jsonInput, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_mergeQcowFile(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_mergeQcowFile(__p_jsonInput, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_mergeQcowFile(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_mergeQcowFile(const ::std::string& __p_jsonInput)
    {
        return begin_mergeQcowFile(__p_jsonInput, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_mergeQcowFile(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx)
    {
        return begin_mergeQcowFile(__p_jsonInput, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_mergeQcowFile(const ::std::string& __p_jsonInput, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mergeQcowFile(__p_jsonInput, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_mergeQcowFile(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mergeQcowFile(__p_jsonInput, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_mergeQcowFile(const ::std::string& __p_jsonInput, const ::BoxLogic::Callback_LogicInternal_mergeQcowFilePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mergeQcowFile(__p_jsonInput, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_mergeQcowFile(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_mergeQcowFilePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mergeQcowFile(__p_jsonInput, &__ctx, __del, __cookie);
    }

    void end_mergeQcowFile(const ::Ice::AsyncResultPtr&);
    
private:

    void mergeQcowFile(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_mergeQcowFile(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string startBackupOptimize(const ::std::string& __p_jsonInput)
    {
        return startBackupOptimize(__p_jsonInput, 0);
    }
    ::std::string startBackupOptimize(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx)
    {
        return startBackupOptimize(__p_jsonInput, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_startBackupOptimize(const ::std::string& __p_jsonInput, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_startBackupOptimize(__p_jsonInput, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_startBackupOptimize(const ::std::string& __p_jsonInput, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_startBackupOptimize(__p_jsonInput, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_startBackupOptimize(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_startBackupOptimize(__p_jsonInput, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_startBackupOptimize(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_startBackupOptimize(__p_jsonInput, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_startBackupOptimize(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_startBackupOptimize(const ::std::string& __p_jsonInput)
    {
        return begin_startBackupOptimize(__p_jsonInput, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_startBackupOptimize(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx)
    {
        return begin_startBackupOptimize(__p_jsonInput, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_startBackupOptimize(const ::std::string& __p_jsonInput, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_startBackupOptimize(__p_jsonInput, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_startBackupOptimize(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_startBackupOptimize(__p_jsonInput, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_startBackupOptimize(const ::std::string& __p_jsonInput, const ::BoxLogic::Callback_LogicInternal_startBackupOptimizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_startBackupOptimize(__p_jsonInput, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_startBackupOptimize(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_startBackupOptimizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_startBackupOptimize(__p_jsonInput, &__ctx, __del, __cookie);
    }

    ::std::string end_startBackupOptimize(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string startBackupOptimize(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_startBackupOptimize(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void stopBackupOptimize(const ::std::string& __p_jsonInput)
    {
        stopBackupOptimize(__p_jsonInput, 0);
    }
    void stopBackupOptimize(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx)
    {
        stopBackupOptimize(__p_jsonInput, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_stopBackupOptimize(const ::std::string& __p_jsonInput, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_stopBackupOptimize(__p_jsonInput, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_stopBackupOptimize(const ::std::string& __p_jsonInput, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_stopBackupOptimize(__p_jsonInput, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_stopBackupOptimize(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_stopBackupOptimize(__p_jsonInput, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_stopBackupOptimize(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_stopBackupOptimize(__p_jsonInput, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_stopBackupOptimize(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_stopBackupOptimize(const ::std::string& __p_jsonInput)
    {
        return begin_stopBackupOptimize(__p_jsonInput, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_stopBackupOptimize(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx)
    {
        return begin_stopBackupOptimize(__p_jsonInput, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_stopBackupOptimize(const ::std::string& __p_jsonInput, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_stopBackupOptimize(__p_jsonInput, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_stopBackupOptimize(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_stopBackupOptimize(__p_jsonInput, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_stopBackupOptimize(const ::std::string& __p_jsonInput, const ::BoxLogic::Callback_LogicInternal_stopBackupOptimizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_stopBackupOptimize(__p_jsonInput, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_stopBackupOptimize(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_stopBackupOptimizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_stopBackupOptimize(__p_jsonInput, &__ctx, __del, __cookie);
    }

    void end_stopBackupOptimize(const ::Ice::AsyncResultPtr&);
    
private:

    void stopBackupOptimize(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_stopBackupOptimize(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void mergeHashFile(const ::std::string& __p_jsonInput)
    {
        mergeHashFile(__p_jsonInput, 0);
    }
    void mergeHashFile(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx)
    {
        mergeHashFile(__p_jsonInput, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_mergeHashFile(const ::std::string& __p_jsonInput, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_mergeHashFile(__p_jsonInput, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_mergeHashFile(const ::std::string& __p_jsonInput, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_mergeHashFile(__p_jsonInput, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_mergeHashFile(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_mergeHashFile(__p_jsonInput, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_mergeHashFile(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_mergeHashFile(__p_jsonInput, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_mergeHashFile(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_mergeHashFile(const ::std::string& __p_jsonInput)
    {
        return begin_mergeHashFile(__p_jsonInput, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_mergeHashFile(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx)
    {
        return begin_mergeHashFile(__p_jsonInput, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_mergeHashFile(const ::std::string& __p_jsonInput, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mergeHashFile(__p_jsonInput, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_mergeHashFile(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mergeHashFile(__p_jsonInput, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_mergeHashFile(const ::std::string& __p_jsonInput, const ::BoxLogic::Callback_LogicInternal_mergeHashFilePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mergeHashFile(__p_jsonInput, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_mergeHashFile(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_mergeHashFilePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_mergeHashFile(__p_jsonInput, &__ctx, __del, __cookie);
    }

    void end_mergeHashFile(const ::Ice::AsyncResultPtr&);
    
private:

    void mergeHashFile(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_mergeHashFile(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void generateBitMapFromQcowFile(const ::std::string& __p_jsonArgs)
    {
        generateBitMapFromQcowFile(__p_jsonArgs, 0);
    }
    void generateBitMapFromQcowFile(const ::std::string& __p_jsonArgs, const ::Ice::Context& __ctx)
    {
        generateBitMapFromQcowFile(__p_jsonArgs, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_generateBitMapFromQcowFile(const ::std::string& __p_jsonArgs, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_generateBitMapFromQcowFile(__p_jsonArgs, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_generateBitMapFromQcowFile(const ::std::string& __p_jsonArgs, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_generateBitMapFromQcowFile(__p_jsonArgs, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_generateBitMapFromQcowFile(const ::std::string& __p_jsonArgs, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_generateBitMapFromQcowFile(__p_jsonArgs, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_generateBitMapFromQcowFile(const ::std::string& __p_jsonArgs, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_generateBitMapFromQcowFile(__p_jsonArgs, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_generateBitMapFromQcowFile(const ::std::string& __p_jsonArgs, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_generateBitMapFromQcowFile(const ::std::string& __p_jsonArgs)
    {
        return begin_generateBitMapFromQcowFile(__p_jsonArgs, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_generateBitMapFromQcowFile(const ::std::string& __p_jsonArgs, const ::Ice::Context& __ctx)
    {
        return begin_generateBitMapFromQcowFile(__p_jsonArgs, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_generateBitMapFromQcowFile(const ::std::string& __p_jsonArgs, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_generateBitMapFromQcowFile(__p_jsonArgs, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_generateBitMapFromQcowFile(const ::std::string& __p_jsonArgs, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_generateBitMapFromQcowFile(__p_jsonArgs, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_generateBitMapFromQcowFile(const ::std::string& __p_jsonArgs, const ::BoxLogic::Callback_LogicInternal_generateBitMapFromQcowFilePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_generateBitMapFromQcowFile(__p_jsonArgs, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_generateBitMapFromQcowFile(const ::std::string& __p_jsonArgs, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_generateBitMapFromQcowFilePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_generateBitMapFromQcowFile(__p_jsonArgs, &__ctx, __del, __cookie);
    }

    void end_generateBitMapFromQcowFile(const ::Ice::AsyncResultPtr&);
    
private:

    void generateBitMapFromQcowFile(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_generateBitMapFromQcowFile(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Long fromMapGetQcowMaxSize(const ::std::string& __p_mapPath)
    {
        return fromMapGetQcowMaxSize(__p_mapPath, 0);
    }
    ::Ice::Long fromMapGetQcowMaxSize(const ::std::string& __p_mapPath, const ::Ice::Context& __ctx)
    {
        return fromMapGetQcowMaxSize(__p_mapPath, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_fromMapGetQcowMaxSize(const ::std::string& __p_mapPath, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_fromMapGetQcowMaxSize(__p_mapPath, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_fromMapGetQcowMaxSize(const ::std::string& __p_mapPath, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_fromMapGetQcowMaxSize(__p_mapPath, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_fromMapGetQcowMaxSize(const ::std::string& __p_mapPath, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_fromMapGetQcowMaxSize(__p_mapPath, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_fromMapGetQcowMaxSize(const ::std::string& __p_mapPath, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_fromMapGetQcowMaxSize(__p_mapPath, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_fromMapGetQcowMaxSize(const ::std::string& __p_mapPath, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_fromMapGetQcowMaxSize(const ::std::string& __p_mapPath)
    {
        return begin_fromMapGetQcowMaxSize(__p_mapPath, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_fromMapGetQcowMaxSize(const ::std::string& __p_mapPath, const ::Ice::Context& __ctx)
    {
        return begin_fromMapGetQcowMaxSize(__p_mapPath, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_fromMapGetQcowMaxSize(const ::std::string& __p_mapPath, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fromMapGetQcowMaxSize(__p_mapPath, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_fromMapGetQcowMaxSize(const ::std::string& __p_mapPath, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fromMapGetQcowMaxSize(__p_mapPath, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_fromMapGetQcowMaxSize(const ::std::string& __p_mapPath, const ::BoxLogic::Callback_LogicInternal_fromMapGetQcowMaxSizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fromMapGetQcowMaxSize(__p_mapPath, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_fromMapGetQcowMaxSize(const ::std::string& __p_mapPath, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_fromMapGetQcowMaxSizePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fromMapGetQcowMaxSize(__p_mapPath, &__ctx, __del, __cookie);
    }

    ::Ice::Long end_fromMapGetQcowMaxSize(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Long fromMapGetQcowMaxSize(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_fromMapGetQcowMaxSize(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void reorganizeHashFile(const ::BoxLogic::BinaryStream& __p_bitmap, const ::std::string& __p_jsonInput)
    {
        reorganizeHashFile(__p_bitmap, __p_jsonInput, 0);
    }
    void reorganizeHashFile(const ::BoxLogic::BinaryStream& __p_bitmap, const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx)
    {
        reorganizeHashFile(__p_bitmap, __p_jsonInput, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_reorganizeHashFile(const ::BoxLogic::BinaryStream& __p_bitmap, const ::std::string& __p_jsonInput, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_reorganizeHashFile(__p_bitmap, __p_jsonInput, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_reorganizeHashFile(const ::BoxLogic::BinaryStream& __p_bitmap, const ::std::string& __p_jsonInput, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_reorganizeHashFile(__p_bitmap, __p_jsonInput, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_reorganizeHashFile(const ::BoxLogic::BinaryStream& __p_bitmap, const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_reorganizeHashFile(__p_bitmap, __p_jsonInput, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_reorganizeHashFile(const ::BoxLogic::BinaryStream& __p_bitmap, const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_reorganizeHashFile(__p_bitmap, __p_jsonInput, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_reorganizeHashFile(const ::BoxLogic::BinaryStream& __p_bitmap, const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_reorganizeHashFile(const ::BoxLogic::BinaryStream& __p_bitmap, const ::std::string& __p_jsonInput)
    {
        return begin_reorganizeHashFile(__p_bitmap, __p_jsonInput, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reorganizeHashFile(const ::BoxLogic::BinaryStream& __p_bitmap, const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx)
    {
        return begin_reorganizeHashFile(__p_bitmap, __p_jsonInput, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reorganizeHashFile(const ::BoxLogic::BinaryStream& __p_bitmap, const ::std::string& __p_jsonInput, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reorganizeHashFile(__p_bitmap, __p_jsonInput, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reorganizeHashFile(const ::BoxLogic::BinaryStream& __p_bitmap, const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reorganizeHashFile(__p_bitmap, __p_jsonInput, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reorganizeHashFile(const ::BoxLogic::BinaryStream& __p_bitmap, const ::std::string& __p_jsonInput, const ::BoxLogic::Callback_LogicInternal_reorganizeHashFilePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reorganizeHashFile(__p_bitmap, __p_jsonInput, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reorganizeHashFile(const ::BoxLogic::BinaryStream& __p_bitmap, const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_reorganizeHashFilePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reorganizeHashFile(__p_bitmap, __p_jsonInput, &__ctx, __del, __cookie);
    }

    void end_reorganizeHashFile(const ::Ice::AsyncResultPtr&);
    
private:

    void reorganizeHashFile(const ::BoxLogic::BinaryStream&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_reorganizeHashFile(const ::BoxLogic::BinaryStream&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void reorganizeHashFilev2(const ::std::string& __p_bitmapPath, const ::std::string& __p_jsonInput)
    {
        reorganizeHashFilev2(__p_bitmapPath, __p_jsonInput, 0);
    }
    void reorganizeHashFilev2(const ::std::string& __p_bitmapPath, const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx)
    {
        reorganizeHashFilev2(__p_bitmapPath, __p_jsonInput, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_reorganizeHashFilev2(const ::std::string& __p_bitmapPath, const ::std::string& __p_jsonInput, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_reorganizeHashFilev2(__p_bitmapPath, __p_jsonInput, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_reorganizeHashFilev2(const ::std::string& __p_bitmapPath, const ::std::string& __p_jsonInput, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_reorganizeHashFilev2(__p_bitmapPath, __p_jsonInput, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_reorganizeHashFilev2(const ::std::string& __p_bitmapPath, const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_reorganizeHashFilev2(__p_bitmapPath, __p_jsonInput, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_reorganizeHashFilev2(const ::std::string& __p_bitmapPath, const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_reorganizeHashFilev2(__p_bitmapPath, __p_jsonInput, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_reorganizeHashFilev2(const ::std::string& __p_bitmapPath, const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_reorganizeHashFilev2(const ::std::string& __p_bitmapPath, const ::std::string& __p_jsonInput)
    {
        return begin_reorganizeHashFilev2(__p_bitmapPath, __p_jsonInput, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reorganizeHashFilev2(const ::std::string& __p_bitmapPath, const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx)
    {
        return begin_reorganizeHashFilev2(__p_bitmapPath, __p_jsonInput, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_reorganizeHashFilev2(const ::std::string& __p_bitmapPath, const ::std::string& __p_jsonInput, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reorganizeHashFilev2(__p_bitmapPath, __p_jsonInput, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reorganizeHashFilev2(const ::std::string& __p_bitmapPath, const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reorganizeHashFilev2(__p_bitmapPath, __p_jsonInput, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reorganizeHashFilev2(const ::std::string& __p_bitmapPath, const ::std::string& __p_jsonInput, const ::BoxLogic::Callback_LogicInternal_reorganizeHashFilev2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reorganizeHashFilev2(__p_bitmapPath, __p_jsonInput, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_reorganizeHashFilev2(const ::std::string& __p_bitmapPath, const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_reorganizeHashFilev2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_reorganizeHashFilev2(__p_bitmapPath, __p_jsonInput, &__ctx, __del, __cookie);
    }

    void end_reorganizeHashFilev2(const ::Ice::AsyncResultPtr&);
    
private:

    void reorganizeHashFilev2(const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_reorganizeHashFilev2(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Long hash2Interval(const ::std::string& __p_jsonInput)
    {
        return hash2Interval(__p_jsonInput, 0);
    }
    ::Ice::Long hash2Interval(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx)
    {
        return hash2Interval(__p_jsonInput, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_hash2Interval(const ::std::string& __p_jsonInput, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_hash2Interval(__p_jsonInput, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_hash2Interval(const ::std::string& __p_jsonInput, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_hash2Interval(__p_jsonInput, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_hash2Interval(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_hash2Interval(__p_jsonInput, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_hash2Interval(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_hash2Interval(__p_jsonInput, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_hash2Interval(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_hash2Interval(const ::std::string& __p_jsonInput)
    {
        return begin_hash2Interval(__p_jsonInput, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_hash2Interval(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx)
    {
        return begin_hash2Interval(__p_jsonInput, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_hash2Interval(const ::std::string& __p_jsonInput, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_hash2Interval(__p_jsonInput, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_hash2Interval(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_hash2Interval(__p_jsonInput, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_hash2Interval(const ::std::string& __p_jsonInput, const ::BoxLogic::Callback_LogicInternal_hash2IntervalPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_hash2Interval(__p_jsonInput, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_hash2Interval(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_hash2IntervalPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_hash2Interval(__p_jsonInput, &__ctx, __del, __cookie);
    }

    ::Ice::Long end_hash2Interval(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Long hash2Interval(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_hash2Interval(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string exportSnapshot(const ::std::string& __p_jsonInput)
    {
        return exportSnapshot(__p_jsonInput, 0);
    }
    ::std::string exportSnapshot(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx)
    {
        return exportSnapshot(__p_jsonInput, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_exportSnapshot(const ::std::string& __p_jsonInput, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_exportSnapshot(__p_jsonInput, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_exportSnapshot(const ::std::string& __p_jsonInput, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_exportSnapshot(__p_jsonInput, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_exportSnapshot(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_exportSnapshot(__p_jsonInput, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_exportSnapshot(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_exportSnapshot(__p_jsonInput, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_exportSnapshot(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_exportSnapshot(const ::std::string& __p_jsonInput)
    {
        return begin_exportSnapshot(__p_jsonInput, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_exportSnapshot(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx)
    {
        return begin_exportSnapshot(__p_jsonInput, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_exportSnapshot(const ::std::string& __p_jsonInput, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_exportSnapshot(__p_jsonInput, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_exportSnapshot(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_exportSnapshot(__p_jsonInput, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_exportSnapshot(const ::std::string& __p_jsonInput, const ::BoxLogic::Callback_LogicInternal_exportSnapshotPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_exportSnapshot(__p_jsonInput, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_exportSnapshot(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_exportSnapshotPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_exportSnapshot(__p_jsonInput, &__ctx, __del, __cookie);
    }

    ::std::string end_exportSnapshot(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string exportSnapshot(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_exportSnapshot(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string getAllTapeJson()
    {
        return getAllTapeJson(0);
    }
    ::std::string getAllTapeJson(const ::Ice::Context& __ctx)
    {
        return getAllTapeJson(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getAllTapeJson(const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getAllTapeJson(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getAllTapeJson(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getAllTapeJson(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getAllTapeJson(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getAllTapeJson(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getAllTapeJson(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getAllTapeJson(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getAllTapeJson(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getAllTapeJson()
    {
        return begin_getAllTapeJson(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAllTapeJson(const ::Ice::Context& __ctx)
    {
        return begin_getAllTapeJson(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAllTapeJson(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAllTapeJson(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAllTapeJson(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAllTapeJson(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAllTapeJson(const ::BoxLogic::Callback_LogicInternal_getAllTapeJsonPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAllTapeJson(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAllTapeJson(const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_getAllTapeJsonPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAllTapeJson(&__ctx, __del, __cookie);
    }

    ::std::string end_getAllTapeJson(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string getAllTapeJson(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getAllTapeJson(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string getAllMediumxJson()
    {
        return getAllMediumxJson(0);
    }
    ::std::string getAllMediumxJson(const ::Ice::Context& __ctx)
    {
        return getAllMediumxJson(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getAllMediumxJson(const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getAllMediumxJson(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getAllMediumxJson(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getAllMediumxJson(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getAllMediumxJson(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getAllMediumxJson(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getAllMediumxJson(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getAllMediumxJson(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getAllMediumxJson(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getAllMediumxJson()
    {
        return begin_getAllMediumxJson(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAllMediumxJson(const ::Ice::Context& __ctx)
    {
        return begin_getAllMediumxJson(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAllMediumxJson(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAllMediumxJson(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAllMediumxJson(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAllMediumxJson(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAllMediumxJson(const ::BoxLogic::Callback_LogicInternal_getAllMediumxJsonPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAllMediumxJson(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getAllMediumxJson(const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_getAllMediumxJsonPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getAllMediumxJson(&__ctx, __del, __cookie);
    }

    ::std::string end_getAllMediumxJson(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string getAllMediumxJson(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getAllMediumxJson(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string archiveMediaOperation(const ::std::string& __p_jsonInput)
    {
        return archiveMediaOperation(__p_jsonInput, 0);
    }
    ::std::string archiveMediaOperation(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx)
    {
        return archiveMediaOperation(__p_jsonInput, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_archiveMediaOperation(const ::std::string& __p_jsonInput, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_archiveMediaOperation(__p_jsonInput, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_archiveMediaOperation(const ::std::string& __p_jsonInput, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_archiveMediaOperation(__p_jsonInput, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_archiveMediaOperation(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_archiveMediaOperation(__p_jsonInput, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_archiveMediaOperation(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_archiveMediaOperation(__p_jsonInput, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_archiveMediaOperation(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_archiveMediaOperation(const ::std::string& __p_jsonInput)
    {
        return begin_archiveMediaOperation(__p_jsonInput, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_archiveMediaOperation(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx)
    {
        return begin_archiveMediaOperation(__p_jsonInput, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_archiveMediaOperation(const ::std::string& __p_jsonInput, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_archiveMediaOperation(__p_jsonInput, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_archiveMediaOperation(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_archiveMediaOperation(__p_jsonInput, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_archiveMediaOperation(const ::std::string& __p_jsonInput, const ::BoxLogic::Callback_LogicInternal_archiveMediaOperationPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_archiveMediaOperation(__p_jsonInput, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_archiveMediaOperation(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_archiveMediaOperationPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_archiveMediaOperation(__p_jsonInput, &__ctx, __del, __cookie);
    }

    ::std::string end_archiveMediaOperation(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string archiveMediaOperation(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_archiveMediaOperation(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string getArchiveFileMetaData(const ::std::string& __p_jsonInput)
    {
        return getArchiveFileMetaData(__p_jsonInput, 0);
    }
    ::std::string getArchiveFileMetaData(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx)
    {
        return getArchiveFileMetaData(__p_jsonInput, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getArchiveFileMetaData(const ::std::string& __p_jsonInput, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getArchiveFileMetaData(__p_jsonInput, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getArchiveFileMetaData(const ::std::string& __p_jsonInput, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getArchiveFileMetaData(__p_jsonInput, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getArchiveFileMetaData(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getArchiveFileMetaData(__p_jsonInput, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getArchiveFileMetaData(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getArchiveFileMetaData(__p_jsonInput, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getArchiveFileMetaData(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getArchiveFileMetaData(const ::std::string& __p_jsonInput)
    {
        return begin_getArchiveFileMetaData(__p_jsonInput, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getArchiveFileMetaData(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx)
    {
        return begin_getArchiveFileMetaData(__p_jsonInput, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getArchiveFileMetaData(const ::std::string& __p_jsonInput, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getArchiveFileMetaData(__p_jsonInput, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getArchiveFileMetaData(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getArchiveFileMetaData(__p_jsonInput, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getArchiveFileMetaData(const ::std::string& __p_jsonInput, const ::BoxLogic::Callback_LogicInternal_getArchiveFileMetaDataPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getArchiveFileMetaData(__p_jsonInput, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getArchiveFileMetaData(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_getArchiveFileMetaDataPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getArchiveFileMetaData(__p_jsonInput, &__ctx, __del, __cookie);
    }

    ::std::string end_getArchiveFileMetaData(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string getArchiveFileMetaData(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getArchiveFileMetaData(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string genArchiveQcowFile(const ::std::string& __p_jsonInput)
    {
        return genArchiveQcowFile(__p_jsonInput, 0);
    }
    ::std::string genArchiveQcowFile(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx)
    {
        return genArchiveQcowFile(__p_jsonInput, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_genArchiveQcowFile(const ::std::string& __p_jsonInput, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_genArchiveQcowFile(__p_jsonInput, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_genArchiveQcowFile(const ::std::string& __p_jsonInput, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_genArchiveQcowFile(__p_jsonInput, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_genArchiveQcowFile(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_genArchiveQcowFile(__p_jsonInput, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_genArchiveQcowFile(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_genArchiveQcowFile(__p_jsonInput, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_genArchiveQcowFile(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_genArchiveQcowFile(const ::std::string& __p_jsonInput)
    {
        return begin_genArchiveQcowFile(__p_jsonInput, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_genArchiveQcowFile(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx)
    {
        return begin_genArchiveQcowFile(__p_jsonInput, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_genArchiveQcowFile(const ::std::string& __p_jsonInput, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_genArchiveQcowFile(__p_jsonInput, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_genArchiveQcowFile(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_genArchiveQcowFile(__p_jsonInput, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_genArchiveQcowFile(const ::std::string& __p_jsonInput, const ::BoxLogic::Callback_LogicInternal_genArchiveQcowFilePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_genArchiveQcowFile(__p_jsonInput, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_genArchiveQcowFile(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_genArchiveQcowFilePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_genArchiveQcowFile(__p_jsonInput, &__ctx, __del, __cookie);
    }

    ::std::string end_genArchiveQcowFile(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string genArchiveQcowFile(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_genArchiveQcowFile(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string fileBackup(const ::std::string& __p_jsonInput)
    {
        return fileBackup(__p_jsonInput, 0);
    }
    ::std::string fileBackup(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx)
    {
        return fileBackup(__p_jsonInput, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_fileBackup(const ::std::string& __p_jsonInput, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_fileBackup(__p_jsonInput, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_fileBackup(const ::std::string& __p_jsonInput, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_fileBackup(__p_jsonInput, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_fileBackup(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_fileBackup(__p_jsonInput, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_fileBackup(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_fileBackup(__p_jsonInput, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_fileBackup(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_fileBackup(const ::std::string& __p_jsonInput)
    {
        return begin_fileBackup(__p_jsonInput, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_fileBackup(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx)
    {
        return begin_fileBackup(__p_jsonInput, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_fileBackup(const ::std::string& __p_jsonInput, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fileBackup(__p_jsonInput, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_fileBackup(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fileBackup(__p_jsonInput, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_fileBackup(const ::std::string& __p_jsonInput, const ::BoxLogic::Callback_LogicInternal_fileBackupPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fileBackup(__p_jsonInput, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_fileBackup(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_fileBackupPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_fileBackup(__p_jsonInput, &__ctx, __del, __cookie);
    }

    ::std::string end_fileBackup(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string fileBackup(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_fileBackup(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string kvmRpc(const ::std::string& __p_jsonInput)
    {
        return kvmRpc(__p_jsonInput, 0);
    }
    ::std::string kvmRpc(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx)
    {
        return kvmRpc(__p_jsonInput, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_kvmRpc(const ::std::string& __p_jsonInput, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_kvmRpc(__p_jsonInput, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_kvmRpc(const ::std::string& __p_jsonInput, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_kvmRpc(__p_jsonInput, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_kvmRpc(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_kvmRpc(__p_jsonInput, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_kvmRpc(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_kvmRpc(__p_jsonInput, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_kvmRpc(const ::std::string& __p_jsonInput, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_kvmRpc(const ::std::string& __p_jsonInput)
    {
        return begin_kvmRpc(__p_jsonInput, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_kvmRpc(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx)
    {
        return begin_kvmRpc(__p_jsonInput, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_kvmRpc(const ::std::string& __p_jsonInput, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_kvmRpc(__p_jsonInput, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_kvmRpc(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_kvmRpc(__p_jsonInput, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_kvmRpc(const ::std::string& __p_jsonInput, const ::BoxLogic::Callback_LogicInternal_kvmRpcPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_kvmRpc(__p_jsonInput, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_kvmRpc(const ::std::string& __p_jsonInput, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_LogicInternal_kvmRpcPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_kvmRpc(__p_jsonInput, &__ctx, __del, __cookie);
    }

    ::std::string end_kvmRpc(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string kvmRpc(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_kvmRpc(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<LogicInternal> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<LogicInternal*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<LogicInternal> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<LogicInternal*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<LogicInternal> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<LogicInternal*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<LogicInternal> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<LogicInternal*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<LogicInternal> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<LogicInternal*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<LogicInternal> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<LogicInternal*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<LogicInternal> ice_secure(bool __secure) const
    {
        return dynamic_cast<LogicInternal*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<LogicInternal> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<LogicInternal*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<LogicInternal> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<LogicInternal*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<LogicInternal> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<LogicInternal*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<LogicInternal> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<LogicInternal*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<LogicInternal> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<LogicInternal*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<LogicInternal> ice_twoway() const
    {
        return dynamic_cast<LogicInternal*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<LogicInternal> ice_oneway() const
    {
        return dynamic_cast<LogicInternal*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<LogicInternal> ice_batchOneway() const
    {
        return dynamic_cast<LogicInternal*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<LogicInternal> ice_datagram() const
    {
        return dynamic_cast<LogicInternal*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<LogicInternal> ice_batchDatagram() const
    {
        return dynamic_cast<LogicInternal*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<LogicInternal> ice_compress(bool __compress) const
    {
        return dynamic_cast<LogicInternal*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<LogicInternal> ice_timeout(int __timeout) const
    {
        return dynamic_cast<LogicInternal*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<LogicInternal> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<LogicInternal*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<LogicInternal> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<LogicInternal*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class Setup : virtual public ::IceProxy::Ice::Object
{
public:

    void startSetup(const ::std::string& __p_session, const ::std::string& __p_flagJson)
    {
        startSetup(__p_session, __p_flagJson, 0);
    }
    void startSetup(const ::std::string& __p_session, const ::std::string& __p_flagJson, const ::Ice::Context& __ctx)
    {
        startSetup(__p_session, __p_flagJson, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_startSetup(const ::std::string& __p_session, const ::std::string& __p_flagJson, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_startSetup(__p_session, __p_flagJson, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_startSetup(const ::std::string& __p_session, const ::std::string& __p_flagJson, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_startSetup(__p_session, __p_flagJson, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_startSetup(const ::std::string& __p_session, const ::std::string& __p_flagJson, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_startSetup(__p_session, __p_flagJson, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_startSetup(const ::std::string& __p_session, const ::std::string& __p_flagJson, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_startSetup(__p_session, __p_flagJson, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_startSetup(const ::std::string& __p_session, const ::std::string& __p_flagJson, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_startSetup(const ::std::string& __p_session, const ::std::string& __p_flagJson)
    {
        return begin_startSetup(__p_session, __p_flagJson, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_startSetup(const ::std::string& __p_session, const ::std::string& __p_flagJson, const ::Ice::Context& __ctx)
    {
        return begin_startSetup(__p_session, __p_flagJson, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_startSetup(const ::std::string& __p_session, const ::std::string& __p_flagJson, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_startSetup(__p_session, __p_flagJson, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_startSetup(const ::std::string& __p_session, const ::std::string& __p_flagJson, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_startSetup(__p_session, __p_flagJson, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_startSetup(const ::std::string& __p_session, const ::std::string& __p_flagJson, const ::BoxLogic::Callback_Setup_startSetupPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_startSetup(__p_session, __p_flagJson, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_startSetup(const ::std::string& __p_session, const ::std::string& __p_flagJson, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_Setup_startSetupPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_startSetup(__p_session, __p_flagJson, &__ctx, __del, __cookie);
    }

    void end_startSetup(const ::Ice::AsyncResultPtr&);
    
private:

    void startSetup(const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_startSetup(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void cancelSetup(const ::std::string& __p_session)
    {
        cancelSetup(__p_session, 0);
    }
    void cancelSetup(const ::std::string& __p_session, const ::Ice::Context& __ctx)
    {
        cancelSetup(__p_session, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_cancelSetup(const ::std::string& __p_session, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_cancelSetup(__p_session, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_cancelSetup(const ::std::string& __p_session, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_cancelSetup(__p_session, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_cancelSetup(const ::std::string& __p_session, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_cancelSetup(__p_session, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_cancelSetup(const ::std::string& __p_session, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_cancelSetup(__p_session, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_cancelSetup(const ::std::string& __p_session, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_cancelSetup(const ::std::string& __p_session)
    {
        return begin_cancelSetup(__p_session, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_cancelSetup(const ::std::string& __p_session, const ::Ice::Context& __ctx)
    {
        return begin_cancelSetup(__p_session, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_cancelSetup(const ::std::string& __p_session, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_cancelSetup(__p_session, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_cancelSetup(const ::std::string& __p_session, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_cancelSetup(__p_session, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_cancelSetup(const ::std::string& __p_session, const ::BoxLogic::Callback_Setup_cancelSetupPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_cancelSetup(__p_session, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_cancelSetup(const ::std::string& __p_session, const ::Ice::Context& __ctx, const ::BoxLogic::Callback_Setup_cancelSetupPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_cancelSetup(__p_session, &__ctx, __del, __cookie);
    }

    void end_cancelSetup(const ::Ice::AsyncResultPtr&);
    
private:

    void cancelSetup(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_cancelSetup(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<Setup> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<Setup*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<Setup> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<Setup*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Setup> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<Setup*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<Setup> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<Setup*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Setup> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<Setup*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<Setup> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<Setup*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<Setup> ice_secure(bool __secure) const
    {
        return dynamic_cast<Setup*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<Setup> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<Setup*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<Setup> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<Setup*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<Setup> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<Setup*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<Setup> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<Setup*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<Setup> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<Setup*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Setup> ice_twoway() const
    {
        return dynamic_cast<Setup*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<Setup> ice_oneway() const
    {
        return dynamic_cast<Setup*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<Setup> ice_batchOneway() const
    {
        return dynamic_cast<Setup*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<Setup> ice_datagram() const
    {
        return dynamic_cast<Setup*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<Setup> ice_batchDatagram() const
    {
        return dynamic_cast<Setup*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<Setup> ice_compress(bool __compress) const
    {
        return dynamic_cast<Setup*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<Setup> ice_timeout(int __timeout) const
    {
        return dynamic_cast<Setup*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<Setup> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<Setup*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<Setup> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<Setup*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

namespace BoxLogic
{

class Logic : virtual public ::Ice::Object
{
public:

    typedef LogicPrx ProxyType;
    typedef LogicPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void ping(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___ping(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string queryHostName(const ::BoxLogic::AgentIdentification&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___queryHostName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool login(const ::std::string&, const ::std::string&, const ::std::string&, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___login(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void logout(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___logout(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string queryHostSoftIdent(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___queryHostSoftIdent(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void reportAgentModuleError(const ::std::string&, const ::BoxLogic::AgentModuleError&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___reportAgentModuleError(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void reportBackupProgress(const ::std::string&, const ::BoxLogic::BackupProgress&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___reportBackupProgress(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void reportBackupFinish(const ::std::string&, ::BoxLogic::BackupFinishCode, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___reportBackupFinish(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void reportVolumeRestoreStatus(const ::std::string&, ::BoxLogic::RestoreStageCode, const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___reportVolumeRestoreStatus(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void clearAllHostSession(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___clearAllHostSession(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string peLogin(const ::PerpcIce::PeGuestInfo&, const ::std::string&, const ::std::string&, ::Ice::Int, const IceUtil::Optional< ::std::string>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___peLogin(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void peLogout(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___peLogout(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void updateCDPToken(const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___updateCDPToken(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void updateTrafficControl(const ::std::string&, ::Ice::Long, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___updateTrafficControl(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void updateRestoreToken(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___updateRestoreToken(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void closeCDPToken(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___closeCDPToken(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void refreshSnapshotToken(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___refreshSnapshotToken(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void reportRestoreStatus(const ::std::string&, const ::BoxLogic::RestoreProgress&, bool, const IceUtil::Optional< ::std::string>&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___reportRestoreStatus(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string QueryJsonData(const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___QueryJsonData(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void startKvm(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___startKvm(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void fetchProxyEndPoints(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___fetchProxyEndPoints(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::BoxLogic::LastCdpDetail queryLastCdpDetailByRestoreToken(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___queryLastCdpDetailByRestoreToken(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool queryLastCdpDetailByCdpToken(const ::std::string&, const ::std::string&, ::BoxLogic::LastCdpDetail&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___queryLastCdpDetailByCdpToken(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string queryNetworkTransmissionType(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___queryNetworkTransmissionType(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int dataQueuingReport(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___dataQueuingReport(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string getHashFilePathByRestoreToken(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getHashFilePathByRestoreToken(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void VmwareAgentReport(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___VmwareAgentReport(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
};

inline bool operator==(const Logic& l, const Logic& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Logic& l, const Logic& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class LogicInternal : virtual public ::Ice::Object
{
public:

    typedef LogicInternalPrx ProxyType;
    typedef LogicInternalPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::std::string pathJoin(const ::BoxLogic::Paths&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___pathJoin(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool isFileExist(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___isFileExist(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool AllFilesExist(const ::BoxLogic::Paths&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___AllFilesExist(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool isFolderExist(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___isFolderExist(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void makeDirs(const ::std::string&, bool, ::Ice::Short, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___makeDirs(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void remove(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___remove(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void copy(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___copy(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void findFiles(const ::std::string&, ::BoxLogic::Paths&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___findFiles(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string queryCdpTimestampRange(const ::std::string&, bool, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___queryCdpTimestampRange(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string queryCdpTimestamp(const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___queryCdpTimestamp(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string formatCdpTimestamp(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___formatCdpTimestamp(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void mergeCdpFile(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___mergeCdpFile(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool isHardwareDriverExist(const ::BoxLogic::Hardware&, const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___isHardwareDriverExist(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string GetDriversVersions(const ::BoxLogic::Hardware&, const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___GetDriversVersions(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool ChkIsSubId(const ::BoxLogic::Hardware&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___ChkIsSubId(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string GetDriversSubList(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___GetDriversSubList(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void generatePeStageIso(const ::std::string&, const ::std::string&, const ::BoxLogic::Hardwares&, const ::BoxLogic::IPConfigs&, const ::BoxLogic::StringList&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___generatePeStageIso(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string runRestoreKvm(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___runRestoreKvm(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string getCurrentNetworkInfos(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getCurrentNetworkInfos(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setNetwork(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setNetwork(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string enumStorageNodes(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___enumStorageNodes(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string getLocalIqn(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getLocalIqn(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setLocalIqn(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setLocalIqn(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setGlobalDoubleChap(const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setGlobalDoubleChap(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool getGlobalDoubleChap(::std::string&, ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getGlobalDoubleChap(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string loginExternalDevice(const ::std::string&, ::Ice::Int, bool, const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___loginExternalDevice(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void logoutExternalDevice(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___logoutExternalDevice(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void refreshExternalDevice(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___refreshExternalDevice(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void formatAndInitializeStorageNode(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___formatAndInitializeStorageNode(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void mountStorageNode(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___mountStorageNode(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void unmountStorageNode(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___unmountStorageNode(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int runCmd(const ::std::string&, bool, ::BoxLogic::StringList&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___runCmd(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string CmdCtrl(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___CmdCtrl(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setPasswd(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setPasswd(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string getPasswd(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getPasswd(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void calcClusterTime0Hash(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___calcClusterTime0Hash(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void generateClusterDiffImages(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___generateClusterDiffImages(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void mergeCdpFiles(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___mergeCdpFiles(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void cutCdpFile(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___cutCdpFile(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int getRawDiskFiles(const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getRawDiskFiles(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string NbdFindUnusedReverse(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___NbdFindUnusedReverse(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void NbdSetUnused(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___NbdSetUnused(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void NbdSetUsed(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___NbdSetUsed(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string queryTakeOverHostInfo(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___queryTakeOverHostInfo(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void mergeQcowFile(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___mergeQcowFile(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string startBackupOptimize(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___startBackupOptimize(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void stopBackupOptimize(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___stopBackupOptimize(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void mergeHashFile(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___mergeHashFile(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void generateBitMapFromQcowFile(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___generateBitMapFromQcowFile(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Long fromMapGetQcowMaxSize(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___fromMapGetQcowMaxSize(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void reorganizeHashFile(const ::BoxLogic::BinaryStream&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___reorganizeHashFile(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void reorganizeHashFilev2(const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___reorganizeHashFilev2(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Long hash2Interval(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___hash2Interval(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string exportSnapshot(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___exportSnapshot(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string getAllTapeJson(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getAllTapeJson(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string getAllMediumxJson(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getAllMediumxJson(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string archiveMediaOperation(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___archiveMediaOperation(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string getArchiveFileMetaData(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getArchiveFileMetaData(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string genArchiveQcowFile(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___genArchiveQcowFile(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string fileBackup(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___fileBackup(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string kvmRpc(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___kvmRpc(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
};

inline bool operator==(const LogicInternal& l, const LogicInternal& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const LogicInternal& l, const LogicInternal& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class Setup : virtual public ::Ice::Object
{
public:

    typedef SetupPrx ProxyType;
    typedef SetupPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void startSetup(const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___startSetup(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void cancelSetup(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___cancelSetup(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
};

inline bool operator==(const Setup& l, const Setup& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const Setup& l, const Setup& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace BoxLogic
{

template<class T>
class CallbackNC_Logic_ping : public Callback_Logic_ping_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Logic_ping(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Logic_pingPtr
newCallback_Logic_ping(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_ping<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_pingPtr
newCallback_Logic_ping(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_ping<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Logic_pingPtr
newCallback_Logic_ping(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_ping<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_pingPtr
newCallback_Logic_ping(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_ping<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Logic_ping : public Callback_Logic_ping_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Logic_ping(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Logic_pingPtr
newCallback_Logic_ping(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_ping<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_pingPtr
newCallback_Logic_ping(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_ping<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_pingPtr
newCallback_Logic_ping(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_ping<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_pingPtr
newCallback_Logic_ping(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_ping<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Logic_queryHostName : public Callback_Logic_queryHostName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_Logic_queryHostName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_queryHostName(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Logic_queryHostNamePtr
newCallback_Logic_queryHostName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_queryHostName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_queryHostNamePtr
newCallback_Logic_queryHostName(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_queryHostName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Logic_queryHostName : public Callback_Logic_queryHostName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_Logic_queryHostName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_queryHostName(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Logic_queryHostNamePtr
newCallback_Logic_queryHostName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_queryHostName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_queryHostNamePtr
newCallback_Logic_queryHostName(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_queryHostName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Logic_login : public Callback_Logic_login_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_Logic_login(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_login(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Logic_loginPtr
newCallback_Logic_login(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_login<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_loginPtr
newCallback_Logic_login(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_login<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Logic_login : public Callback_Logic_login_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_Logic_login(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_login(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Logic_loginPtr
newCallback_Logic_login(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_login<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_loginPtr
newCallback_Logic_login(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_login<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Logic_logout : public Callback_Logic_logout_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Logic_logout(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Logic_logoutPtr
newCallback_Logic_logout(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_logout<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_logoutPtr
newCallback_Logic_logout(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_logout<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Logic_logoutPtr
newCallback_Logic_logout(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_logout<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_logoutPtr
newCallback_Logic_logout(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_logout<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Logic_logout : public Callback_Logic_logout_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Logic_logout(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Logic_logoutPtr
newCallback_Logic_logout(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_logout<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_logoutPtr
newCallback_Logic_logout(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_logout<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_logoutPtr
newCallback_Logic_logout(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_logout<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_logoutPtr
newCallback_Logic_logout(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_logout<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Logic_queryHostSoftIdent : public Callback_Logic_queryHostSoftIdent_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_Logic_queryHostSoftIdent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_queryHostSoftIdent(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Logic_queryHostSoftIdentPtr
newCallback_Logic_queryHostSoftIdent(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_queryHostSoftIdent<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_queryHostSoftIdentPtr
newCallback_Logic_queryHostSoftIdent(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_queryHostSoftIdent<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Logic_queryHostSoftIdent : public Callback_Logic_queryHostSoftIdent_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_Logic_queryHostSoftIdent(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_queryHostSoftIdent(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Logic_queryHostSoftIdentPtr
newCallback_Logic_queryHostSoftIdent(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_queryHostSoftIdent<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_queryHostSoftIdentPtr
newCallback_Logic_queryHostSoftIdent(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_queryHostSoftIdent<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Logic_reportAgentModuleError : public Callback_Logic_reportAgentModuleError_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Logic_reportAgentModuleError(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Logic_reportAgentModuleErrorPtr
newCallback_Logic_reportAgentModuleError(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_reportAgentModuleError<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_reportAgentModuleErrorPtr
newCallback_Logic_reportAgentModuleError(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_reportAgentModuleError<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Logic_reportAgentModuleErrorPtr
newCallback_Logic_reportAgentModuleError(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_reportAgentModuleError<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_reportAgentModuleErrorPtr
newCallback_Logic_reportAgentModuleError(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_reportAgentModuleError<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Logic_reportAgentModuleError : public Callback_Logic_reportAgentModuleError_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Logic_reportAgentModuleError(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Logic_reportAgentModuleErrorPtr
newCallback_Logic_reportAgentModuleError(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_reportAgentModuleError<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_reportAgentModuleErrorPtr
newCallback_Logic_reportAgentModuleError(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_reportAgentModuleError<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_reportAgentModuleErrorPtr
newCallback_Logic_reportAgentModuleError(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_reportAgentModuleError<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_reportAgentModuleErrorPtr
newCallback_Logic_reportAgentModuleError(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_reportAgentModuleError<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Logic_reportBackupProgress : public Callback_Logic_reportBackupProgress_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Logic_reportBackupProgress(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Logic_reportBackupProgressPtr
newCallback_Logic_reportBackupProgress(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_reportBackupProgress<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_reportBackupProgressPtr
newCallback_Logic_reportBackupProgress(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_reportBackupProgress<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Logic_reportBackupProgressPtr
newCallback_Logic_reportBackupProgress(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_reportBackupProgress<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_reportBackupProgressPtr
newCallback_Logic_reportBackupProgress(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_reportBackupProgress<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Logic_reportBackupProgress : public Callback_Logic_reportBackupProgress_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Logic_reportBackupProgress(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Logic_reportBackupProgressPtr
newCallback_Logic_reportBackupProgress(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_reportBackupProgress<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_reportBackupProgressPtr
newCallback_Logic_reportBackupProgress(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_reportBackupProgress<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_reportBackupProgressPtr
newCallback_Logic_reportBackupProgress(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_reportBackupProgress<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_reportBackupProgressPtr
newCallback_Logic_reportBackupProgress(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_reportBackupProgress<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Logic_reportBackupFinish : public Callback_Logic_reportBackupFinish_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Logic_reportBackupFinish(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_reportBackupFinish(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Logic_reportBackupFinishPtr
newCallback_Logic_reportBackupFinish(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_reportBackupFinish<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_reportBackupFinishPtr
newCallback_Logic_reportBackupFinish(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_reportBackupFinish<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Logic_reportBackupFinishPtr
newCallback_Logic_reportBackupFinish(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_reportBackupFinish<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_reportBackupFinishPtr
newCallback_Logic_reportBackupFinish(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_reportBackupFinish<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Logic_reportBackupFinish : public Callback_Logic_reportBackupFinish_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Logic_reportBackupFinish(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_reportBackupFinish(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Logic_reportBackupFinishPtr
newCallback_Logic_reportBackupFinish(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_reportBackupFinish<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_reportBackupFinishPtr
newCallback_Logic_reportBackupFinish(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_reportBackupFinish<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_reportBackupFinishPtr
newCallback_Logic_reportBackupFinish(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_reportBackupFinish<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_reportBackupFinishPtr
newCallback_Logic_reportBackupFinish(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_reportBackupFinish<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Logic_reportVolumeRestoreStatus : public Callback_Logic_reportVolumeRestoreStatus_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Logic_reportVolumeRestoreStatus(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_reportVolumeRestoreStatus(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Logic_reportVolumeRestoreStatusPtr
newCallback_Logic_reportVolumeRestoreStatus(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_reportVolumeRestoreStatus<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_reportVolumeRestoreStatusPtr
newCallback_Logic_reportVolumeRestoreStatus(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_reportVolumeRestoreStatus<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Logic_reportVolumeRestoreStatusPtr
newCallback_Logic_reportVolumeRestoreStatus(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_reportVolumeRestoreStatus<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_reportVolumeRestoreStatusPtr
newCallback_Logic_reportVolumeRestoreStatus(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_reportVolumeRestoreStatus<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Logic_reportVolumeRestoreStatus : public Callback_Logic_reportVolumeRestoreStatus_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Logic_reportVolumeRestoreStatus(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_reportVolumeRestoreStatus(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Logic_reportVolumeRestoreStatusPtr
newCallback_Logic_reportVolumeRestoreStatus(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_reportVolumeRestoreStatus<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_reportVolumeRestoreStatusPtr
newCallback_Logic_reportVolumeRestoreStatus(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_reportVolumeRestoreStatus<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_reportVolumeRestoreStatusPtr
newCallback_Logic_reportVolumeRestoreStatus(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_reportVolumeRestoreStatus<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_reportVolumeRestoreStatusPtr
newCallback_Logic_reportVolumeRestoreStatus(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_reportVolumeRestoreStatus<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Logic_clearAllHostSession : public Callback_Logic_clearAllHostSession_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Logic_clearAllHostSession(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Logic_clearAllHostSessionPtr
newCallback_Logic_clearAllHostSession(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_clearAllHostSession<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_clearAllHostSessionPtr
newCallback_Logic_clearAllHostSession(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_clearAllHostSession<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Logic_clearAllHostSessionPtr
newCallback_Logic_clearAllHostSession(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_clearAllHostSession<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_clearAllHostSessionPtr
newCallback_Logic_clearAllHostSession(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_clearAllHostSession<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Logic_clearAllHostSession : public Callback_Logic_clearAllHostSession_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Logic_clearAllHostSession(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Logic_clearAllHostSessionPtr
newCallback_Logic_clearAllHostSession(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_clearAllHostSession<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_clearAllHostSessionPtr
newCallback_Logic_clearAllHostSession(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_clearAllHostSession<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_clearAllHostSessionPtr
newCallback_Logic_clearAllHostSession(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_clearAllHostSession<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_clearAllHostSessionPtr
newCallback_Logic_clearAllHostSession(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_clearAllHostSession<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Logic_peLogin : public Callback_Logic_peLogin_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_Logic_peLogin(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_peLogin(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Logic_peLoginPtr
newCallback_Logic_peLogin(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_peLogin<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_peLoginPtr
newCallback_Logic_peLogin(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_peLogin<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Logic_peLogin : public Callback_Logic_peLogin_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_Logic_peLogin(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_peLogin(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Logic_peLoginPtr
newCallback_Logic_peLogin(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_peLogin<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_peLoginPtr
newCallback_Logic_peLogin(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_peLogin<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Logic_peLogout : public Callback_Logic_peLogout_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Logic_peLogout(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_Logic_peLogoutPtr
newCallback_Logic_peLogout(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_peLogout<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_peLogoutPtr
newCallback_Logic_peLogout(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_peLogout<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Logic_peLogoutPtr
newCallback_Logic_peLogout(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_peLogout<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_peLogoutPtr
newCallback_Logic_peLogout(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_peLogout<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Logic_peLogout : public Callback_Logic_peLogout_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Logic_peLogout(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_Logic_peLogoutPtr
newCallback_Logic_peLogout(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_peLogout<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_peLogoutPtr
newCallback_Logic_peLogout(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_peLogout<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_peLogoutPtr
newCallback_Logic_peLogout(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_peLogout<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_peLogoutPtr
newCallback_Logic_peLogout(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_peLogout<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Logic_updateCDPToken : public Callback_Logic_updateCDPToken_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Logic_updateCDPToken(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_updateCDPToken(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Logic_updateCDPTokenPtr
newCallback_Logic_updateCDPToken(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_updateCDPToken<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_updateCDPTokenPtr
newCallback_Logic_updateCDPToken(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_updateCDPToken<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Logic_updateCDPTokenPtr
newCallback_Logic_updateCDPToken(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_updateCDPToken<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_updateCDPTokenPtr
newCallback_Logic_updateCDPToken(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_updateCDPToken<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Logic_updateCDPToken : public Callback_Logic_updateCDPToken_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Logic_updateCDPToken(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_updateCDPToken(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Logic_updateCDPTokenPtr
newCallback_Logic_updateCDPToken(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_updateCDPToken<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_updateCDPTokenPtr
newCallback_Logic_updateCDPToken(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_updateCDPToken<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_updateCDPTokenPtr
newCallback_Logic_updateCDPToken(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_updateCDPToken<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_updateCDPTokenPtr
newCallback_Logic_updateCDPToken(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_updateCDPToken<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Logic_updateTrafficControl : public Callback_Logic_updateTrafficControl_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Logic_updateTrafficControl(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_updateTrafficControl(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Logic_updateTrafficControlPtr
newCallback_Logic_updateTrafficControl(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_updateTrafficControl<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_updateTrafficControlPtr
newCallback_Logic_updateTrafficControl(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_updateTrafficControl<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Logic_updateTrafficControlPtr
newCallback_Logic_updateTrafficControl(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_updateTrafficControl<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_updateTrafficControlPtr
newCallback_Logic_updateTrafficControl(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_updateTrafficControl<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Logic_updateTrafficControl : public Callback_Logic_updateTrafficControl_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Logic_updateTrafficControl(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_updateTrafficControl(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Logic_updateTrafficControlPtr
newCallback_Logic_updateTrafficControl(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_updateTrafficControl<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_updateTrafficControlPtr
newCallback_Logic_updateTrafficControl(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_updateTrafficControl<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_updateTrafficControlPtr
newCallback_Logic_updateTrafficControl(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_updateTrafficControl<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_updateTrafficControlPtr
newCallback_Logic_updateTrafficControl(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_updateTrafficControl<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Logic_updateRestoreToken : public Callback_Logic_updateRestoreToken_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Logic_updateRestoreToken(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_updateRestoreToken(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Logic_updateRestoreTokenPtr
newCallback_Logic_updateRestoreToken(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_updateRestoreToken<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_updateRestoreTokenPtr
newCallback_Logic_updateRestoreToken(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_updateRestoreToken<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Logic_updateRestoreTokenPtr
newCallback_Logic_updateRestoreToken(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_updateRestoreToken<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_updateRestoreTokenPtr
newCallback_Logic_updateRestoreToken(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_updateRestoreToken<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Logic_updateRestoreToken : public Callback_Logic_updateRestoreToken_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Logic_updateRestoreToken(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_updateRestoreToken(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Logic_updateRestoreTokenPtr
newCallback_Logic_updateRestoreToken(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_updateRestoreToken<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_updateRestoreTokenPtr
newCallback_Logic_updateRestoreToken(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_updateRestoreToken<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_updateRestoreTokenPtr
newCallback_Logic_updateRestoreToken(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_updateRestoreToken<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_updateRestoreTokenPtr
newCallback_Logic_updateRestoreToken(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_updateRestoreToken<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Logic_closeCDPToken : public Callback_Logic_closeCDPToken_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Logic_closeCDPToken(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_closeCDPToken(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Logic_closeCDPTokenPtr
newCallback_Logic_closeCDPToken(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_closeCDPToken<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_closeCDPTokenPtr
newCallback_Logic_closeCDPToken(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_closeCDPToken<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Logic_closeCDPTokenPtr
newCallback_Logic_closeCDPToken(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_closeCDPToken<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_closeCDPTokenPtr
newCallback_Logic_closeCDPToken(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_closeCDPToken<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Logic_closeCDPToken : public Callback_Logic_closeCDPToken_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Logic_closeCDPToken(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_closeCDPToken(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Logic_closeCDPTokenPtr
newCallback_Logic_closeCDPToken(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_closeCDPToken<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_closeCDPTokenPtr
newCallback_Logic_closeCDPToken(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_closeCDPToken<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_closeCDPTokenPtr
newCallback_Logic_closeCDPToken(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_closeCDPToken<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_closeCDPTokenPtr
newCallback_Logic_closeCDPToken(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_closeCDPToken<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Logic_refreshSnapshotToken : public Callback_Logic_refreshSnapshotToken_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Logic_refreshSnapshotToken(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_refreshSnapshotToken(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Logic_refreshSnapshotTokenPtr
newCallback_Logic_refreshSnapshotToken(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_refreshSnapshotToken<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_refreshSnapshotTokenPtr
newCallback_Logic_refreshSnapshotToken(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_refreshSnapshotToken<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Logic_refreshSnapshotTokenPtr
newCallback_Logic_refreshSnapshotToken(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_refreshSnapshotToken<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_refreshSnapshotTokenPtr
newCallback_Logic_refreshSnapshotToken(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_refreshSnapshotToken<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Logic_refreshSnapshotToken : public Callback_Logic_refreshSnapshotToken_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Logic_refreshSnapshotToken(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_refreshSnapshotToken(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Logic_refreshSnapshotTokenPtr
newCallback_Logic_refreshSnapshotToken(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_refreshSnapshotToken<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_refreshSnapshotTokenPtr
newCallback_Logic_refreshSnapshotToken(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_refreshSnapshotToken<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_refreshSnapshotTokenPtr
newCallback_Logic_refreshSnapshotToken(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_refreshSnapshotToken<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_refreshSnapshotTokenPtr
newCallback_Logic_refreshSnapshotToken(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_refreshSnapshotToken<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Logic_reportRestoreStatus : public Callback_Logic_reportRestoreStatus_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Logic_reportRestoreStatus(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_reportRestoreStatus(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Logic_reportRestoreStatusPtr
newCallback_Logic_reportRestoreStatus(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_reportRestoreStatus<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_reportRestoreStatusPtr
newCallback_Logic_reportRestoreStatus(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_reportRestoreStatus<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Logic_reportRestoreStatusPtr
newCallback_Logic_reportRestoreStatus(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_reportRestoreStatus<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_reportRestoreStatusPtr
newCallback_Logic_reportRestoreStatus(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_reportRestoreStatus<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Logic_reportRestoreStatus : public Callback_Logic_reportRestoreStatus_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Logic_reportRestoreStatus(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_reportRestoreStatus(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Logic_reportRestoreStatusPtr
newCallback_Logic_reportRestoreStatus(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_reportRestoreStatus<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_reportRestoreStatusPtr
newCallback_Logic_reportRestoreStatus(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_reportRestoreStatus<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_reportRestoreStatusPtr
newCallback_Logic_reportRestoreStatus(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_reportRestoreStatus<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_reportRestoreStatusPtr
newCallback_Logic_reportRestoreStatus(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_reportRestoreStatus<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Logic_QueryJsonData : public Callback_Logic_QueryJsonData_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_Logic_QueryJsonData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_QueryJsonData(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Logic_QueryJsonDataPtr
newCallback_Logic_QueryJsonData(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_QueryJsonData<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_QueryJsonDataPtr
newCallback_Logic_QueryJsonData(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_QueryJsonData<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Logic_QueryJsonData : public Callback_Logic_QueryJsonData_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_Logic_QueryJsonData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_QueryJsonData(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Logic_QueryJsonDataPtr
newCallback_Logic_QueryJsonData(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_QueryJsonData<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_QueryJsonDataPtr
newCallback_Logic_QueryJsonData(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_QueryJsonData<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Logic_startKvm : public Callback_Logic_startKvm_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Logic_startKvm(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_startKvm(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Logic_startKvmPtr
newCallback_Logic_startKvm(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_startKvm<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_startKvmPtr
newCallback_Logic_startKvm(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_startKvm<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Logic_startKvmPtr
newCallback_Logic_startKvm(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_startKvm<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_startKvmPtr
newCallback_Logic_startKvm(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_startKvm<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Logic_startKvm : public Callback_Logic_startKvm_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Logic_startKvm(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_startKvm(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Logic_startKvmPtr
newCallback_Logic_startKvm(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_startKvm<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_startKvmPtr
newCallback_Logic_startKvm(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_startKvm<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_startKvmPtr
newCallback_Logic_startKvm(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_startKvm<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_startKvmPtr
newCallback_Logic_startKvm(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_startKvm<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Logic_fetchProxyEndPoints : public Callback_Logic_fetchProxyEndPoints_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Logic_fetchProxyEndPoints(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_fetchProxyEndPoints(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Logic_fetchProxyEndPointsPtr
newCallback_Logic_fetchProxyEndPoints(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_fetchProxyEndPoints<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_fetchProxyEndPointsPtr
newCallback_Logic_fetchProxyEndPoints(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_fetchProxyEndPoints<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Logic_fetchProxyEndPointsPtr
newCallback_Logic_fetchProxyEndPoints(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_fetchProxyEndPoints<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_fetchProxyEndPointsPtr
newCallback_Logic_fetchProxyEndPoints(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_fetchProxyEndPoints<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Logic_fetchProxyEndPoints : public Callback_Logic_fetchProxyEndPoints_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Logic_fetchProxyEndPoints(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_fetchProxyEndPoints(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Logic_fetchProxyEndPointsPtr
newCallback_Logic_fetchProxyEndPoints(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_fetchProxyEndPoints<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_fetchProxyEndPointsPtr
newCallback_Logic_fetchProxyEndPoints(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_fetchProxyEndPoints<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_fetchProxyEndPointsPtr
newCallback_Logic_fetchProxyEndPoints(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_fetchProxyEndPoints<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_fetchProxyEndPointsPtr
newCallback_Logic_fetchProxyEndPoints(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_fetchProxyEndPoints<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Logic_queryLastCdpDetailByRestoreToken : public Callback_Logic_queryLastCdpDetailByRestoreToken_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::BoxLogic::LastCdpDetail&);

    CallbackNC_Logic_queryLastCdpDetailByRestoreToken(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        ::BoxLogic::LastCdpDetail __ret;
        try
        {
            __ret = __proxy->end_queryLastCdpDetailByRestoreToken(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Logic_queryLastCdpDetailByRestoreTokenPtr
newCallback_Logic_queryLastCdpDetailByRestoreToken(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::BoxLogic::LastCdpDetail&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_queryLastCdpDetailByRestoreToken<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_queryLastCdpDetailByRestoreTokenPtr
newCallback_Logic_queryLastCdpDetailByRestoreToken(T* instance, void (T::*cb)(const ::BoxLogic::LastCdpDetail&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_queryLastCdpDetailByRestoreToken<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Logic_queryLastCdpDetailByRestoreToken : public Callback_Logic_queryLastCdpDetailByRestoreToken_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::BoxLogic::LastCdpDetail&, const CT&);

    Callback_Logic_queryLastCdpDetailByRestoreToken(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        ::BoxLogic::LastCdpDetail __ret;
        try
        {
            __ret = __proxy->end_queryLastCdpDetailByRestoreToken(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Logic_queryLastCdpDetailByRestoreTokenPtr
newCallback_Logic_queryLastCdpDetailByRestoreToken(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::BoxLogic::LastCdpDetail&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_queryLastCdpDetailByRestoreToken<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_queryLastCdpDetailByRestoreTokenPtr
newCallback_Logic_queryLastCdpDetailByRestoreToken(T* instance, void (T::*cb)(const ::BoxLogic::LastCdpDetail&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_queryLastCdpDetailByRestoreToken<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Logic_queryLastCdpDetailByCdpToken : public Callback_Logic_queryLastCdpDetailByCdpToken_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const ::BoxLogic::LastCdpDetail&);

    CallbackNC_Logic_queryLastCdpDetailByCdpToken(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        ::BoxLogic::LastCdpDetail detail;
        bool __ret;
        try
        {
            __ret = __proxy->end_queryLastCdpDetailByCdpToken(detail, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, detail);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Logic_queryLastCdpDetailByCdpTokenPtr
newCallback_Logic_queryLastCdpDetailByCdpToken(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const ::BoxLogic::LastCdpDetail&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_queryLastCdpDetailByCdpToken<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_queryLastCdpDetailByCdpTokenPtr
newCallback_Logic_queryLastCdpDetailByCdpToken(T* instance, void (T::*cb)(bool, const ::BoxLogic::LastCdpDetail&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_queryLastCdpDetailByCdpToken<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Logic_queryLastCdpDetailByCdpToken : public Callback_Logic_queryLastCdpDetailByCdpToken_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const ::BoxLogic::LastCdpDetail&, const CT&);

    Callback_Logic_queryLastCdpDetailByCdpToken(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        ::BoxLogic::LastCdpDetail detail;
        bool __ret;
        try
        {
            __ret = __proxy->end_queryLastCdpDetailByCdpToken(detail, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, detail, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Logic_queryLastCdpDetailByCdpTokenPtr
newCallback_Logic_queryLastCdpDetailByCdpToken(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const ::BoxLogic::LastCdpDetail&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_queryLastCdpDetailByCdpToken<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_queryLastCdpDetailByCdpTokenPtr
newCallback_Logic_queryLastCdpDetailByCdpToken(T* instance, void (T::*cb)(bool, const ::BoxLogic::LastCdpDetail&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_queryLastCdpDetailByCdpToken<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Logic_queryNetworkTransmissionType : public Callback_Logic_queryNetworkTransmissionType_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_Logic_queryNetworkTransmissionType(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_queryNetworkTransmissionType(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Logic_queryNetworkTransmissionTypePtr
newCallback_Logic_queryNetworkTransmissionType(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_queryNetworkTransmissionType<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_queryNetworkTransmissionTypePtr
newCallback_Logic_queryNetworkTransmissionType(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_queryNetworkTransmissionType<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Logic_queryNetworkTransmissionType : public Callback_Logic_queryNetworkTransmissionType_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_Logic_queryNetworkTransmissionType(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_queryNetworkTransmissionType(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Logic_queryNetworkTransmissionTypePtr
newCallback_Logic_queryNetworkTransmissionType(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_queryNetworkTransmissionType<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_queryNetworkTransmissionTypePtr
newCallback_Logic_queryNetworkTransmissionType(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_queryNetworkTransmissionType<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Logic_dataQueuingReport : public Callback_Logic_dataQueuingReport_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_Logic_dataQueuingReport(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_dataQueuingReport(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Logic_dataQueuingReportPtr
newCallback_Logic_dataQueuingReport(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_dataQueuingReport<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_dataQueuingReportPtr
newCallback_Logic_dataQueuingReport(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_dataQueuingReport<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Logic_dataQueuingReport : public Callback_Logic_dataQueuingReport_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_Logic_dataQueuingReport(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_dataQueuingReport(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Logic_dataQueuingReportPtr
newCallback_Logic_dataQueuingReport(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_dataQueuingReport<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_dataQueuingReportPtr
newCallback_Logic_dataQueuingReport(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_dataQueuingReport<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Logic_getHashFilePathByRestoreToken : public Callback_Logic_getHashFilePathByRestoreToken_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_Logic_getHashFilePathByRestoreToken(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getHashFilePathByRestoreToken(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Logic_getHashFilePathByRestoreTokenPtr
newCallback_Logic_getHashFilePathByRestoreToken(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_getHashFilePathByRestoreToken<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_getHashFilePathByRestoreTokenPtr
newCallback_Logic_getHashFilePathByRestoreToken(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_getHashFilePathByRestoreToken<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_Logic_getHashFilePathByRestoreToken : public Callback_Logic_getHashFilePathByRestoreToken_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_Logic_getHashFilePathByRestoreToken(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getHashFilePathByRestoreToken(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Logic_getHashFilePathByRestoreTokenPtr
newCallback_Logic_getHashFilePathByRestoreToken(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_getHashFilePathByRestoreToken<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_getHashFilePathByRestoreTokenPtr
newCallback_Logic_getHashFilePathByRestoreToken(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_getHashFilePathByRestoreToken<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Logic_VmwareAgentReport : public Callback_Logic_VmwareAgentReport_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Logic_VmwareAgentReport(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_VmwareAgentReport(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Logic_VmwareAgentReportPtr
newCallback_Logic_VmwareAgentReport(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_VmwareAgentReport<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_VmwareAgentReportPtr
newCallback_Logic_VmwareAgentReport(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_VmwareAgentReport<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Logic_VmwareAgentReportPtr
newCallback_Logic_VmwareAgentReport(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_VmwareAgentReport<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Logic_VmwareAgentReportPtr
newCallback_Logic_VmwareAgentReport(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Logic_VmwareAgentReport<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Logic_VmwareAgentReport : public Callback_Logic_VmwareAgentReport_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Logic_VmwareAgentReport(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicPrx __proxy = ::BoxLogic::LogicPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_VmwareAgentReport(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Logic_VmwareAgentReportPtr
newCallback_Logic_VmwareAgentReport(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_VmwareAgentReport<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_VmwareAgentReportPtr
newCallback_Logic_VmwareAgentReport(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_VmwareAgentReport<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_VmwareAgentReportPtr
newCallback_Logic_VmwareAgentReport(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_VmwareAgentReport<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Logic_VmwareAgentReportPtr
newCallback_Logic_VmwareAgentReport(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Logic_VmwareAgentReport<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_pathJoin : public Callback_LogicInternal_pathJoin_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_LogicInternal_pathJoin(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_pathJoin(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_pathJoinPtr
newCallback_LogicInternal_pathJoin(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_pathJoin<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_pathJoinPtr
newCallback_LogicInternal_pathJoin(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_pathJoin<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_pathJoin : public Callback_LogicInternal_pathJoin_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_LogicInternal_pathJoin(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_pathJoin(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_pathJoinPtr
newCallback_LogicInternal_pathJoin(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_pathJoin<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_pathJoinPtr
newCallback_LogicInternal_pathJoin(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_pathJoin<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_isFileExist : public Callback_LogicInternal_isFileExist_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_LogicInternal_isFileExist(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_isFileExist(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_isFileExistPtr
newCallback_LogicInternal_isFileExist(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_isFileExist<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_isFileExistPtr
newCallback_LogicInternal_isFileExist(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_isFileExist<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_isFileExist : public Callback_LogicInternal_isFileExist_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_LogicInternal_isFileExist(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_isFileExist(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_isFileExistPtr
newCallback_LogicInternal_isFileExist(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_isFileExist<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_isFileExistPtr
newCallback_LogicInternal_isFileExist(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_isFileExist<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_AllFilesExist : public Callback_LogicInternal_AllFilesExist_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_LogicInternal_AllFilesExist(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_AllFilesExist(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_AllFilesExistPtr
newCallback_LogicInternal_AllFilesExist(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_AllFilesExist<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_AllFilesExistPtr
newCallback_LogicInternal_AllFilesExist(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_AllFilesExist<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_AllFilesExist : public Callback_LogicInternal_AllFilesExist_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_LogicInternal_AllFilesExist(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_AllFilesExist(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_AllFilesExistPtr
newCallback_LogicInternal_AllFilesExist(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_AllFilesExist<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_AllFilesExistPtr
newCallback_LogicInternal_AllFilesExist(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_AllFilesExist<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_isFolderExist : public Callback_LogicInternal_isFolderExist_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_LogicInternal_isFolderExist(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_isFolderExist(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_isFolderExistPtr
newCallback_LogicInternal_isFolderExist(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_isFolderExist<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_isFolderExistPtr
newCallback_LogicInternal_isFolderExist(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_isFolderExist<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_isFolderExist : public Callback_LogicInternal_isFolderExist_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_LogicInternal_isFolderExist(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_isFolderExist(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_isFolderExistPtr
newCallback_LogicInternal_isFolderExist(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_isFolderExist<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_isFolderExistPtr
newCallback_LogicInternal_isFolderExist(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_isFolderExist<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_makeDirs : public Callback_LogicInternal_makeDirs_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicInternal_makeDirs(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_LogicInternal_makeDirsPtr
newCallback_LogicInternal_makeDirs(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_makeDirs<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_makeDirsPtr
newCallback_LogicInternal_makeDirs(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_makeDirs<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicInternal_makeDirsPtr
newCallback_LogicInternal_makeDirs(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_makeDirs<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_makeDirsPtr
newCallback_LogicInternal_makeDirs(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_makeDirs<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_makeDirs : public Callback_LogicInternal_makeDirs_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicInternal_makeDirs(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_LogicInternal_makeDirsPtr
newCallback_LogicInternal_makeDirs(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_makeDirs<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_makeDirsPtr
newCallback_LogicInternal_makeDirs(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_makeDirs<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_makeDirsPtr
newCallback_LogicInternal_makeDirs(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_makeDirs<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_makeDirsPtr
newCallback_LogicInternal_makeDirs(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_makeDirs<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_remove : public Callback_LogicInternal_remove_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicInternal_remove(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_LogicInternal_removePtr
newCallback_LogicInternal_remove(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_remove<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_removePtr
newCallback_LogicInternal_remove(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_remove<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicInternal_removePtr
newCallback_LogicInternal_remove(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_remove<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_removePtr
newCallback_LogicInternal_remove(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_remove<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_remove : public Callback_LogicInternal_remove_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicInternal_remove(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_LogicInternal_removePtr
newCallback_LogicInternal_remove(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_remove<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_removePtr
newCallback_LogicInternal_remove(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_remove<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_removePtr
newCallback_LogicInternal_remove(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_remove<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_removePtr
newCallback_LogicInternal_remove(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_remove<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_copy : public Callback_LogicInternal_copy_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicInternal_copy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_copy(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_copyPtr
newCallback_LogicInternal_copy(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_copy<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_copyPtr
newCallback_LogicInternal_copy(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_copy<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicInternal_copyPtr
newCallback_LogicInternal_copy(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_copy<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_copyPtr
newCallback_LogicInternal_copy(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_copy<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_copy : public Callback_LogicInternal_copy_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicInternal_copy(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_copy(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_copyPtr
newCallback_LogicInternal_copy(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_copy<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_copyPtr
newCallback_LogicInternal_copy(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_copy<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_copyPtr
newCallback_LogicInternal_copy(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_copy<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_copyPtr
newCallback_LogicInternal_copy(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_copy<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_findFiles : public Callback_LogicInternal_findFiles_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::BoxLogic::Paths&);

    CallbackNC_LogicInternal_findFiles(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::BoxLogic::Paths paths;
        try
        {
            __proxy->end_findFiles(paths, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(paths);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_findFilesPtr
newCallback_LogicInternal_findFiles(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::BoxLogic::Paths&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_findFiles<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_findFilesPtr
newCallback_LogicInternal_findFiles(T* instance, void (T::*cb)(const ::BoxLogic::Paths&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_findFiles<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_findFiles : public Callback_LogicInternal_findFiles_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::BoxLogic::Paths&, const CT&);

    Callback_LogicInternal_findFiles(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::BoxLogic::Paths paths;
        try
        {
            __proxy->end_findFiles(paths, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(paths, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_findFilesPtr
newCallback_LogicInternal_findFiles(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::BoxLogic::Paths&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_findFiles<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_findFilesPtr
newCallback_LogicInternal_findFiles(T* instance, void (T::*cb)(const ::BoxLogic::Paths&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_findFiles<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_queryCdpTimestampRange : public Callback_LogicInternal_queryCdpTimestampRange_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_LogicInternal_queryCdpTimestampRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_queryCdpTimestampRange(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_queryCdpTimestampRangePtr
newCallback_LogicInternal_queryCdpTimestampRange(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_queryCdpTimestampRange<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_queryCdpTimestampRangePtr
newCallback_LogicInternal_queryCdpTimestampRange(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_queryCdpTimestampRange<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_queryCdpTimestampRange : public Callback_LogicInternal_queryCdpTimestampRange_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_LogicInternal_queryCdpTimestampRange(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_queryCdpTimestampRange(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_queryCdpTimestampRangePtr
newCallback_LogicInternal_queryCdpTimestampRange(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_queryCdpTimestampRange<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_queryCdpTimestampRangePtr
newCallback_LogicInternal_queryCdpTimestampRange(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_queryCdpTimestampRange<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_queryCdpTimestamp : public Callback_LogicInternal_queryCdpTimestamp_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_LogicInternal_queryCdpTimestamp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_queryCdpTimestamp(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_queryCdpTimestampPtr
newCallback_LogicInternal_queryCdpTimestamp(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_queryCdpTimestamp<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_queryCdpTimestampPtr
newCallback_LogicInternal_queryCdpTimestamp(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_queryCdpTimestamp<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_queryCdpTimestamp : public Callback_LogicInternal_queryCdpTimestamp_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_LogicInternal_queryCdpTimestamp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_queryCdpTimestamp(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_queryCdpTimestampPtr
newCallback_LogicInternal_queryCdpTimestamp(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_queryCdpTimestamp<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_queryCdpTimestampPtr
newCallback_LogicInternal_queryCdpTimestamp(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_queryCdpTimestamp<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_formatCdpTimestamp : public Callback_LogicInternal_formatCdpTimestamp_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_LogicInternal_formatCdpTimestamp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_formatCdpTimestamp(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_formatCdpTimestampPtr
newCallback_LogicInternal_formatCdpTimestamp(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_formatCdpTimestamp<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_formatCdpTimestampPtr
newCallback_LogicInternal_formatCdpTimestamp(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_formatCdpTimestamp<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_formatCdpTimestamp : public Callback_LogicInternal_formatCdpTimestamp_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_LogicInternal_formatCdpTimestamp(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_formatCdpTimestamp(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_formatCdpTimestampPtr
newCallback_LogicInternal_formatCdpTimestamp(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_formatCdpTimestamp<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_formatCdpTimestampPtr
newCallback_LogicInternal_formatCdpTimestamp(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_formatCdpTimestamp<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_mergeCdpFile : public Callback_LogicInternal_mergeCdpFile_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicInternal_mergeCdpFile(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_mergeCdpFile(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_mergeCdpFilePtr
newCallback_LogicInternal_mergeCdpFile(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_mergeCdpFile<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_mergeCdpFilePtr
newCallback_LogicInternal_mergeCdpFile(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_mergeCdpFile<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicInternal_mergeCdpFilePtr
newCallback_LogicInternal_mergeCdpFile(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_mergeCdpFile<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_mergeCdpFilePtr
newCallback_LogicInternal_mergeCdpFile(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_mergeCdpFile<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_mergeCdpFile : public Callback_LogicInternal_mergeCdpFile_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicInternal_mergeCdpFile(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_mergeCdpFile(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_mergeCdpFilePtr
newCallback_LogicInternal_mergeCdpFile(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_mergeCdpFile<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_mergeCdpFilePtr
newCallback_LogicInternal_mergeCdpFile(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_mergeCdpFile<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_mergeCdpFilePtr
newCallback_LogicInternal_mergeCdpFile(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_mergeCdpFile<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_mergeCdpFilePtr
newCallback_LogicInternal_mergeCdpFile(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_mergeCdpFile<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_isHardwareDriverExist : public Callback_LogicInternal_isHardwareDriverExist_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_LogicInternal_isHardwareDriverExist(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_isHardwareDriverExist(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_isHardwareDriverExistPtr
newCallback_LogicInternal_isHardwareDriverExist(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_isHardwareDriverExist<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_isHardwareDriverExistPtr
newCallback_LogicInternal_isHardwareDriverExist(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_isHardwareDriverExist<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_isHardwareDriverExist : public Callback_LogicInternal_isHardwareDriverExist_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_LogicInternal_isHardwareDriverExist(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_isHardwareDriverExist(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_isHardwareDriverExistPtr
newCallback_LogicInternal_isHardwareDriverExist(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_isHardwareDriverExist<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_isHardwareDriverExistPtr
newCallback_LogicInternal_isHardwareDriverExist(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_isHardwareDriverExist<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_GetDriversVersions : public Callback_LogicInternal_GetDriversVersions_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_LogicInternal_GetDriversVersions(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_GetDriversVersions(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_GetDriversVersionsPtr
newCallback_LogicInternal_GetDriversVersions(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_GetDriversVersions<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_GetDriversVersionsPtr
newCallback_LogicInternal_GetDriversVersions(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_GetDriversVersions<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_GetDriversVersions : public Callback_LogicInternal_GetDriversVersions_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_LogicInternal_GetDriversVersions(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_GetDriversVersions(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_GetDriversVersionsPtr
newCallback_LogicInternal_GetDriversVersions(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_GetDriversVersions<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_GetDriversVersionsPtr
newCallback_LogicInternal_GetDriversVersions(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_GetDriversVersions<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_ChkIsSubId : public Callback_LogicInternal_ChkIsSubId_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_LogicInternal_ChkIsSubId(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_ChkIsSubId(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_ChkIsSubIdPtr
newCallback_LogicInternal_ChkIsSubId(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_ChkIsSubId<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_ChkIsSubIdPtr
newCallback_LogicInternal_ChkIsSubId(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_ChkIsSubId<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_ChkIsSubId : public Callback_LogicInternal_ChkIsSubId_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_LogicInternal_ChkIsSubId(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_ChkIsSubId(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_ChkIsSubIdPtr
newCallback_LogicInternal_ChkIsSubId(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_ChkIsSubId<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_ChkIsSubIdPtr
newCallback_LogicInternal_ChkIsSubId(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_ChkIsSubId<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_GetDriversSubList : public Callback_LogicInternal_GetDriversSubList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_LogicInternal_GetDriversSubList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_GetDriversSubList(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_GetDriversSubListPtr
newCallback_LogicInternal_GetDriversSubList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_GetDriversSubList<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_GetDriversSubListPtr
newCallback_LogicInternal_GetDriversSubList(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_GetDriversSubList<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_GetDriversSubList : public Callback_LogicInternal_GetDriversSubList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_LogicInternal_GetDriversSubList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_GetDriversSubList(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_GetDriversSubListPtr
newCallback_LogicInternal_GetDriversSubList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_GetDriversSubList<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_GetDriversSubListPtr
newCallback_LogicInternal_GetDriversSubList(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_GetDriversSubList<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_generatePeStageIso : public Callback_LogicInternal_generatePeStageIso_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicInternal_generatePeStageIso(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_generatePeStageIso(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_generatePeStageIsoPtr
newCallback_LogicInternal_generatePeStageIso(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_generatePeStageIso<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_generatePeStageIsoPtr
newCallback_LogicInternal_generatePeStageIso(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_generatePeStageIso<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicInternal_generatePeStageIsoPtr
newCallback_LogicInternal_generatePeStageIso(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_generatePeStageIso<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_generatePeStageIsoPtr
newCallback_LogicInternal_generatePeStageIso(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_generatePeStageIso<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_generatePeStageIso : public Callback_LogicInternal_generatePeStageIso_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicInternal_generatePeStageIso(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_generatePeStageIso(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_generatePeStageIsoPtr
newCallback_LogicInternal_generatePeStageIso(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_generatePeStageIso<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_generatePeStageIsoPtr
newCallback_LogicInternal_generatePeStageIso(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_generatePeStageIso<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_generatePeStageIsoPtr
newCallback_LogicInternal_generatePeStageIso(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_generatePeStageIso<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_generatePeStageIsoPtr
newCallback_LogicInternal_generatePeStageIso(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_generatePeStageIso<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_runRestoreKvm : public Callback_LogicInternal_runRestoreKvm_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_LogicInternal_runRestoreKvm(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_runRestoreKvm(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_runRestoreKvmPtr
newCallback_LogicInternal_runRestoreKvm(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_runRestoreKvm<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_runRestoreKvmPtr
newCallback_LogicInternal_runRestoreKvm(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_runRestoreKvm<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_runRestoreKvm : public Callback_LogicInternal_runRestoreKvm_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_LogicInternal_runRestoreKvm(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_runRestoreKvm(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_runRestoreKvmPtr
newCallback_LogicInternal_runRestoreKvm(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_runRestoreKvm<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_runRestoreKvmPtr
newCallback_LogicInternal_runRestoreKvm(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_runRestoreKvm<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_getCurrentNetworkInfos : public Callback_LogicInternal_getCurrentNetworkInfos_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_LogicInternal_getCurrentNetworkInfos(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getCurrentNetworkInfos(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_getCurrentNetworkInfosPtr
newCallback_LogicInternal_getCurrentNetworkInfos(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_getCurrentNetworkInfos<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_getCurrentNetworkInfosPtr
newCallback_LogicInternal_getCurrentNetworkInfos(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_getCurrentNetworkInfos<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_getCurrentNetworkInfos : public Callback_LogicInternal_getCurrentNetworkInfos_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_LogicInternal_getCurrentNetworkInfos(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getCurrentNetworkInfos(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_getCurrentNetworkInfosPtr
newCallback_LogicInternal_getCurrentNetworkInfos(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_getCurrentNetworkInfos<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_getCurrentNetworkInfosPtr
newCallback_LogicInternal_getCurrentNetworkInfos(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_getCurrentNetworkInfos<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_setNetwork : public Callback_LogicInternal_setNetwork_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicInternal_setNetwork(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setNetwork(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_setNetworkPtr
newCallback_LogicInternal_setNetwork(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_setNetwork<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_setNetworkPtr
newCallback_LogicInternal_setNetwork(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_setNetwork<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicInternal_setNetworkPtr
newCallback_LogicInternal_setNetwork(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_setNetwork<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_setNetworkPtr
newCallback_LogicInternal_setNetwork(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_setNetwork<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_setNetwork : public Callback_LogicInternal_setNetwork_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicInternal_setNetwork(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setNetwork(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_setNetworkPtr
newCallback_LogicInternal_setNetwork(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_setNetwork<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_setNetworkPtr
newCallback_LogicInternal_setNetwork(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_setNetwork<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_setNetworkPtr
newCallback_LogicInternal_setNetwork(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_setNetwork<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_setNetworkPtr
newCallback_LogicInternal_setNetwork(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_setNetwork<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_enumStorageNodes : public Callback_LogicInternal_enumStorageNodes_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_LogicInternal_enumStorageNodes(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_enumStorageNodes(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_enumStorageNodesPtr
newCallback_LogicInternal_enumStorageNodes(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_enumStorageNodes<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_enumStorageNodesPtr
newCallback_LogicInternal_enumStorageNodes(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_enumStorageNodes<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_enumStorageNodes : public Callback_LogicInternal_enumStorageNodes_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_LogicInternal_enumStorageNodes(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_enumStorageNodes(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_enumStorageNodesPtr
newCallback_LogicInternal_enumStorageNodes(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_enumStorageNodes<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_enumStorageNodesPtr
newCallback_LogicInternal_enumStorageNodes(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_enumStorageNodes<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_getLocalIqn : public Callback_LogicInternal_getLocalIqn_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_LogicInternal_getLocalIqn(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getLocalIqn(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_getLocalIqnPtr
newCallback_LogicInternal_getLocalIqn(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_getLocalIqn<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_getLocalIqnPtr
newCallback_LogicInternal_getLocalIqn(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_getLocalIqn<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_getLocalIqn : public Callback_LogicInternal_getLocalIqn_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_LogicInternal_getLocalIqn(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getLocalIqn(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_getLocalIqnPtr
newCallback_LogicInternal_getLocalIqn(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_getLocalIqn<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_getLocalIqnPtr
newCallback_LogicInternal_getLocalIqn(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_getLocalIqn<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_setLocalIqn : public Callback_LogicInternal_setLocalIqn_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicInternal_setLocalIqn(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setLocalIqn(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_setLocalIqnPtr
newCallback_LogicInternal_setLocalIqn(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_setLocalIqn<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_setLocalIqnPtr
newCallback_LogicInternal_setLocalIqn(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_setLocalIqn<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicInternal_setLocalIqnPtr
newCallback_LogicInternal_setLocalIqn(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_setLocalIqn<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_setLocalIqnPtr
newCallback_LogicInternal_setLocalIqn(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_setLocalIqn<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_setLocalIqn : public Callback_LogicInternal_setLocalIqn_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicInternal_setLocalIqn(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setLocalIqn(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_setLocalIqnPtr
newCallback_LogicInternal_setLocalIqn(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_setLocalIqn<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_setLocalIqnPtr
newCallback_LogicInternal_setLocalIqn(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_setLocalIqn<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_setLocalIqnPtr
newCallback_LogicInternal_setLocalIqn(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_setLocalIqn<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_setLocalIqnPtr
newCallback_LogicInternal_setLocalIqn(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_setLocalIqn<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_setGlobalDoubleChap : public Callback_LogicInternal_setGlobalDoubleChap_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicInternal_setGlobalDoubleChap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setGlobalDoubleChap(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_setGlobalDoubleChapPtr
newCallback_LogicInternal_setGlobalDoubleChap(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_setGlobalDoubleChap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_setGlobalDoubleChapPtr
newCallback_LogicInternal_setGlobalDoubleChap(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_setGlobalDoubleChap<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicInternal_setGlobalDoubleChapPtr
newCallback_LogicInternal_setGlobalDoubleChap(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_setGlobalDoubleChap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_setGlobalDoubleChapPtr
newCallback_LogicInternal_setGlobalDoubleChap(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_setGlobalDoubleChap<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_setGlobalDoubleChap : public Callback_LogicInternal_setGlobalDoubleChap_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicInternal_setGlobalDoubleChap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setGlobalDoubleChap(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_setGlobalDoubleChapPtr
newCallback_LogicInternal_setGlobalDoubleChap(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_setGlobalDoubleChap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_setGlobalDoubleChapPtr
newCallback_LogicInternal_setGlobalDoubleChap(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_setGlobalDoubleChap<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_setGlobalDoubleChapPtr
newCallback_LogicInternal_setGlobalDoubleChap(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_setGlobalDoubleChap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_setGlobalDoubleChapPtr
newCallback_LogicInternal_setGlobalDoubleChap(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_setGlobalDoubleChap<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_getGlobalDoubleChap : public Callback_LogicInternal_getGlobalDoubleChap_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const ::std::string&, const ::std::string&);

    CallbackNC_LogicInternal_getGlobalDoubleChap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string userName;
        ::std::string password;
        bool __ret;
        try
        {
            __ret = __proxy->end_getGlobalDoubleChap(userName, password, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, userName, password);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_getGlobalDoubleChapPtr
newCallback_LogicInternal_getGlobalDoubleChap(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const ::std::string&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_getGlobalDoubleChap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_getGlobalDoubleChapPtr
newCallback_LogicInternal_getGlobalDoubleChap(T* instance, void (T::*cb)(bool, const ::std::string&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_getGlobalDoubleChap<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_getGlobalDoubleChap : public Callback_LogicInternal_getGlobalDoubleChap_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const ::std::string&, const ::std::string&, const CT&);

    Callback_LogicInternal_getGlobalDoubleChap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string userName;
        ::std::string password;
        bool __ret;
        try
        {
            __ret = __proxy->end_getGlobalDoubleChap(userName, password, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, userName, password, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_getGlobalDoubleChapPtr
newCallback_LogicInternal_getGlobalDoubleChap(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const ::std::string&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_getGlobalDoubleChap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_getGlobalDoubleChapPtr
newCallback_LogicInternal_getGlobalDoubleChap(T* instance, void (T::*cb)(bool, const ::std::string&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_getGlobalDoubleChap<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_loginExternalDevice : public Callback_LogicInternal_loginExternalDevice_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_LogicInternal_loginExternalDevice(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_loginExternalDevice(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_loginExternalDevicePtr
newCallback_LogicInternal_loginExternalDevice(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_loginExternalDevice<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_loginExternalDevicePtr
newCallback_LogicInternal_loginExternalDevice(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_loginExternalDevice<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_loginExternalDevice : public Callback_LogicInternal_loginExternalDevice_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_LogicInternal_loginExternalDevice(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_loginExternalDevice(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_loginExternalDevicePtr
newCallback_LogicInternal_loginExternalDevice(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_loginExternalDevice<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_loginExternalDevicePtr
newCallback_LogicInternal_loginExternalDevice(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_loginExternalDevice<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_logoutExternalDevice : public Callback_LogicInternal_logoutExternalDevice_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicInternal_logoutExternalDevice(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_logoutExternalDevice(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_logoutExternalDevicePtr
newCallback_LogicInternal_logoutExternalDevice(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_logoutExternalDevice<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_logoutExternalDevicePtr
newCallback_LogicInternal_logoutExternalDevice(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_logoutExternalDevice<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicInternal_logoutExternalDevicePtr
newCallback_LogicInternal_logoutExternalDevice(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_logoutExternalDevice<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_logoutExternalDevicePtr
newCallback_LogicInternal_logoutExternalDevice(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_logoutExternalDevice<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_logoutExternalDevice : public Callback_LogicInternal_logoutExternalDevice_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicInternal_logoutExternalDevice(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_logoutExternalDevice(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_logoutExternalDevicePtr
newCallback_LogicInternal_logoutExternalDevice(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_logoutExternalDevice<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_logoutExternalDevicePtr
newCallback_LogicInternal_logoutExternalDevice(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_logoutExternalDevice<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_logoutExternalDevicePtr
newCallback_LogicInternal_logoutExternalDevice(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_logoutExternalDevice<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_logoutExternalDevicePtr
newCallback_LogicInternal_logoutExternalDevice(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_logoutExternalDevice<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_refreshExternalDevice : public Callback_LogicInternal_refreshExternalDevice_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicInternal_refreshExternalDevice(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_refreshExternalDevice(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_refreshExternalDevicePtr
newCallback_LogicInternal_refreshExternalDevice(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_refreshExternalDevice<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_refreshExternalDevicePtr
newCallback_LogicInternal_refreshExternalDevice(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_refreshExternalDevice<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicInternal_refreshExternalDevicePtr
newCallback_LogicInternal_refreshExternalDevice(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_refreshExternalDevice<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_refreshExternalDevicePtr
newCallback_LogicInternal_refreshExternalDevice(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_refreshExternalDevice<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_refreshExternalDevice : public Callback_LogicInternal_refreshExternalDevice_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicInternal_refreshExternalDevice(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_refreshExternalDevice(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_refreshExternalDevicePtr
newCallback_LogicInternal_refreshExternalDevice(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_refreshExternalDevice<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_refreshExternalDevicePtr
newCallback_LogicInternal_refreshExternalDevice(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_refreshExternalDevice<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_refreshExternalDevicePtr
newCallback_LogicInternal_refreshExternalDevice(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_refreshExternalDevice<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_refreshExternalDevicePtr
newCallback_LogicInternal_refreshExternalDevice(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_refreshExternalDevice<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_formatAndInitializeStorageNode : public Callback_LogicInternal_formatAndInitializeStorageNode_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicInternal_formatAndInitializeStorageNode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_formatAndInitializeStorageNode(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_formatAndInitializeStorageNodePtr
newCallback_LogicInternal_formatAndInitializeStorageNode(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_formatAndInitializeStorageNode<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_formatAndInitializeStorageNodePtr
newCallback_LogicInternal_formatAndInitializeStorageNode(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_formatAndInitializeStorageNode<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicInternal_formatAndInitializeStorageNodePtr
newCallback_LogicInternal_formatAndInitializeStorageNode(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_formatAndInitializeStorageNode<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_formatAndInitializeStorageNodePtr
newCallback_LogicInternal_formatAndInitializeStorageNode(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_formatAndInitializeStorageNode<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_formatAndInitializeStorageNode : public Callback_LogicInternal_formatAndInitializeStorageNode_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicInternal_formatAndInitializeStorageNode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_formatAndInitializeStorageNode(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_formatAndInitializeStorageNodePtr
newCallback_LogicInternal_formatAndInitializeStorageNode(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_formatAndInitializeStorageNode<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_formatAndInitializeStorageNodePtr
newCallback_LogicInternal_formatAndInitializeStorageNode(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_formatAndInitializeStorageNode<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_formatAndInitializeStorageNodePtr
newCallback_LogicInternal_formatAndInitializeStorageNode(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_formatAndInitializeStorageNode<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_formatAndInitializeStorageNodePtr
newCallback_LogicInternal_formatAndInitializeStorageNode(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_formatAndInitializeStorageNode<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_mountStorageNode : public Callback_LogicInternal_mountStorageNode_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicInternal_mountStorageNode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_mountStorageNode(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_mountStorageNodePtr
newCallback_LogicInternal_mountStorageNode(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_mountStorageNode<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_mountStorageNodePtr
newCallback_LogicInternal_mountStorageNode(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_mountStorageNode<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicInternal_mountStorageNodePtr
newCallback_LogicInternal_mountStorageNode(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_mountStorageNode<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_mountStorageNodePtr
newCallback_LogicInternal_mountStorageNode(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_mountStorageNode<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_mountStorageNode : public Callback_LogicInternal_mountStorageNode_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicInternal_mountStorageNode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_mountStorageNode(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_mountStorageNodePtr
newCallback_LogicInternal_mountStorageNode(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_mountStorageNode<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_mountStorageNodePtr
newCallback_LogicInternal_mountStorageNode(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_mountStorageNode<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_mountStorageNodePtr
newCallback_LogicInternal_mountStorageNode(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_mountStorageNode<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_mountStorageNodePtr
newCallback_LogicInternal_mountStorageNode(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_mountStorageNode<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_unmountStorageNode : public Callback_LogicInternal_unmountStorageNode_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicInternal_unmountStorageNode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_unmountStorageNode(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_unmountStorageNodePtr
newCallback_LogicInternal_unmountStorageNode(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_unmountStorageNode<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_unmountStorageNodePtr
newCallback_LogicInternal_unmountStorageNode(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_unmountStorageNode<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicInternal_unmountStorageNodePtr
newCallback_LogicInternal_unmountStorageNode(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_unmountStorageNode<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_unmountStorageNodePtr
newCallback_LogicInternal_unmountStorageNode(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_unmountStorageNode<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_unmountStorageNode : public Callback_LogicInternal_unmountStorageNode_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicInternal_unmountStorageNode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_unmountStorageNode(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_unmountStorageNodePtr
newCallback_LogicInternal_unmountStorageNode(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_unmountStorageNode<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_unmountStorageNodePtr
newCallback_LogicInternal_unmountStorageNode(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_unmountStorageNode<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_unmountStorageNodePtr
newCallback_LogicInternal_unmountStorageNode(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_unmountStorageNode<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_unmountStorageNodePtr
newCallback_LogicInternal_unmountStorageNode(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_unmountStorageNode<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_runCmd : public Callback_LogicInternal_runCmd_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, const ::BoxLogic::StringList&);

    CallbackNC_LogicInternal_runCmd(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::BoxLogic::StringList lines;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_runCmd(lines, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, lines);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_runCmdPtr
newCallback_LogicInternal_runCmd(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::BoxLogic::StringList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_runCmd<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_runCmdPtr
newCallback_LogicInternal_runCmd(T* instance, void (T::*cb)(::Ice::Int, const ::BoxLogic::StringList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_runCmd<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_runCmd : public Callback_LogicInternal_runCmd_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const ::BoxLogic::StringList&, const CT&);

    Callback_LogicInternal_runCmd(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::BoxLogic::StringList lines;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_runCmd(lines, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, lines, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_runCmdPtr
newCallback_LogicInternal_runCmd(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::BoxLogic::StringList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_runCmd<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_runCmdPtr
newCallback_LogicInternal_runCmd(T* instance, void (T::*cb)(::Ice::Int, const ::BoxLogic::StringList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_runCmd<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_CmdCtrl : public Callback_LogicInternal_CmdCtrl_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_LogicInternal_CmdCtrl(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_CmdCtrl(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_CmdCtrlPtr
newCallback_LogicInternal_CmdCtrl(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_CmdCtrl<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_CmdCtrlPtr
newCallback_LogicInternal_CmdCtrl(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_CmdCtrl<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_CmdCtrl : public Callback_LogicInternal_CmdCtrl_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_LogicInternal_CmdCtrl(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_CmdCtrl(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_CmdCtrlPtr
newCallback_LogicInternal_CmdCtrl(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_CmdCtrl<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_CmdCtrlPtr
newCallback_LogicInternal_CmdCtrl(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_CmdCtrl<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_setPasswd : public Callback_LogicInternal_setPasswd_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicInternal_setPasswd(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setPasswd(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_setPasswdPtr
newCallback_LogicInternal_setPasswd(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_setPasswd<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_setPasswdPtr
newCallback_LogicInternal_setPasswd(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_setPasswd<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicInternal_setPasswdPtr
newCallback_LogicInternal_setPasswd(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_setPasswd<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_setPasswdPtr
newCallback_LogicInternal_setPasswd(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_setPasswd<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_setPasswd : public Callback_LogicInternal_setPasswd_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicInternal_setPasswd(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_setPasswd(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_setPasswdPtr
newCallback_LogicInternal_setPasswd(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_setPasswd<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_setPasswdPtr
newCallback_LogicInternal_setPasswd(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_setPasswd<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_setPasswdPtr
newCallback_LogicInternal_setPasswd(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_setPasswd<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_setPasswdPtr
newCallback_LogicInternal_setPasswd(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_setPasswd<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_getPasswd : public Callback_LogicInternal_getPasswd_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_LogicInternal_getPasswd(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getPasswd(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_getPasswdPtr
newCallback_LogicInternal_getPasswd(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_getPasswd<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_getPasswdPtr
newCallback_LogicInternal_getPasswd(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_getPasswd<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_getPasswd : public Callback_LogicInternal_getPasswd_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_LogicInternal_getPasswd(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getPasswd(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_getPasswdPtr
newCallback_LogicInternal_getPasswd(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_getPasswd<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_getPasswdPtr
newCallback_LogicInternal_getPasswd(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_getPasswd<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_calcClusterTime0Hash : public Callback_LogicInternal_calcClusterTime0Hash_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicInternal_calcClusterTime0Hash(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_calcClusterTime0Hash(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_calcClusterTime0HashPtr
newCallback_LogicInternal_calcClusterTime0Hash(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_calcClusterTime0Hash<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_calcClusterTime0HashPtr
newCallback_LogicInternal_calcClusterTime0Hash(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_calcClusterTime0Hash<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicInternal_calcClusterTime0HashPtr
newCallback_LogicInternal_calcClusterTime0Hash(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_calcClusterTime0Hash<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_calcClusterTime0HashPtr
newCallback_LogicInternal_calcClusterTime0Hash(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_calcClusterTime0Hash<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_calcClusterTime0Hash : public Callback_LogicInternal_calcClusterTime0Hash_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicInternal_calcClusterTime0Hash(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_calcClusterTime0Hash(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_calcClusterTime0HashPtr
newCallback_LogicInternal_calcClusterTime0Hash(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_calcClusterTime0Hash<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_calcClusterTime0HashPtr
newCallback_LogicInternal_calcClusterTime0Hash(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_calcClusterTime0Hash<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_calcClusterTime0HashPtr
newCallback_LogicInternal_calcClusterTime0Hash(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_calcClusterTime0Hash<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_calcClusterTime0HashPtr
newCallback_LogicInternal_calcClusterTime0Hash(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_calcClusterTime0Hash<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_generateClusterDiffImages : public Callback_LogicInternal_generateClusterDiffImages_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicInternal_generateClusterDiffImages(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_generateClusterDiffImages(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_generateClusterDiffImagesPtr
newCallback_LogicInternal_generateClusterDiffImages(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_generateClusterDiffImages<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_generateClusterDiffImagesPtr
newCallback_LogicInternal_generateClusterDiffImages(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_generateClusterDiffImages<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicInternal_generateClusterDiffImagesPtr
newCallback_LogicInternal_generateClusterDiffImages(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_generateClusterDiffImages<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_generateClusterDiffImagesPtr
newCallback_LogicInternal_generateClusterDiffImages(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_generateClusterDiffImages<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_generateClusterDiffImages : public Callback_LogicInternal_generateClusterDiffImages_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicInternal_generateClusterDiffImages(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_generateClusterDiffImages(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_generateClusterDiffImagesPtr
newCallback_LogicInternal_generateClusterDiffImages(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_generateClusterDiffImages<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_generateClusterDiffImagesPtr
newCallback_LogicInternal_generateClusterDiffImages(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_generateClusterDiffImages<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_generateClusterDiffImagesPtr
newCallback_LogicInternal_generateClusterDiffImages(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_generateClusterDiffImages<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_generateClusterDiffImagesPtr
newCallback_LogicInternal_generateClusterDiffImages(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_generateClusterDiffImages<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_mergeCdpFiles : public Callback_LogicInternal_mergeCdpFiles_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicInternal_mergeCdpFiles(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_mergeCdpFiles(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_mergeCdpFilesPtr
newCallback_LogicInternal_mergeCdpFiles(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_mergeCdpFiles<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_mergeCdpFilesPtr
newCallback_LogicInternal_mergeCdpFiles(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_mergeCdpFiles<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicInternal_mergeCdpFilesPtr
newCallback_LogicInternal_mergeCdpFiles(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_mergeCdpFiles<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_mergeCdpFilesPtr
newCallback_LogicInternal_mergeCdpFiles(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_mergeCdpFiles<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_mergeCdpFiles : public Callback_LogicInternal_mergeCdpFiles_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicInternal_mergeCdpFiles(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_mergeCdpFiles(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_mergeCdpFilesPtr
newCallback_LogicInternal_mergeCdpFiles(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_mergeCdpFiles<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_mergeCdpFilesPtr
newCallback_LogicInternal_mergeCdpFiles(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_mergeCdpFiles<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_mergeCdpFilesPtr
newCallback_LogicInternal_mergeCdpFiles(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_mergeCdpFiles<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_mergeCdpFilesPtr
newCallback_LogicInternal_mergeCdpFiles(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_mergeCdpFiles<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_cutCdpFile : public Callback_LogicInternal_cutCdpFile_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicInternal_cutCdpFile(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_cutCdpFile(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_cutCdpFilePtr
newCallback_LogicInternal_cutCdpFile(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_cutCdpFile<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_cutCdpFilePtr
newCallback_LogicInternal_cutCdpFile(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_cutCdpFile<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicInternal_cutCdpFilePtr
newCallback_LogicInternal_cutCdpFile(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_cutCdpFile<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_cutCdpFilePtr
newCallback_LogicInternal_cutCdpFile(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_cutCdpFile<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_cutCdpFile : public Callback_LogicInternal_cutCdpFile_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicInternal_cutCdpFile(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_cutCdpFile(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_cutCdpFilePtr
newCallback_LogicInternal_cutCdpFile(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_cutCdpFile<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_cutCdpFilePtr
newCallback_LogicInternal_cutCdpFile(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_cutCdpFile<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_cutCdpFilePtr
newCallback_LogicInternal_cutCdpFile(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_cutCdpFile<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_cutCdpFilePtr
newCallback_LogicInternal_cutCdpFile(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_cutCdpFile<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_getRawDiskFiles : public Callback_LogicInternal_getRawDiskFiles_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_LogicInternal_getRawDiskFiles(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getRawDiskFiles(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_getRawDiskFilesPtr
newCallback_LogicInternal_getRawDiskFiles(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_getRawDiskFiles<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_getRawDiskFilesPtr
newCallback_LogicInternal_getRawDiskFiles(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_getRawDiskFiles<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_getRawDiskFiles : public Callback_LogicInternal_getRawDiskFiles_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_LogicInternal_getRawDiskFiles(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_getRawDiskFiles(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_getRawDiskFilesPtr
newCallback_LogicInternal_getRawDiskFiles(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_getRawDiskFiles<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_getRawDiskFilesPtr
newCallback_LogicInternal_getRawDiskFiles(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_getRawDiskFiles<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_NbdFindUnusedReverse : public Callback_LogicInternal_NbdFindUnusedReverse_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_LogicInternal_NbdFindUnusedReverse(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_NbdFindUnusedReverse(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_NbdFindUnusedReversePtr
newCallback_LogicInternal_NbdFindUnusedReverse(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_NbdFindUnusedReverse<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_NbdFindUnusedReversePtr
newCallback_LogicInternal_NbdFindUnusedReverse(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_NbdFindUnusedReverse<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_NbdFindUnusedReverse : public Callback_LogicInternal_NbdFindUnusedReverse_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_LogicInternal_NbdFindUnusedReverse(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_NbdFindUnusedReverse(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_NbdFindUnusedReversePtr
newCallback_LogicInternal_NbdFindUnusedReverse(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_NbdFindUnusedReverse<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_NbdFindUnusedReversePtr
newCallback_LogicInternal_NbdFindUnusedReverse(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_NbdFindUnusedReverse<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_NbdSetUnused : public Callback_LogicInternal_NbdSetUnused_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicInternal_NbdSetUnused(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_NbdSetUnused(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_NbdSetUnusedPtr
newCallback_LogicInternal_NbdSetUnused(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_NbdSetUnused<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_NbdSetUnusedPtr
newCallback_LogicInternal_NbdSetUnused(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_NbdSetUnused<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicInternal_NbdSetUnusedPtr
newCallback_LogicInternal_NbdSetUnused(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_NbdSetUnused<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_NbdSetUnusedPtr
newCallback_LogicInternal_NbdSetUnused(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_NbdSetUnused<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_NbdSetUnused : public Callback_LogicInternal_NbdSetUnused_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicInternal_NbdSetUnused(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_NbdSetUnused(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_NbdSetUnusedPtr
newCallback_LogicInternal_NbdSetUnused(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_NbdSetUnused<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_NbdSetUnusedPtr
newCallback_LogicInternal_NbdSetUnused(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_NbdSetUnused<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_NbdSetUnusedPtr
newCallback_LogicInternal_NbdSetUnused(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_NbdSetUnused<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_NbdSetUnusedPtr
newCallback_LogicInternal_NbdSetUnused(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_NbdSetUnused<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_NbdSetUsed : public Callback_LogicInternal_NbdSetUsed_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicInternal_NbdSetUsed(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_NbdSetUsed(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_NbdSetUsedPtr
newCallback_LogicInternal_NbdSetUsed(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_NbdSetUsed<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_NbdSetUsedPtr
newCallback_LogicInternal_NbdSetUsed(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_NbdSetUsed<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicInternal_NbdSetUsedPtr
newCallback_LogicInternal_NbdSetUsed(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_NbdSetUsed<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_NbdSetUsedPtr
newCallback_LogicInternal_NbdSetUsed(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_NbdSetUsed<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_NbdSetUsed : public Callback_LogicInternal_NbdSetUsed_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicInternal_NbdSetUsed(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_NbdSetUsed(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_NbdSetUsedPtr
newCallback_LogicInternal_NbdSetUsed(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_NbdSetUsed<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_NbdSetUsedPtr
newCallback_LogicInternal_NbdSetUsed(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_NbdSetUsed<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_NbdSetUsedPtr
newCallback_LogicInternal_NbdSetUsed(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_NbdSetUsed<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_NbdSetUsedPtr
newCallback_LogicInternal_NbdSetUsed(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_NbdSetUsed<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_queryTakeOverHostInfo : public Callback_LogicInternal_queryTakeOverHostInfo_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_LogicInternal_queryTakeOverHostInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_queryTakeOverHostInfo(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_queryTakeOverHostInfoPtr
newCallback_LogicInternal_queryTakeOverHostInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_queryTakeOverHostInfo<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_queryTakeOverHostInfoPtr
newCallback_LogicInternal_queryTakeOverHostInfo(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_queryTakeOverHostInfo<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_queryTakeOverHostInfo : public Callback_LogicInternal_queryTakeOverHostInfo_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_LogicInternal_queryTakeOverHostInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_queryTakeOverHostInfo(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_queryTakeOverHostInfoPtr
newCallback_LogicInternal_queryTakeOverHostInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_queryTakeOverHostInfo<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_queryTakeOverHostInfoPtr
newCallback_LogicInternal_queryTakeOverHostInfo(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_queryTakeOverHostInfo<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_mergeQcowFile : public Callback_LogicInternal_mergeQcowFile_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicInternal_mergeQcowFile(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_mergeQcowFile(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_mergeQcowFilePtr
newCallback_LogicInternal_mergeQcowFile(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_mergeQcowFile<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_mergeQcowFilePtr
newCallback_LogicInternal_mergeQcowFile(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_mergeQcowFile<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicInternal_mergeQcowFilePtr
newCallback_LogicInternal_mergeQcowFile(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_mergeQcowFile<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_mergeQcowFilePtr
newCallback_LogicInternal_mergeQcowFile(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_mergeQcowFile<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_mergeQcowFile : public Callback_LogicInternal_mergeQcowFile_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicInternal_mergeQcowFile(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_mergeQcowFile(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_mergeQcowFilePtr
newCallback_LogicInternal_mergeQcowFile(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_mergeQcowFile<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_mergeQcowFilePtr
newCallback_LogicInternal_mergeQcowFile(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_mergeQcowFile<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_mergeQcowFilePtr
newCallback_LogicInternal_mergeQcowFile(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_mergeQcowFile<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_mergeQcowFilePtr
newCallback_LogicInternal_mergeQcowFile(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_mergeQcowFile<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_startBackupOptimize : public Callback_LogicInternal_startBackupOptimize_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_LogicInternal_startBackupOptimize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_startBackupOptimize(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_startBackupOptimizePtr
newCallback_LogicInternal_startBackupOptimize(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_startBackupOptimize<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_startBackupOptimizePtr
newCallback_LogicInternal_startBackupOptimize(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_startBackupOptimize<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_startBackupOptimize : public Callback_LogicInternal_startBackupOptimize_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_LogicInternal_startBackupOptimize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_startBackupOptimize(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_startBackupOptimizePtr
newCallback_LogicInternal_startBackupOptimize(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_startBackupOptimize<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_startBackupOptimizePtr
newCallback_LogicInternal_startBackupOptimize(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_startBackupOptimize<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_stopBackupOptimize : public Callback_LogicInternal_stopBackupOptimize_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicInternal_stopBackupOptimize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_stopBackupOptimize(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_stopBackupOptimizePtr
newCallback_LogicInternal_stopBackupOptimize(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_stopBackupOptimize<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_stopBackupOptimizePtr
newCallback_LogicInternal_stopBackupOptimize(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_stopBackupOptimize<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicInternal_stopBackupOptimizePtr
newCallback_LogicInternal_stopBackupOptimize(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_stopBackupOptimize<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_stopBackupOptimizePtr
newCallback_LogicInternal_stopBackupOptimize(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_stopBackupOptimize<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_stopBackupOptimize : public Callback_LogicInternal_stopBackupOptimize_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicInternal_stopBackupOptimize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_stopBackupOptimize(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_stopBackupOptimizePtr
newCallback_LogicInternal_stopBackupOptimize(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_stopBackupOptimize<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_stopBackupOptimizePtr
newCallback_LogicInternal_stopBackupOptimize(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_stopBackupOptimize<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_stopBackupOptimizePtr
newCallback_LogicInternal_stopBackupOptimize(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_stopBackupOptimize<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_stopBackupOptimizePtr
newCallback_LogicInternal_stopBackupOptimize(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_stopBackupOptimize<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_mergeHashFile : public Callback_LogicInternal_mergeHashFile_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicInternal_mergeHashFile(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_mergeHashFile(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_mergeHashFilePtr
newCallback_LogicInternal_mergeHashFile(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_mergeHashFile<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_mergeHashFilePtr
newCallback_LogicInternal_mergeHashFile(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_mergeHashFile<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicInternal_mergeHashFilePtr
newCallback_LogicInternal_mergeHashFile(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_mergeHashFile<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_mergeHashFilePtr
newCallback_LogicInternal_mergeHashFile(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_mergeHashFile<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_mergeHashFile : public Callback_LogicInternal_mergeHashFile_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicInternal_mergeHashFile(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_mergeHashFile(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_mergeHashFilePtr
newCallback_LogicInternal_mergeHashFile(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_mergeHashFile<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_mergeHashFilePtr
newCallback_LogicInternal_mergeHashFile(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_mergeHashFile<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_mergeHashFilePtr
newCallback_LogicInternal_mergeHashFile(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_mergeHashFile<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_mergeHashFilePtr
newCallback_LogicInternal_mergeHashFile(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_mergeHashFile<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_generateBitMapFromQcowFile : public Callback_LogicInternal_generateBitMapFromQcowFile_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicInternal_generateBitMapFromQcowFile(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_generateBitMapFromQcowFile(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_generateBitMapFromQcowFilePtr
newCallback_LogicInternal_generateBitMapFromQcowFile(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_generateBitMapFromQcowFile<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_generateBitMapFromQcowFilePtr
newCallback_LogicInternal_generateBitMapFromQcowFile(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_generateBitMapFromQcowFile<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicInternal_generateBitMapFromQcowFilePtr
newCallback_LogicInternal_generateBitMapFromQcowFile(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_generateBitMapFromQcowFile<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_generateBitMapFromQcowFilePtr
newCallback_LogicInternal_generateBitMapFromQcowFile(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_generateBitMapFromQcowFile<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_generateBitMapFromQcowFile : public Callback_LogicInternal_generateBitMapFromQcowFile_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicInternal_generateBitMapFromQcowFile(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_generateBitMapFromQcowFile(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_generateBitMapFromQcowFilePtr
newCallback_LogicInternal_generateBitMapFromQcowFile(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_generateBitMapFromQcowFile<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_generateBitMapFromQcowFilePtr
newCallback_LogicInternal_generateBitMapFromQcowFile(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_generateBitMapFromQcowFile<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_generateBitMapFromQcowFilePtr
newCallback_LogicInternal_generateBitMapFromQcowFile(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_generateBitMapFromQcowFile<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_generateBitMapFromQcowFilePtr
newCallback_LogicInternal_generateBitMapFromQcowFile(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_generateBitMapFromQcowFile<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_fromMapGetQcowMaxSize : public Callback_LogicInternal_fromMapGetQcowMaxSize_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Long);

    CallbackNC_LogicInternal_fromMapGetQcowMaxSize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_fromMapGetQcowMaxSize(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_fromMapGetQcowMaxSizePtr
newCallback_LogicInternal_fromMapGetQcowMaxSize(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_fromMapGetQcowMaxSize<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_fromMapGetQcowMaxSizePtr
newCallback_LogicInternal_fromMapGetQcowMaxSize(T* instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_fromMapGetQcowMaxSize<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_fromMapGetQcowMaxSize : public Callback_LogicInternal_fromMapGetQcowMaxSize_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Long, const CT&);

    Callback_LogicInternal_fromMapGetQcowMaxSize(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_fromMapGetQcowMaxSize(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_fromMapGetQcowMaxSizePtr
newCallback_LogicInternal_fromMapGetQcowMaxSize(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_fromMapGetQcowMaxSize<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_fromMapGetQcowMaxSizePtr
newCallback_LogicInternal_fromMapGetQcowMaxSize(T* instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_fromMapGetQcowMaxSize<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_reorganizeHashFile : public Callback_LogicInternal_reorganizeHashFile_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicInternal_reorganizeHashFile(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_reorganizeHashFile(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_reorganizeHashFilePtr
newCallback_LogicInternal_reorganizeHashFile(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_reorganizeHashFile<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_reorganizeHashFilePtr
newCallback_LogicInternal_reorganizeHashFile(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_reorganizeHashFile<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicInternal_reorganizeHashFilePtr
newCallback_LogicInternal_reorganizeHashFile(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_reorganizeHashFile<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_reorganizeHashFilePtr
newCallback_LogicInternal_reorganizeHashFile(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_reorganizeHashFile<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_reorganizeHashFile : public Callback_LogicInternal_reorganizeHashFile_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicInternal_reorganizeHashFile(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_reorganizeHashFile(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_reorganizeHashFilePtr
newCallback_LogicInternal_reorganizeHashFile(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_reorganizeHashFile<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_reorganizeHashFilePtr
newCallback_LogicInternal_reorganizeHashFile(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_reorganizeHashFile<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_reorganizeHashFilePtr
newCallback_LogicInternal_reorganizeHashFile(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_reorganizeHashFile<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_reorganizeHashFilePtr
newCallback_LogicInternal_reorganizeHashFile(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_reorganizeHashFile<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_reorganizeHashFilev2 : public Callback_LogicInternal_reorganizeHashFilev2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_LogicInternal_reorganizeHashFilev2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_reorganizeHashFilev2(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_reorganizeHashFilev2Ptr
newCallback_LogicInternal_reorganizeHashFilev2(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_reorganizeHashFilev2<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_reorganizeHashFilev2Ptr
newCallback_LogicInternal_reorganizeHashFilev2(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_reorganizeHashFilev2<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_LogicInternal_reorganizeHashFilev2Ptr
newCallback_LogicInternal_reorganizeHashFilev2(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_reorganizeHashFilev2<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_reorganizeHashFilev2Ptr
newCallback_LogicInternal_reorganizeHashFilev2(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_reorganizeHashFilev2<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_reorganizeHashFilev2 : public Callback_LogicInternal_reorganizeHashFilev2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_LogicInternal_reorganizeHashFilev2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_reorganizeHashFilev2(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_reorganizeHashFilev2Ptr
newCallback_LogicInternal_reorganizeHashFilev2(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_reorganizeHashFilev2<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_reorganizeHashFilev2Ptr
newCallback_LogicInternal_reorganizeHashFilev2(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_reorganizeHashFilev2<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_reorganizeHashFilev2Ptr
newCallback_LogicInternal_reorganizeHashFilev2(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_reorganizeHashFilev2<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_reorganizeHashFilev2Ptr
newCallback_LogicInternal_reorganizeHashFilev2(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_reorganizeHashFilev2<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_hash2Interval : public Callback_LogicInternal_hash2Interval_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Long);

    CallbackNC_LogicInternal_hash2Interval(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_hash2Interval(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_hash2IntervalPtr
newCallback_LogicInternal_hash2Interval(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_hash2Interval<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_hash2IntervalPtr
newCallback_LogicInternal_hash2Interval(T* instance, void (T::*cb)(::Ice::Long), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_hash2Interval<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_hash2Interval : public Callback_LogicInternal_hash2Interval_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Long, const CT&);

    Callback_LogicInternal_hash2Interval(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::Ice::Long __ret;
        try
        {
            __ret = __proxy->end_hash2Interval(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_hash2IntervalPtr
newCallback_LogicInternal_hash2Interval(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_hash2Interval<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_hash2IntervalPtr
newCallback_LogicInternal_hash2Interval(T* instance, void (T::*cb)(::Ice::Long, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_hash2Interval<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_exportSnapshot : public Callback_LogicInternal_exportSnapshot_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_LogicInternal_exportSnapshot(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_exportSnapshot(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_exportSnapshotPtr
newCallback_LogicInternal_exportSnapshot(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_exportSnapshot<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_exportSnapshotPtr
newCallback_LogicInternal_exportSnapshot(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_exportSnapshot<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_exportSnapshot : public Callback_LogicInternal_exportSnapshot_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_LogicInternal_exportSnapshot(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_exportSnapshot(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_exportSnapshotPtr
newCallback_LogicInternal_exportSnapshot(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_exportSnapshot<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_exportSnapshotPtr
newCallback_LogicInternal_exportSnapshot(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_exportSnapshot<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_getAllTapeJson : public Callback_LogicInternal_getAllTapeJson_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_LogicInternal_getAllTapeJson(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getAllTapeJson(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_getAllTapeJsonPtr
newCallback_LogicInternal_getAllTapeJson(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_getAllTapeJson<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_getAllTapeJsonPtr
newCallback_LogicInternal_getAllTapeJson(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_getAllTapeJson<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_getAllTapeJson : public Callback_LogicInternal_getAllTapeJson_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_LogicInternal_getAllTapeJson(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getAllTapeJson(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_getAllTapeJsonPtr
newCallback_LogicInternal_getAllTapeJson(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_getAllTapeJson<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_getAllTapeJsonPtr
newCallback_LogicInternal_getAllTapeJson(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_getAllTapeJson<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_getAllMediumxJson : public Callback_LogicInternal_getAllMediumxJson_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_LogicInternal_getAllMediumxJson(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getAllMediumxJson(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_getAllMediumxJsonPtr
newCallback_LogicInternal_getAllMediumxJson(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_getAllMediumxJson<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_getAllMediumxJsonPtr
newCallback_LogicInternal_getAllMediumxJson(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_getAllMediumxJson<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_getAllMediumxJson : public Callback_LogicInternal_getAllMediumxJson_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_LogicInternal_getAllMediumxJson(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getAllMediumxJson(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_getAllMediumxJsonPtr
newCallback_LogicInternal_getAllMediumxJson(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_getAllMediumxJson<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_getAllMediumxJsonPtr
newCallback_LogicInternal_getAllMediumxJson(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_getAllMediumxJson<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_archiveMediaOperation : public Callback_LogicInternal_archiveMediaOperation_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_LogicInternal_archiveMediaOperation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_archiveMediaOperation(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_archiveMediaOperationPtr
newCallback_LogicInternal_archiveMediaOperation(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_archiveMediaOperation<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_archiveMediaOperationPtr
newCallback_LogicInternal_archiveMediaOperation(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_archiveMediaOperation<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_archiveMediaOperation : public Callback_LogicInternal_archiveMediaOperation_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_LogicInternal_archiveMediaOperation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_archiveMediaOperation(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_archiveMediaOperationPtr
newCallback_LogicInternal_archiveMediaOperation(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_archiveMediaOperation<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_archiveMediaOperationPtr
newCallback_LogicInternal_archiveMediaOperation(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_archiveMediaOperation<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_getArchiveFileMetaData : public Callback_LogicInternal_getArchiveFileMetaData_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_LogicInternal_getArchiveFileMetaData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getArchiveFileMetaData(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_getArchiveFileMetaDataPtr
newCallback_LogicInternal_getArchiveFileMetaData(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_getArchiveFileMetaData<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_getArchiveFileMetaDataPtr
newCallback_LogicInternal_getArchiveFileMetaData(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_getArchiveFileMetaData<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_getArchiveFileMetaData : public Callback_LogicInternal_getArchiveFileMetaData_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_LogicInternal_getArchiveFileMetaData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getArchiveFileMetaData(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_getArchiveFileMetaDataPtr
newCallback_LogicInternal_getArchiveFileMetaData(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_getArchiveFileMetaData<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_getArchiveFileMetaDataPtr
newCallback_LogicInternal_getArchiveFileMetaData(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_getArchiveFileMetaData<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_genArchiveQcowFile : public Callback_LogicInternal_genArchiveQcowFile_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_LogicInternal_genArchiveQcowFile(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_genArchiveQcowFile(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_genArchiveQcowFilePtr
newCallback_LogicInternal_genArchiveQcowFile(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_genArchiveQcowFile<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_genArchiveQcowFilePtr
newCallback_LogicInternal_genArchiveQcowFile(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_genArchiveQcowFile<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_genArchiveQcowFile : public Callback_LogicInternal_genArchiveQcowFile_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_LogicInternal_genArchiveQcowFile(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_genArchiveQcowFile(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_genArchiveQcowFilePtr
newCallback_LogicInternal_genArchiveQcowFile(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_genArchiveQcowFile<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_genArchiveQcowFilePtr
newCallback_LogicInternal_genArchiveQcowFile(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_genArchiveQcowFile<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_fileBackup : public Callback_LogicInternal_fileBackup_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_LogicInternal_fileBackup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_fileBackup(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_fileBackupPtr
newCallback_LogicInternal_fileBackup(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_fileBackup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_fileBackupPtr
newCallback_LogicInternal_fileBackup(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_fileBackup<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_fileBackup : public Callback_LogicInternal_fileBackup_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_LogicInternal_fileBackup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_fileBackup(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_fileBackupPtr
newCallback_LogicInternal_fileBackup(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_fileBackup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_fileBackupPtr
newCallback_LogicInternal_fileBackup(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_fileBackup<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_LogicInternal_kvmRpc : public Callback_LogicInternal_kvmRpc_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_LogicInternal_kvmRpc(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_kvmRpc(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_LogicInternal_kvmRpcPtr
newCallback_LogicInternal_kvmRpc(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_kvmRpc<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_LogicInternal_kvmRpcPtr
newCallback_LogicInternal_kvmRpc(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_LogicInternal_kvmRpc<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_LogicInternal_kvmRpc : public Callback_LogicInternal_kvmRpc_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_LogicInternal_kvmRpc(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::LogicInternalPrx __proxy = ::BoxLogic::LogicInternalPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_kvmRpc(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_LogicInternal_kvmRpcPtr
newCallback_LogicInternal_kvmRpc(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_kvmRpc<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_LogicInternal_kvmRpcPtr
newCallback_LogicInternal_kvmRpc(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_LogicInternal_kvmRpc<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_Setup_startSetup : public Callback_Setup_startSetup_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Setup_startSetup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::SetupPrx __proxy = ::BoxLogic::SetupPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_startSetup(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Setup_startSetupPtr
newCallback_Setup_startSetup(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Setup_startSetup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Setup_startSetupPtr
newCallback_Setup_startSetup(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Setup_startSetup<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Setup_startSetupPtr
newCallback_Setup_startSetup(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Setup_startSetup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Setup_startSetupPtr
newCallback_Setup_startSetup(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Setup_startSetup<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Setup_startSetup : public Callback_Setup_startSetup_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Setup_startSetup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::SetupPrx __proxy = ::BoxLogic::SetupPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_startSetup(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Setup_startSetupPtr
newCallback_Setup_startSetup(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Setup_startSetup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Setup_startSetupPtr
newCallback_Setup_startSetup(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Setup_startSetup<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Setup_startSetupPtr
newCallback_Setup_startSetup(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Setup_startSetup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Setup_startSetupPtr
newCallback_Setup_startSetup(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Setup_startSetup<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_Setup_cancelSetup : public Callback_Setup_cancelSetup_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Setup_cancelSetup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::SetupPrx __proxy = ::BoxLogic::SetupPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_cancelSetup(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

    private:

    Response _response;
};

template<class T> Callback_Setup_cancelSetupPtr
newCallback_Setup_cancelSetup(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Setup_cancelSetup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Setup_cancelSetupPtr
newCallback_Setup_cancelSetup(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Setup_cancelSetup<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_Setup_cancelSetupPtr
newCallback_Setup_cancelSetup(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Setup_cancelSetup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_Setup_cancelSetupPtr
newCallback_Setup_cancelSetup(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Setup_cancelSetup<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_Setup_cancelSetup : public Callback_Setup_cancelSetup_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Setup_cancelSetup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::BoxLogic::SetupPrx __proxy = ::BoxLogic::SetupPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_cancelSetup(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_Setup_cancelSetupPtr
newCallback_Setup_cancelSetup(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Setup_cancelSetup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Setup_cancelSetupPtr
newCallback_Setup_cancelSetup(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Setup_cancelSetup<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_Setup_cancelSetupPtr
newCallback_Setup_cancelSetup(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Setup_cancelSetup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_Setup_cancelSetupPtr
newCallback_Setup_cancelSetup(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Setup_cancelSetup<T, CT>(instance, 0, excb, sentcb);
}

}

#include <IceUtil/PopDisableWarnings.h>
#endif
