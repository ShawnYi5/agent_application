// **********************************************************************
//
// Copyright (c) 2003-2015 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.6.1
//
// <auto-generated>
//
// Generated from file `vps_agent.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <vps_agent.h>
#include <IceUtil/PushDisableWarnings.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/BasicStream.h>
#include <IceUtil/Iterator.h>
#include <IceUtil/PopDisableWarnings.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 306
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace
{

const ::std::string __VpsAgent__Services__ping_name = "ping";

const ::std::string __VpsAgent__Backup__PostSectorData_name = "PostSectorData";

const ::std::string __VpsAgent__Backup__PostSectorDataEx_name = "PostSectorDataEx";

const ::std::string __VpsAgent__Backup__PostSectorDataExV2_name = "PostSectorDataExV2";

const ::std::string __VpsAgent__Backup__PostBakDataExt_name = "PostBakDataExt";

const ::std::string __VpsAgent__Backup__GetBakDataExt_name = "GetBakDataExt";

const ::std::string __VpsAgent__Backup__PostUsedBlockBitmap_name = "PostUsedBlockBitmap";

const ::std::string __VpsAgent__Backup__PostDuplicateFileSectors_name = "PostDuplicateFileSectors";

const ::std::string __VpsAgent__Backup__PostCurrentFileList_name = "PostCurrentFileList";

const ::std::string __VpsAgent__Backup__GetFileListFromDuplicateFilePool_name = "GetFileListFromDuplicateFilePool";

const ::std::string __VpsAgent__Backup__ReportStatus_name = "ReportStatus";

const ::std::string __VpsAgent__Backup__Exit_name = "Exit";

const ::std::string __VpsAgent__Restore__getUesdBlockBitmap_name = "getUesdBlockBitmap";

const ::std::string __VpsAgent__Restore__reportStatus_name = "reportStatus";

const ::std::string __VpsAgent__AgentReceiver__check_name = "check";

const ::std::string __VpsAgent__AgentReceiver__JsonFunc_name = "JsonFunc";

const ::std::string __VpsAgent__AgentReceiver__QuerySystemInfo_name = "QuerySystemInfo";

const ::std::string __VpsAgent__AgentReceiver__QueryDisksStatus_name = "QueryDisksStatus";

const ::std::string __VpsAgent__AgentReceiver__DoBackup_name = "DoBackup";

const ::std::string __VpsAgent__AgentReceiver__DoBackupEx_name = "DoBackupEx";

const ::std::string __VpsAgent__AgentReceiver__GetLastBackupError_name = "GetLastBackupError";

const ::std::string __VpsAgent__AgentReceiver__GetLastCdpError_name = "GetLastCdpError";

const ::std::string __VpsAgent__AgentReceiver__StartAgentPe_name = "StartAgentPe";

const ::std::string __VpsAgent__AgentReceiver__CancelBackup_name = "CancelBackup";

const ::std::string __VpsAgent__AgentReceiver__NotifyHighPriority_name = "NotifyHighPriority";

const ::std::string __VpsAgent__AgentReceiver__GetStatus_name = "GetStatus";

const ::std::string __VpsAgent__AgentReceiver__StopCdpStatus_name = "StopCdpStatus";

const ::std::string __VpsAgent__AgentReceiver__PackDebugFiles_name = "PackDebugFiles";

const ::std::string __VpsAgent__AgentReceiver__FetchDebugPacket_name = "FetchDebugPacket";

const ::std::string __VpsAgent__AgentReceiver__DoRestore_name = "DoRestore";

const ::std::string __VpsAgent__AgentReceiver__CancelRestore_name = "CancelRestore";

const ::std::string __VpsAgent__AgentReceiver__GetServiceList_name = "GetServiceList";

const ::std::string __VpsAgent__AgentReceiver__GetTcpListenList_name = "GetTcpListenList";

const ::std::string __VpsAgent__AgentReceiver__StartServiceSync_name = "StartServiceSync";

const ::std::string __VpsAgent__AgentReceiver__StopServiceSync_name = "StopServiceSync";

const ::std::string __VpsAgent__AgentReceiver__StartHttpDServiceAsync_name = "StartHttpDServiceAsync";

const ::std::string __VpsAgent__AgentReceiver__GetHttpDServiceListSync_name = "GetHttpDServiceListSync";

const ::std::string __VpsAgent__AgentReceiver__StopAllHttpDServiceSync_name = "StopAllHttpDServiceSync";

const ::std::string __VpsAgent__AgentReceiver__testdisk_name = "testdisk";

const ::std::string __VpsAgent__AgentReceiver__readdisk_name = "readdisk";

const ::std::string __VpsAgent__AgentReceiver__writedisk_name = "writedisk";

const ::std::string __VpsAgent__AgentReceiver__JsonFuncV2_name = "JsonFuncV2";

const ::std::string __VpsAgent__Session__QueryName_name = "QueryName";

const ::std::string __VpsAgent__Session__QueryIdentity_name = "QueryIdentity";

const ::std::string __VpsAgent__Session__QuerySoftIdent_name = "QuerySoftIdent";

const ::std::string __VpsAgent__Session__QueryJsonData_name = "QueryJsonData";

const ::std::string __VpsAgent__Session__destroy_name = "destroy";

const ::std::string __VpsAgent__Session__initiateReceiver_name = "initiateReceiver";

const ::std::string __VpsAgent__Session__refresh_name = "refresh";

const ::std::string __VpsAgent__Session__reportRestoreStatus_name = "reportRestoreStatus";

const ::std::string __VpsAgent__Session__queryLastCdpDetailByRestoreToken_name = "queryLastCdpDetailByRestoreToken";

const ::std::string __VpsAgent__Session__queryLastCdpDetailByCdpToken_name = "queryLastCdpDetailByCdpToken";

const ::std::string __VpsAgent__Session__setPreReadBitmap_name = "setPreReadBitmap";

const ::std::string __VpsAgent__SessionFactory__create_name = "create";

}

namespace
{

const ::IceInternal::DefaultUserExceptionFactoryInit< ::VpsAgent::AgentModuleError> __VpsAgent__AgentModuleError_init("::VpsAgent::AgentModuleError");

}

VpsAgent::AgentModuleError::AgentModuleError(const ::std::string& __ice_description, const ::std::string& __ice_debug, ::Ice::Long __ice_rawCode, const ::std::string& __ice_moduleName) :
    ::Utils::SystemError(__ice_description, __ice_debug, __ice_rawCode),
    moduleName(__ice_moduleName)
{
}

VpsAgent::AgentModuleError::~AgentModuleError() throw()
{
}

::std::string
VpsAgent::AgentModuleError::ice_name() const
{
    return "VpsAgent::AgentModuleError";
}

VpsAgent::AgentModuleError*
VpsAgent::AgentModuleError::ice_clone() const
{
    return new AgentModuleError(*this);
}

void
VpsAgent::AgentModuleError::ice_throw() const
{
    throw *this;
}

void
VpsAgent::AgentModuleError::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::VpsAgent::AgentModuleError", -1, false);
    __os->write(moduleName);
    __os->endWriteSlice();
    ::Utils::SystemError::__writeImpl(__os);
}

void
VpsAgent::AgentModuleError::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->read(moduleName);
    __is->endReadSlice();
    ::Utils::SystemError::__readImpl(__is);
}

namespace Ice
{
}
::IceProxy::Ice::Object* ::IceProxy::VpsAgent::upCast(::IceProxy::VpsAgent::Services* p) { return p; }

void
::IceProxy::VpsAgent::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::VpsAgent::Services>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::VpsAgent::Services;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::VpsAgent::Services::ping(const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __VpsAgent__Services__ping_name, ::Ice::Idempotent, __ctx);
    __og.writeEmptyParams();
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Services::begin_ping(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__Services__ping_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__Services__ping_name, ::Ice::Idempotent, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::VpsAgent::Services::end_ping(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __VpsAgent__Services__ping_name);
}

const ::std::string&
IceProxy::VpsAgent::Services::ice_staticId()
{
    return ::VpsAgent::Services::ice_staticId();
}

::IceProxy::Ice::Object*
IceProxy::VpsAgent::Services::__newInstance() const
{
    return new Services;
}
::IceProxy::Ice::Object* ::IceProxy::VpsAgent::upCast(::IceProxy::VpsAgent::Backup* p) { return p; }

void
::IceProxy::VpsAgent::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::VpsAgent::Backup>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::VpsAgent::Backup;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::VpsAgent::Backup::PostSectorData(::Ice::Int __p_diskIndex, const ::VpsAgent::SectorRange& __p_range, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& __p_data, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__Backup__PostSectorData_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__Backup__PostSectorData_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_diskIndex);
        __os->write(__p_range);
        __os->write(__p_data);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Backup::begin_PostSectorData(::Ice::Int __p_diskIndex, const ::VpsAgent::SectorRange& __p_range, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& __p_data, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__Backup__PostSectorData_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__Backup__PostSectorData_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__Backup__PostSectorData_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_diskIndex);
        __os->write(__p_range);
        __os->write(__p_data);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Backup::__begin_PostSectorData(::Ice::Int __p_diskIndex, const ::VpsAgent::SectorRange& __p_range, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& __p_data, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::BackupPrx __proxy = ::VpsAgent::BackupPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_PostSectorData(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_PostSectorData(__p_diskIndex, __p_range, __p_data, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::VpsAgent::Backup::end_PostSectorData(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__Backup__PostSectorData_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::VpsAgent::Backup::PostSectorDataEx(::Ice::Int __p_type, ::Ice::Int __p_diskIndex, const ::VpsAgent::SectorRange& __p_range, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& __p_data, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__Backup__PostSectorDataEx_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__Backup__PostSectorDataEx_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_type);
        __os->write(__p_diskIndex);
        __os->write(__p_range);
        __os->write(__p_data);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Backup::begin_PostSectorDataEx(::Ice::Int __p_type, ::Ice::Int __p_diskIndex, const ::VpsAgent::SectorRange& __p_range, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& __p_data, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__Backup__PostSectorDataEx_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__Backup__PostSectorDataEx_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__Backup__PostSectorDataEx_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_type);
        __os->write(__p_diskIndex);
        __os->write(__p_range);
        __os->write(__p_data);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Backup::__begin_PostSectorDataEx(::Ice::Int __p_type, ::Ice::Int __p_diskIndex, const ::VpsAgent::SectorRange& __p_range, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& __p_data, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::BackupPrx __proxy = ::VpsAgent::BackupPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_PostSectorDataEx(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_PostSectorDataEx(__p_type, __p_diskIndex, __p_range, __p_data, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::VpsAgent::Backup::end_PostSectorDataEx(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__Backup__PostSectorDataEx_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::VpsAgent::Backup::PostSectorDataExV2(const ::VpsAgent::PostSectors& __p_sectors, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& __p_data, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__Backup__PostSectorDataExV2_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__Backup__PostSectorDataExV2_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_sectors);
        __os->write(__p_data);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Backup::begin_PostSectorDataExV2(const ::VpsAgent::PostSectors& __p_sectors, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& __p_data, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__Backup__PostSectorDataExV2_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__Backup__PostSectorDataExV2_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__Backup__PostSectorDataExV2_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_sectors);
        __os->write(__p_data);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Backup::__begin_PostSectorDataExV2(const ::VpsAgent::PostSectors& __p_sectors, const ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*>& __p_data, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::BackupPrx __proxy = ::VpsAgent::BackupPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_PostSectorDataExV2(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_PostSectorDataExV2(__p_sectors, __p_data, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::VpsAgent::Backup::end_PostSectorDataExV2(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__Backup__PostSectorDataExV2_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::VpsAgent::Backup::PostBakDataExt(const ::VpsAgent::PostExtDataVector& __p_extDataVector, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__Backup__PostBakDataExt_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__Backup__PostBakDataExt_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_extDataVector);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Backup::begin_PostBakDataExt(const ::VpsAgent::PostExtDataVector& __p_extDataVector, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__Backup__PostBakDataExt_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__Backup__PostBakDataExt_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__Backup__PostBakDataExt_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_extDataVector);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Backup::__begin_PostBakDataExt(const ::VpsAgent::PostExtDataVector& __p_extDataVector, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::BackupPrx __proxy = ::VpsAgent::BackupPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_PostBakDataExt(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_PostBakDataExt(__p_extDataVector, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::VpsAgent::Backup::end_PostBakDataExt(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__Backup__PostBakDataExt_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

bool
IceProxy::VpsAgent::Backup::GetBakDataExt(const ::VpsAgent::GetExtDataVector& __p_extTypeVector, ::VpsAgent::PostExtDataVector& __p_extDataVector, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__Backup__GetBakDataExt_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__Backup__GetBakDataExt_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_extTypeVector);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_extDataVector);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Backup::begin_GetBakDataExt(const ::VpsAgent::GetExtDataVector& __p_extTypeVector, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__Backup__GetBakDataExt_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__Backup__GetBakDataExt_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__Backup__GetBakDataExt_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_extTypeVector);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Backup::__begin_GetBakDataExt(const ::VpsAgent::GetExtDataVector& __p_extTypeVector, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool, const ::VpsAgent::PostExtDataVector&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool, const ::VpsAgent::PostExtDataVector&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::BackupPrx __proxy = ::VpsAgent::BackupPrx::uncheckedCast(__result->getProxy());
            ::VpsAgent::PostExtDataVector __p_extDataVector;
            bool __ret;
            try
            {
                __ret = __proxy->end_GetBakDataExt(__p_extDataVector, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_extDataVector);
            }
        }
    
    private:
        
        ::std::function<void (bool, const ::VpsAgent::PostExtDataVector&)> _response;
    };
    return begin_GetBakDataExt(__p_extTypeVector, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::VpsAgent::Backup::end_GetBakDataExt(::VpsAgent::PostExtDataVector& __p_extDataVector, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__Backup__GetBakDataExt_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_extDataVector);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::VpsAgent::Backup::PostUsedBlockBitmap(::Ice::Int __p_diskIndex, const ::VpsAgent::BinaryStream& __p_bitmap, bool __p_completed, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__Backup__PostUsedBlockBitmap_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__Backup__PostUsedBlockBitmap_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_diskIndex);
        __os->write(__p_bitmap);
        __os->write(__p_completed);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Backup::begin_PostUsedBlockBitmap(::Ice::Int __p_diskIndex, const ::VpsAgent::BinaryStream& __p_bitmap, bool __p_completed, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__Backup__PostUsedBlockBitmap_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__Backup__PostUsedBlockBitmap_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__Backup__PostUsedBlockBitmap_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_diskIndex);
        __os->write(__p_bitmap);
        __os->write(__p_completed);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Backup::__begin_PostUsedBlockBitmap(::Ice::Int __p_diskIndex, const ::VpsAgent::BinaryStream& __p_bitmap, bool __p_completed, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::BackupPrx __proxy = ::VpsAgent::BackupPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_PostUsedBlockBitmap(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_PostUsedBlockBitmap(__p_diskIndex, __p_bitmap, __p_completed, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::VpsAgent::Backup::end_PostUsedBlockBitmap(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__Backup__PostUsedBlockBitmap_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::VpsAgent::Backup::PostDuplicateFileSectors(::Ice::Int __p_diskIndex, const ::IMG::DuplicateFileSectors& __p_sectors, bool __p_completed, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__Backup__PostDuplicateFileSectors_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__Backup__PostDuplicateFileSectors_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_diskIndex);
        __os->write(__p_sectors);
        __os->write(__p_completed);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Backup::begin_PostDuplicateFileSectors(::Ice::Int __p_diskIndex, const ::IMG::DuplicateFileSectors& __p_sectors, bool __p_completed, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__Backup__PostDuplicateFileSectors_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__Backup__PostDuplicateFileSectors_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__Backup__PostDuplicateFileSectors_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_diskIndex);
        __os->write(__p_sectors);
        __os->write(__p_completed);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Backup::__begin_PostDuplicateFileSectors(::Ice::Int __p_diskIndex, const ::IMG::DuplicateFileSectors& __p_sectors, bool __p_completed, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::BackupPrx __proxy = ::VpsAgent::BackupPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_PostDuplicateFileSectors(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_PostDuplicateFileSectors(__p_diskIndex, __p_sectors, __p_completed, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::VpsAgent::Backup::end_PostDuplicateFileSectors(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__Backup__PostDuplicateFileSectors_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::VpsAgent::Backup::PostCurrentFileList(const ::VpsAgent::BinaryStream& __p_bitmap, bool __p_completed, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__Backup__PostCurrentFileList_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__Backup__PostCurrentFileList_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_bitmap);
        __os->write(__p_completed);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Backup::begin_PostCurrentFileList(const ::VpsAgent::BinaryStream& __p_bitmap, bool __p_completed, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__Backup__PostCurrentFileList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__Backup__PostCurrentFileList_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__Backup__PostCurrentFileList_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_bitmap);
        __os->write(__p_completed);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Backup::__begin_PostCurrentFileList(const ::VpsAgent::BinaryStream& __p_bitmap, bool __p_completed, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::BackupPrx __proxy = ::VpsAgent::BackupPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_PostCurrentFileList(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_PostCurrentFileList(__p_bitmap, __p_completed, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::VpsAgent::Backup::end_PostCurrentFileList(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__Backup__PostCurrentFileList_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

bool
IceProxy::VpsAgent::Backup::GetFileListFromDuplicateFilePool(::VpsAgent::BinaryStream& __p_bitmap, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__Backup__GetFileListFromDuplicateFilePool_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__Backup__GetFileListFromDuplicateFilePool_name, ::Ice::Normal, __ctx);
    __og.writeEmptyParams();
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::NeedRetryLaterError&)
        {
            throw;
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_bitmap);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Backup::begin_GetFileListFromDuplicateFilePool(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__Backup__GetFileListFromDuplicateFilePool_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__Backup__GetFileListFromDuplicateFilePool_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__Backup__GetFileListFromDuplicateFilePool_name, ::Ice::Normal, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Backup::__begin_GetFileListFromDuplicateFilePool(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool, const ::VpsAgent::BinaryStream&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool, const ::VpsAgent::BinaryStream&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::BackupPrx __proxy = ::VpsAgent::BackupPrx::uncheckedCast(__result->getProxy());
            ::VpsAgent::BinaryStream __p_bitmap;
            bool __ret;
            try
            {
                __ret = __proxy->end_GetFileListFromDuplicateFilePool(__p_bitmap, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_bitmap);
            }
        }
    
    private:
        
        ::std::function<void (bool, const ::VpsAgent::BinaryStream&)> _response;
    };
    return begin_GetFileListFromDuplicateFilePool(__ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::VpsAgent::Backup::end_GetFileListFromDuplicateFilePool(::VpsAgent::BinaryStream& __p_bitmap, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__Backup__GetFileListFromDuplicateFilePool_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::NeedRetryLaterError&)
        {
            throw;
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_bitmap);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::VpsAgent::Backup::ReportStatus(const ::BoxLogic::BackupProgress& __p_progress, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__Backup__ReportStatus_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__Backup__ReportStatus_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_progress);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Backup::begin_ReportStatus(const ::BoxLogic::BackupProgress& __p_progress, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__Backup__ReportStatus_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__Backup__ReportStatus_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__Backup__ReportStatus_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_progress);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Backup::__begin_ReportStatus(const ::BoxLogic::BackupProgress& __p_progress, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::BackupPrx __proxy = ::VpsAgent::BackupPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_ReportStatus(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_ReportStatus(__p_progress, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::VpsAgent::Backup::end_ReportStatus(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__Backup__ReportStatus_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::VpsAgent::Backup::Exit(::BoxLogic::BackupFinishCode __p_code, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__Backup__Exit_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__Backup__Exit_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_code);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Backup::begin_Exit(::BoxLogic::BackupFinishCode __p_code, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__Backup__Exit_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__Backup__Exit_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__Backup__Exit_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_code);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Backup::__begin_Exit(::BoxLogic::BackupFinishCode __p_code, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::BackupPrx __proxy = ::VpsAgent::BackupPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_Exit(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_Exit(__p_code, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::VpsAgent::Backup::end_Exit(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__Backup__Exit_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

const ::std::string&
IceProxy::VpsAgent::Backup::ice_staticId()
{
    return ::VpsAgent::Backup::ice_staticId();
}

::IceProxy::Ice::Object*
IceProxy::VpsAgent::Backup::__newInstance() const
{
    return new Backup;
}
::IceProxy::Ice::Object* ::IceProxy::VpsAgent::upCast(::IceProxy::VpsAgent::Restore* p) { return p; }

void
::IceProxy::VpsAgent::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::VpsAgent::Restore>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::VpsAgent::Restore;
        v->__copyFrom(proxy);
    }
}

::Ice::Int
IceProxy::VpsAgent::Restore::getUesdBlockBitmap(const ::std::string& __p_token, ::Ice::Int __p_index, ::VpsAgent::BinaryStream& __p_bitmap, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__Restore__getUesdBlockBitmap_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__Restore__getUesdBlockBitmap_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_token);
        __os->write(__p_index);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_bitmap);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Restore::begin_getUesdBlockBitmap(const ::std::string& __p_token, ::Ice::Int __p_index, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__Restore__getUesdBlockBitmap_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__Restore__getUesdBlockBitmap_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__Restore__getUesdBlockBitmap_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_token);
        __os->write(__p_index);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Restore::__begin_getUesdBlockBitmap(const ::std::string& __p_token, ::Ice::Int __p_index, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int, const ::VpsAgent::BinaryStream&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int, const ::VpsAgent::BinaryStream&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::RestorePrx __proxy = ::VpsAgent::RestorePrx::uncheckedCast(__result->getProxy());
            ::VpsAgent::BinaryStream __p_bitmap;
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_getUesdBlockBitmap(__p_bitmap, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_bitmap);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int, const ::VpsAgent::BinaryStream&)> _response;
    };
    return begin_getUesdBlockBitmap(__p_token, __p_index, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::VpsAgent::Restore::end_getUesdBlockBitmap(::VpsAgent::BinaryStream& __p_bitmap, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__Restore__getUesdBlockBitmap_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_bitmap);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::VpsAgent::Restore::reportStatus(::BoxLogic::RestoreStageCode __p_code, const ::std::string& __p_msg, const ::std::string& __p_debug, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__Restore__reportStatus_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__Restore__reportStatus_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_code);
        __os->write(__p_msg);
        __os->write(__p_debug);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Restore::begin_reportStatus(::BoxLogic::RestoreStageCode __p_code, const ::std::string& __p_msg, const ::std::string& __p_debug, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__Restore__reportStatus_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__Restore__reportStatus_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__Restore__reportStatus_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_code);
        __os->write(__p_msg);
        __os->write(__p_debug);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Restore::__begin_reportStatus(::BoxLogic::RestoreStageCode __p_code, const ::std::string& __p_msg, const ::std::string& __p_debug, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::RestorePrx __proxy = ::VpsAgent::RestorePrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_reportStatus(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_reportStatus(__p_code, __p_msg, __p_debug, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::VpsAgent::Restore::end_reportStatus(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__Restore__reportStatus_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

const ::std::string&
IceProxy::VpsAgent::Restore::ice_staticId()
{
    return ::VpsAgent::Restore::ice_staticId();
}

::IceProxy::Ice::Object*
IceProxy::VpsAgent::Restore::__newInstance() const
{
    return new Restore;
}
::IceProxy::Ice::Object* ::IceProxy::VpsAgent::upCast(::IceProxy::VpsAgent::AgentReceiver* p) { return p; }

void
::IceProxy::VpsAgent::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::VpsAgent::AgentReceiver>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::VpsAgent::AgentReceiver;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::VpsAgent::AgentReceiver::check(const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__AgentReceiver__check_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__AgentReceiver__check_name, ::Ice::Idempotent, __ctx);
    __og.writeEmptyParams();
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::VpsAgent::AgentModuleError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::begin_check(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__AgentReceiver__check_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__AgentReceiver__check_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__AgentReceiver__check_name, ::Ice::Idempotent, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::__begin_check(const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::AgentReceiverPrx __proxy = ::VpsAgent::AgentReceiverPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_check(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_check(__ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::VpsAgent::AgentReceiver::end_check(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__AgentReceiver__check_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::VpsAgent::AgentModuleError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

::std::string
IceProxy::VpsAgent::AgentReceiver::JsonFunc(const ::std::string& __p_InputParam, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__AgentReceiver__JsonFunc_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__AgentReceiver__JsonFunc_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_InputParam);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::begin_JsonFunc(const ::std::string& __p_InputParam, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__AgentReceiver__JsonFunc_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__AgentReceiver__JsonFunc_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__AgentReceiver__JsonFunc_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_InputParam);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::__begin_JsonFunc(const ::std::string& __p_InputParam, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::AgentReceiverPrx __proxy = ::VpsAgent::AgentReceiverPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_JsonFunc(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_JsonFunc(__p_InputParam, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::VpsAgent::AgentReceiver::end_JsonFunc(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__AgentReceiver__JsonFunc_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::std::string
IceProxy::VpsAgent::AgentReceiver::QuerySystemInfo(const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__AgentReceiver__QuerySystemInfo_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__AgentReceiver__QuerySystemInfo_name, ::Ice::Idempotent, __ctx);
    __og.writeEmptyParams();
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::begin_QuerySystemInfo(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__AgentReceiver__QuerySystemInfo_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__AgentReceiver__QuerySystemInfo_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__AgentReceiver__QuerySystemInfo_name, ::Ice::Idempotent, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::__begin_QuerySystemInfo(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::AgentReceiverPrx __proxy = ::VpsAgent::AgentReceiverPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_QuerySystemInfo(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_QuerySystemInfo(__ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::VpsAgent::AgentReceiver::end_QuerySystemInfo(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__AgentReceiver__QuerySystemInfo_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::VpsAgent::AgentReceiver::QueryDisksStatus(::BoxLogic::Disks& __p_disks, IceUtil::Optional< ::std::string>& __p_more, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__AgentReceiver__QueryDisksStatus_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__AgentReceiver__QueryDisksStatus_name, ::Ice::Idempotent, __ctx);
    __og.writeEmptyParams();
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_disks);
    __is->read(1, __p_more);
    __og.endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::begin_QueryDisksStatus(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__AgentReceiver__QueryDisksStatus_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__AgentReceiver__QueryDisksStatus_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__AgentReceiver__QueryDisksStatus_name, ::Ice::Idempotent, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::__begin_QueryDisksStatus(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::BoxLogic::Disks&, const IceUtil::Optional< ::std::string>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::BoxLogic::Disks&, const IceUtil::Optional< ::std::string>&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::AgentReceiverPrx __proxy = ::VpsAgent::AgentReceiverPrx::uncheckedCast(__result->getProxy());
            ::BoxLogic::Disks __p_disks;
            IceUtil::Optional< ::std::string> __p_more;
            try
            {
                __proxy->end_QueryDisksStatus(__p_disks, __p_more, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__p_disks, __p_more);
            }
        }
    
    private:
        
        ::std::function<void (const ::BoxLogic::Disks&, const IceUtil::Optional< ::std::string>&)> _response;
    };
    return begin_QueryDisksStatus(__ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::VpsAgent::AgentReceiver::end_QueryDisksStatus(::BoxLogic::Disks& __p_disks, IceUtil::Optional< ::std::string>& __p_more, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__AgentReceiver__QueryDisksStatus_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_disks);
    __is->read(1, __p_more);
    __result->__endReadParams();
}

void
IceProxy::VpsAgent::AgentReceiver::DoBackup(const ::VpsAgent::SnapshotNames& __p_snapshots, const ::VpsAgent::BackupPrx& __p_prx, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__AgentReceiver__DoBackup_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__AgentReceiver__DoBackup_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_snapshots);
        __os->write(__p_prx);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::begin_DoBackup(const ::VpsAgent::SnapshotNames& __p_snapshots, const ::VpsAgent::BackupPrx& __p_prx, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__AgentReceiver__DoBackup_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__AgentReceiver__DoBackup_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__AgentReceiver__DoBackup_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_snapshots);
        __os->write(__p_prx);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::__begin_DoBackup(const ::VpsAgent::SnapshotNames& __p_snapshots, const ::VpsAgent::BackupPrx& __p_prx, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::AgentReceiverPrx __proxy = ::VpsAgent::AgentReceiverPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_DoBackup(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_DoBackup(__p_snapshots, __p_prx, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::VpsAgent::AgentReceiver::end_DoBackup(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__AgentReceiver__DoBackup_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::VpsAgent::AgentReceiver::DoBackupEx(const ::VpsAgent::SnapshotNames& __p_snapshots, const ::VpsAgent::SnapshotConfigs& __p_configs, const ::VpsAgent::BackupPrx& __p_prx, const IceUtil::Optional< ::std::string>& __p_jsonConfig, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__AgentReceiver__DoBackupEx_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__AgentReceiver__DoBackupEx_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_snapshots);
        __os->write(__p_configs);
        __os->write(__p_prx);
        __os->write(1, __p_jsonConfig);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::begin_DoBackupEx(const ::VpsAgent::SnapshotNames& __p_snapshots, const ::VpsAgent::SnapshotConfigs& __p_configs, const ::VpsAgent::BackupPrx& __p_prx, const IceUtil::Optional< ::std::string>& __p_jsonConfig, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__AgentReceiver__DoBackupEx_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__AgentReceiver__DoBackupEx_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__AgentReceiver__DoBackupEx_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_snapshots);
        __os->write(__p_configs);
        __os->write(__p_prx);
        __os->write(1, __p_jsonConfig);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::__begin_DoBackupEx(const ::VpsAgent::SnapshotNames& __p_snapshots, const ::VpsAgent::SnapshotConfigs& __p_configs, const ::VpsAgent::BackupPrx& __p_prx, const IceUtil::Optional< ::std::string>& __p_jsonConfig, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::AgentReceiverPrx __proxy = ::VpsAgent::AgentReceiverPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_DoBackupEx(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_DoBackupEx(__p_snapshots, __p_configs, __p_prx, __p_jsonConfig, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::VpsAgent::AgentReceiver::end_DoBackupEx(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__AgentReceiver__DoBackupEx_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

::std::string
IceProxy::VpsAgent::AgentReceiver::GetLastBackupError(const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__AgentReceiver__GetLastBackupError_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__AgentReceiver__GetLastBackupError_name, ::Ice::Idempotent, __ctx);
    __og.writeEmptyParams();
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::begin_GetLastBackupError(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__AgentReceiver__GetLastBackupError_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__AgentReceiver__GetLastBackupError_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__AgentReceiver__GetLastBackupError_name, ::Ice::Idempotent, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::__begin_GetLastBackupError(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::AgentReceiverPrx __proxy = ::VpsAgent::AgentReceiverPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_GetLastBackupError(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_GetLastBackupError(__ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::VpsAgent::AgentReceiver::end_GetLastBackupError(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__AgentReceiver__GetLastBackupError_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::std::string
IceProxy::VpsAgent::AgentReceiver::GetLastCdpError(const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__AgentReceiver__GetLastCdpError_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__AgentReceiver__GetLastCdpError_name, ::Ice::Idempotent, __ctx);
    __og.writeEmptyParams();
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::begin_GetLastCdpError(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__AgentReceiver__GetLastCdpError_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__AgentReceiver__GetLastCdpError_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__AgentReceiver__GetLastCdpError_name, ::Ice::Idempotent, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::__begin_GetLastCdpError(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::AgentReceiverPrx __proxy = ::VpsAgent::AgentReceiverPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_GetLastCdpError(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_GetLastCdpError(__ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::VpsAgent::AgentReceiver::end_GetLastCdpError(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__AgentReceiver__GetLastCdpError_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::Ice::Int
IceProxy::VpsAgent::AgentReceiver::StartAgentPe(::std::string& __p_peHostIdent, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__AgentReceiver__StartAgentPe_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__AgentReceiver__StartAgentPe_name, ::Ice::Normal, __ctx);
    __og.writeEmptyParams();
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_peHostIdent);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::begin_StartAgentPe(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__AgentReceiver__StartAgentPe_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__AgentReceiver__StartAgentPe_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__AgentReceiver__StartAgentPe_name, ::Ice::Normal, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::__begin_StartAgentPe(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int, const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int, const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::AgentReceiverPrx __proxy = ::VpsAgent::AgentReceiverPrx::uncheckedCast(__result->getProxy());
            ::std::string __p_peHostIdent;
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_StartAgentPe(__p_peHostIdent, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_peHostIdent);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int, const ::std::string&)> _response;
    };
    return begin_StartAgentPe(__ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::VpsAgent::AgentReceiver::end_StartAgentPe(::std::string& __p_peHostIdent, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__AgentReceiver__StartAgentPe_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_peHostIdent);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::VpsAgent::AgentReceiver::CancelBackup(const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__AgentReceiver__CancelBackup_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__AgentReceiver__CancelBackup_name, ::Ice::Idempotent, __ctx);
    __og.writeEmptyParams();
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::begin_CancelBackup(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__AgentReceiver__CancelBackup_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__AgentReceiver__CancelBackup_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__AgentReceiver__CancelBackup_name, ::Ice::Idempotent, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::__begin_CancelBackup(const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::AgentReceiverPrx __proxy = ::VpsAgent::AgentReceiverPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_CancelBackup(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_CancelBackup(__ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::VpsAgent::AgentReceiver::end_CancelBackup(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__AgentReceiver__CancelBackup_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::VpsAgent::AgentReceiver::NotifyHighPriority(const ::std::string& __p_diskIdent, ::Ice::Long __p_byteOffset, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__AgentReceiver__NotifyHighPriority_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__AgentReceiver__NotifyHighPriority_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_diskIdent);
        __os->write(__p_byteOffset);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::begin_NotifyHighPriority(const ::std::string& __p_diskIdent, ::Ice::Long __p_byteOffset, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__AgentReceiver__NotifyHighPriority_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__AgentReceiver__NotifyHighPriority_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__AgentReceiver__NotifyHighPriority_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_diskIdent);
        __os->write(__p_byteOffset);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::__begin_NotifyHighPriority(const ::std::string& __p_diskIdent, ::Ice::Long __p_byteOffset, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::AgentReceiverPrx __proxy = ::VpsAgent::AgentReceiverPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_NotifyHighPriority(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_NotifyHighPriority(__p_diskIdent, __p_byteOffset, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::VpsAgent::AgentReceiver::end_NotifyHighPriority(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__AgentReceiver__NotifyHighPriority_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

::BoxLogic::AgentStatus
IceProxy::VpsAgent::AgentReceiver::GetStatus(const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__AgentReceiver__GetStatus_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__AgentReceiver__GetStatus_name, ::Ice::Idempotent, __ctx);
    __og.writeEmptyParams();
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::BoxLogic::AgentStatus __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::begin_GetStatus(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__AgentReceiver__GetStatus_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__AgentReceiver__GetStatus_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__AgentReceiver__GetStatus_name, ::Ice::Idempotent, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::__begin_GetStatus(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::BoxLogic::AgentStatus&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::BoxLogic::AgentStatus&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::AgentReceiverPrx __proxy = ::VpsAgent::AgentReceiverPrx::uncheckedCast(__result->getProxy());
            ::BoxLogic::AgentStatus __ret;
            try
            {
                __ret = __proxy->end_GetStatus(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::BoxLogic::AgentStatus&)> _response;
    };
    return begin_GetStatus(__ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::BoxLogic::AgentStatus
IceProxy::VpsAgent::AgentReceiver::end_GetStatus(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__AgentReceiver__GetStatus_name);
    ::BoxLogic::AgentStatus __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::VpsAgent::AgentReceiver::StopCdpStatus(const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __VpsAgent__AgentReceiver__StopCdpStatus_name, ::Ice::Idempotent, __ctx);
    __og.writeEmptyParams();
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::begin_StopCdpStatus(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__AgentReceiver__StopCdpStatus_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__AgentReceiver__StopCdpStatus_name, ::Ice::Idempotent, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::VpsAgent::AgentReceiver::end_StopCdpStatus(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __VpsAgent__AgentReceiver__StopCdpStatus_name);
}

bool
IceProxy::VpsAgent::AgentReceiver::PackDebugFiles(const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__AgentReceiver__PackDebugFiles_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__AgentReceiver__PackDebugFiles_name, ::Ice::Normal, __ctx);
    __og.writeEmptyParams();
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::begin_PackDebugFiles(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__AgentReceiver__PackDebugFiles_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__AgentReceiver__PackDebugFiles_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__AgentReceiver__PackDebugFiles_name, ::Ice::Normal, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::__begin_PackDebugFiles(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::AgentReceiverPrx __proxy = ::VpsAgent::AgentReceiverPrx::uncheckedCast(__result->getProxy());
            bool __ret;
            try
            {
                __ret = __proxy->end_PackDebugFiles(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (bool)> _response;
    };
    return begin_PackDebugFiles(__ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::VpsAgent::AgentReceiver::end_PackDebugFiles(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__AgentReceiver__PackDebugFiles_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::Ice::Int
IceProxy::VpsAgent::AgentReceiver::FetchDebugPacket(::Ice::Int __p_index, ::VpsAgent::BinaryStream& __p_data, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__AgentReceiver__FetchDebugPacket_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__AgentReceiver__FetchDebugPacket_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_index);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_data);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::begin_FetchDebugPacket(::Ice::Int __p_index, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__AgentReceiver__FetchDebugPacket_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__AgentReceiver__FetchDebugPacket_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__AgentReceiver__FetchDebugPacket_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_index);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::__begin_FetchDebugPacket(::Ice::Int __p_index, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int, const ::VpsAgent::BinaryStream&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int, const ::VpsAgent::BinaryStream&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::AgentReceiverPrx __proxy = ::VpsAgent::AgentReceiverPrx::uncheckedCast(__result->getProxy());
            ::VpsAgent::BinaryStream __p_data;
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_FetchDebugPacket(__p_data, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_data);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int, const ::VpsAgent::BinaryStream&)> _response;
    };
    return begin_FetchDebugPacket(__p_index, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::VpsAgent::AgentReceiver::end_FetchDebugPacket(::VpsAgent::BinaryStream& __p_data, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__AgentReceiver__FetchDebugPacket_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_data);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::VpsAgent::AgentReceiver::DoRestore(const ::std::string& __p_json, const ::VpsAgent::RestorePrx& __p_prx, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__AgentReceiver__DoRestore_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__AgentReceiver__DoRestore_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_json);
        __os->write(__p_prx);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::begin_DoRestore(const ::std::string& __p_json, const ::VpsAgent::RestorePrx& __p_prx, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__AgentReceiver__DoRestore_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__AgentReceiver__DoRestore_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__AgentReceiver__DoRestore_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_json);
        __os->write(__p_prx);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::__begin_DoRestore(const ::std::string& __p_json, const ::VpsAgent::RestorePrx& __p_prx, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::AgentReceiverPrx __proxy = ::VpsAgent::AgentReceiverPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_DoRestore(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_DoRestore(__p_json, __p_prx, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::VpsAgent::AgentReceiver::end_DoRestore(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__AgentReceiver__DoRestore_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::VpsAgent::AgentReceiver::CancelRestore(const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__AgentReceiver__CancelRestore_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__AgentReceiver__CancelRestore_name, ::Ice::Idempotent, __ctx);
    __og.writeEmptyParams();
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::begin_CancelRestore(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__AgentReceiver__CancelRestore_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__AgentReceiver__CancelRestore_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__AgentReceiver__CancelRestore_name, ::Ice::Idempotent, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::__begin_CancelRestore(const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::AgentReceiverPrx __proxy = ::VpsAgent::AgentReceiverPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_CancelRestore(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_CancelRestore(__ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::VpsAgent::AgentReceiver::end_CancelRestore(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__AgentReceiver__CancelRestore_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

::Ice::Int
IceProxy::VpsAgent::AgentReceiver::GetServiceList(::Box::ServiceInfoStatusS& __p_ServiceList, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__AgentReceiver__GetServiceList_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__AgentReceiver__GetServiceList_name, ::Ice::Idempotent, __ctx);
    __og.writeEmptyParams();
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_ServiceList);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::begin_GetServiceList(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__AgentReceiver__GetServiceList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__AgentReceiver__GetServiceList_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__AgentReceiver__GetServiceList_name, ::Ice::Idempotent, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::__begin_GetServiceList(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int, const ::Box::ServiceInfoStatusS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int, const ::Box::ServiceInfoStatusS&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::AgentReceiverPrx __proxy = ::VpsAgent::AgentReceiverPrx::uncheckedCast(__result->getProxy());
            ::Box::ServiceInfoStatusS __p_ServiceList;
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_GetServiceList(__p_ServiceList, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_ServiceList);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int, const ::Box::ServiceInfoStatusS&)> _response;
    };
    return begin_GetServiceList(__ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::VpsAgent::AgentReceiver::end_GetServiceList(::Box::ServiceInfoStatusS& __p_ServiceList, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__AgentReceiver__GetServiceList_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_ServiceList);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::Ice::Int
IceProxy::VpsAgent::AgentReceiver::GetTcpListenList(const ::Box::vectorINT& __p_portList, ::Box::vectorINT& __p_pidList, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__AgentReceiver__GetTcpListenList_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__AgentReceiver__GetTcpListenList_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_portList);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_pidList);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::begin_GetTcpListenList(const ::Box::vectorINT& __p_portList, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__AgentReceiver__GetTcpListenList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__AgentReceiver__GetTcpListenList_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__AgentReceiver__GetTcpListenList_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_portList);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::__begin_GetTcpListenList(const ::Box::vectorINT& __p_portList, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int, const ::Box::vectorINT&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int, const ::Box::vectorINT&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::AgentReceiverPrx __proxy = ::VpsAgent::AgentReceiverPrx::uncheckedCast(__result->getProxy());
            ::Box::vectorINT __p_pidList;
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_GetTcpListenList(__p_pidList, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_pidList);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int, const ::Box::vectorINT&)> _response;
    };
    return begin_GetTcpListenList(__p_portList, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::VpsAgent::AgentReceiver::end_GetTcpListenList(::Box::vectorINT& __p_pidList, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__AgentReceiver__GetTcpListenList_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_pidList);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::Ice::Int
IceProxy::VpsAgent::AgentReceiver::StartServiceSync(const ::std::string& __p_ServiceName, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__AgentReceiver__StartServiceSync_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__AgentReceiver__StartServiceSync_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_ServiceName);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::begin_StartServiceSync(const ::std::string& __p_ServiceName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__AgentReceiver__StartServiceSync_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__AgentReceiver__StartServiceSync_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__AgentReceiver__StartServiceSync_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_ServiceName);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::__begin_StartServiceSync(const ::std::string& __p_ServiceName, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::AgentReceiverPrx __proxy = ::VpsAgent::AgentReceiverPrx::uncheckedCast(__result->getProxy());
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_StartServiceSync(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int)> _response;
    };
    return begin_StartServiceSync(__p_ServiceName, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::VpsAgent::AgentReceiver::end_StartServiceSync(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__AgentReceiver__StartServiceSync_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::Ice::Int
IceProxy::VpsAgent::AgentReceiver::StopServiceSync(const ::std::string& __p_ServiceName, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__AgentReceiver__StopServiceSync_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__AgentReceiver__StopServiceSync_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_ServiceName);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::begin_StopServiceSync(const ::std::string& __p_ServiceName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__AgentReceiver__StopServiceSync_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__AgentReceiver__StopServiceSync_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__AgentReceiver__StopServiceSync_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_ServiceName);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::__begin_StopServiceSync(const ::std::string& __p_ServiceName, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::AgentReceiverPrx __proxy = ::VpsAgent::AgentReceiverPrx::uncheckedCast(__result->getProxy());
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_StopServiceSync(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int)> _response;
    };
    return begin_StopServiceSync(__p_ServiceName, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::VpsAgent::AgentReceiver::end_StopServiceSync(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__AgentReceiver__StopServiceSync_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::Ice::Int
IceProxy::VpsAgent::AgentReceiver::StartHttpDServiceAsync(::Ice::Int __p_port, const ::VpsAgent::BinaryStream& __p_bs, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__AgentReceiver__StartHttpDServiceAsync_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__AgentReceiver__StartHttpDServiceAsync_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_port);
        __os->write(__p_bs);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::begin_StartHttpDServiceAsync(::Ice::Int __p_port, const ::VpsAgent::BinaryStream& __p_bs, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__AgentReceiver__StartHttpDServiceAsync_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__AgentReceiver__StartHttpDServiceAsync_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__AgentReceiver__StartHttpDServiceAsync_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_port);
        __os->write(__p_bs);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::__begin_StartHttpDServiceAsync(::Ice::Int __p_port, const ::VpsAgent::BinaryStream& __p_bs, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::AgentReceiverPrx __proxy = ::VpsAgent::AgentReceiverPrx::uncheckedCast(__result->getProxy());
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_StartHttpDServiceAsync(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int)> _response;
    };
    return begin_StartHttpDServiceAsync(__p_port, __p_bs, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::VpsAgent::AgentReceiver::end_StartHttpDServiceAsync(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__AgentReceiver__StartHttpDServiceAsync_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::Ice::Int
IceProxy::VpsAgent::AgentReceiver::GetHttpDServiceListSync(::Box::vectorINT& __p_pidList, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__AgentReceiver__GetHttpDServiceListSync_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__AgentReceiver__GetHttpDServiceListSync_name, ::Ice::Idempotent, __ctx);
    __og.writeEmptyParams();
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_pidList);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::begin_GetHttpDServiceListSync(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__AgentReceiver__GetHttpDServiceListSync_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__AgentReceiver__GetHttpDServiceListSync_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__AgentReceiver__GetHttpDServiceListSync_name, ::Ice::Idempotent, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::__begin_GetHttpDServiceListSync(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int, const ::Box::vectorINT&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int, const ::Box::vectorINT&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::AgentReceiverPrx __proxy = ::VpsAgent::AgentReceiverPrx::uncheckedCast(__result->getProxy());
            ::Box::vectorINT __p_pidList;
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_GetHttpDServiceListSync(__p_pidList, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_pidList);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int, const ::Box::vectorINT&)> _response;
    };
    return begin_GetHttpDServiceListSync(__ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::VpsAgent::AgentReceiver::end_GetHttpDServiceListSync(::Box::vectorINT& __p_pidList, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__AgentReceiver__GetHttpDServiceListSync_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_pidList);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::Ice::Int
IceProxy::VpsAgent::AgentReceiver::StopAllHttpDServiceSync(const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__AgentReceiver__StopAllHttpDServiceSync_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__AgentReceiver__StopAllHttpDServiceSync_name, ::Ice::Idempotent, __ctx);
    __og.writeEmptyParams();
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::begin_StopAllHttpDServiceSync(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__AgentReceiver__StopAllHttpDServiceSync_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__AgentReceiver__StopAllHttpDServiceSync_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__AgentReceiver__StopAllHttpDServiceSync_name, ::Ice::Idempotent, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::__begin_StopAllHttpDServiceSync(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::AgentReceiverPrx __proxy = ::VpsAgent::AgentReceiverPrx::uncheckedCast(__result->getProxy());
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_StopAllHttpDServiceSync(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int)> _response;
    };
    return begin_StopAllHttpDServiceSync(__ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::VpsAgent::AgentReceiver::end_StopAllHttpDServiceSync(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__AgentReceiver__StopAllHttpDServiceSync_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::Ice::Int
IceProxy::VpsAgent::AgentReceiver::testdisk(::Ice::Int __p_diskIndex, ::Ice::Long __p_sectorOffset, ::Ice::Short __p_numberOfSectors, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__AgentReceiver__testdisk_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__AgentReceiver__testdisk_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_diskIndex);
        __os->write(__p_sectorOffset);
        __os->write(__p_numberOfSectors);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::begin_testdisk(::Ice::Int __p_diskIndex, ::Ice::Long __p_sectorOffset, ::Ice::Short __p_numberOfSectors, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__AgentReceiver__testdisk_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__AgentReceiver__testdisk_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__AgentReceiver__testdisk_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_diskIndex);
        __os->write(__p_sectorOffset);
        __os->write(__p_numberOfSectors);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::__begin_testdisk(::Ice::Int __p_diskIndex, ::Ice::Long __p_sectorOffset, ::Ice::Short __p_numberOfSectors, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::AgentReceiverPrx __proxy = ::VpsAgent::AgentReceiverPrx::uncheckedCast(__result->getProxy());
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_testdisk(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int)> _response;
    };
    return begin_testdisk(__p_diskIndex, __p_sectorOffset, __p_numberOfSectors, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::VpsAgent::AgentReceiver::end_testdisk(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__AgentReceiver__testdisk_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::Ice::Int
IceProxy::VpsAgent::AgentReceiver::readdisk(::Ice::Int __p_diskIndex, ::Ice::Long __p_sectorOffset, ::Ice::Short __p_numberOfSectors, ::VpsAgent::BinaryStream& __p_bs, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__AgentReceiver__readdisk_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__AgentReceiver__readdisk_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_diskIndex);
        __os->write(__p_sectorOffset);
        __os->write(__p_numberOfSectors);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_bs);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::begin_readdisk(::Ice::Int __p_diskIndex, ::Ice::Long __p_sectorOffset, ::Ice::Short __p_numberOfSectors, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__AgentReceiver__readdisk_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__AgentReceiver__readdisk_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__AgentReceiver__readdisk_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_diskIndex);
        __os->write(__p_sectorOffset);
        __os->write(__p_numberOfSectors);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::__begin_readdisk(::Ice::Int __p_diskIndex, ::Ice::Long __p_sectorOffset, ::Ice::Short __p_numberOfSectors, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int, const ::VpsAgent::BinaryStream&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int, const ::VpsAgent::BinaryStream&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::AgentReceiverPrx __proxy = ::VpsAgent::AgentReceiverPrx::uncheckedCast(__result->getProxy());
            ::VpsAgent::BinaryStream __p_bs;
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_readdisk(__p_bs, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_bs);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int, const ::VpsAgent::BinaryStream&)> _response;
    };
    return begin_readdisk(__p_diskIndex, __p_sectorOffset, __p_numberOfSectors, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::VpsAgent::AgentReceiver::end_readdisk(::VpsAgent::BinaryStream& __p_bs, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__AgentReceiver__readdisk_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_bs);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::Ice::Int
IceProxy::VpsAgent::AgentReceiver::writedisk(::Ice::Int __p_diskIndex, ::Ice::Long __p_sectorOffset, ::Ice::Short __p_numberOfSector, const ::VpsAgent::BinaryStream& __p_bs, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__AgentReceiver__writedisk_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__AgentReceiver__writedisk_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_diskIndex);
        __os->write(__p_sectorOffset);
        __os->write(__p_numberOfSector);
        __os->write(__p_bs);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::begin_writedisk(::Ice::Int __p_diskIndex, ::Ice::Long __p_sectorOffset, ::Ice::Short __p_numberOfSector, const ::VpsAgent::BinaryStream& __p_bs, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__AgentReceiver__writedisk_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__AgentReceiver__writedisk_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__AgentReceiver__writedisk_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_diskIndex);
        __os->write(__p_sectorOffset);
        __os->write(__p_numberOfSector);
        __os->write(__p_bs);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::__begin_writedisk(::Ice::Int __p_diskIndex, ::Ice::Long __p_sectorOffset, ::Ice::Short __p_numberOfSector, const ::VpsAgent::BinaryStream& __p_bs, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::AgentReceiverPrx __proxy = ::VpsAgent::AgentReceiverPrx::uncheckedCast(__result->getProxy());
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_writedisk(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int)> _response;
    };
    return begin_writedisk(__p_diskIndex, __p_sectorOffset, __p_numberOfSector, __p_bs, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::VpsAgent::AgentReceiver::end_writedisk(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__AgentReceiver__writedisk_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::std::string
IceProxy::VpsAgent::AgentReceiver::JsonFuncV2(const ::std::string& __p_inputJson, const ::VpsAgent::BinaryStream& __p_inputBs, ::VpsAgent::BinaryStream& __p_outputBs, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__AgentReceiver__JsonFuncV2_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__AgentReceiver__JsonFuncV2_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_inputJson);
        __os->write(__p_inputBs);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_outputBs);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::begin_JsonFuncV2(const ::std::string& __p_inputJson, const ::VpsAgent::BinaryStream& __p_inputBs, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__AgentReceiver__JsonFuncV2_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__AgentReceiver__JsonFuncV2_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__AgentReceiver__JsonFuncV2_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_inputJson);
        __os->write(__p_inputBs);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::AgentReceiver::__begin_JsonFuncV2(const ::std::string& __p_inputJson, const ::VpsAgent::BinaryStream& __p_inputBs, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&, const ::VpsAgent::BinaryStream&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&, const ::VpsAgent::BinaryStream&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::AgentReceiverPrx __proxy = ::VpsAgent::AgentReceiverPrx::uncheckedCast(__result->getProxy());
            ::VpsAgent::BinaryStream __p_outputBs;
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_JsonFuncV2(__p_outputBs, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_outputBs);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&, const ::VpsAgent::BinaryStream&)> _response;
    };
    return begin_JsonFuncV2(__p_inputJson, __p_inputBs, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::VpsAgent::AgentReceiver::end_JsonFuncV2(::VpsAgent::BinaryStream& __p_outputBs, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__AgentReceiver__JsonFuncV2_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_outputBs);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

const ::std::string&
IceProxy::VpsAgent::AgentReceiver::ice_staticId()
{
    return ::VpsAgent::AgentReceiver::ice_staticId();
}

::IceProxy::Ice::Object*
IceProxy::VpsAgent::AgentReceiver::__newInstance() const
{
    return new AgentReceiver;
}
::IceProxy::Ice::Object* ::IceProxy::VpsAgent::upCast(::IceProxy::VpsAgent::Session* p) { return p; }

void
::IceProxy::VpsAgent::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::VpsAgent::Session>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::VpsAgent::Session;
        v->__copyFrom(proxy);
    }
}

::std::string
IceProxy::VpsAgent::Session::QueryName(const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__Session__QueryName_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__Session__QueryName_name, ::Ice::Idempotent, __ctx);
    __og.writeEmptyParams();
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Session::begin_QueryName(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__Session__QueryName_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__Session__QueryName_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__Session__QueryName_name, ::Ice::Idempotent, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Session::__begin_QueryName(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::SessionPrx __proxy = ::VpsAgent::SessionPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_QueryName(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_QueryName(__ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::VpsAgent::Session::end_QueryName(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__Session__QueryName_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::std::string
IceProxy::VpsAgent::Session::QueryIdentity(const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__Session__QueryIdentity_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__Session__QueryIdentity_name, ::Ice::Idempotent, __ctx);
    __og.writeEmptyParams();
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Session::begin_QueryIdentity(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__Session__QueryIdentity_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__Session__QueryIdentity_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__Session__QueryIdentity_name, ::Ice::Idempotent, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Session::__begin_QueryIdentity(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::SessionPrx __proxy = ::VpsAgent::SessionPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_QueryIdentity(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_QueryIdentity(__ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::VpsAgent::Session::end_QueryIdentity(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__Session__QueryIdentity_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::std::string
IceProxy::VpsAgent::Session::QuerySoftIdent(const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__Session__QuerySoftIdent_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__Session__QuerySoftIdent_name, ::Ice::Idempotent, __ctx);
    __og.writeEmptyParams();
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Session::begin_QuerySoftIdent(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__Session__QuerySoftIdent_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__Session__QuerySoftIdent_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__Session__QuerySoftIdent_name, ::Ice::Idempotent, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Session::__begin_QuerySoftIdent(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::SessionPrx __proxy = ::VpsAgent::SessionPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_QuerySoftIdent(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_QuerySoftIdent(__ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::VpsAgent::Session::end_QuerySoftIdent(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__Session__QuerySoftIdent_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::std::string
IceProxy::VpsAgent::Session::QueryJsonData(const ::std::string& __p_inputJson, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__Session__QueryJsonData_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__Session__QueryJsonData_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_inputJson);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Session::begin_QueryJsonData(const ::std::string& __p_inputJson, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__Session__QueryJsonData_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__Session__QueryJsonData_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__Session__QueryJsonData_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_inputJson);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Session::__begin_QueryJsonData(const ::std::string& __p_inputJson, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::SessionPrx __proxy = ::VpsAgent::SessionPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_QueryJsonData(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_QueryJsonData(__p_inputJson, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::VpsAgent::Session::end_QueryJsonData(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__Session__QueryJsonData_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::VpsAgent::Session::destroy(const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __VpsAgent__Session__destroy_name, ::Ice::Normal, __ctx);
    __og.writeEmptyParams();
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Session::begin_destroy(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__Session__destroy_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__Session__destroy_name, ::Ice::Normal, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::VpsAgent::Session::end_destroy(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __VpsAgent__Session__destroy_name);
}

void
IceProxy::VpsAgent::Session::initiateReceiver(const ::Ice::Identity& __p_ident, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__Session__initiateReceiver_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__Session__initiateReceiver_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_ident);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Session::begin_initiateReceiver(const ::Ice::Identity& __p_ident, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__Session__initiateReceiver_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__Session__initiateReceiver_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__Session__initiateReceiver_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_ident);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Session::__begin_initiateReceiver(const ::Ice::Identity& __p_ident, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::SessionPrx __proxy = ::VpsAgent::SessionPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_initiateReceiver(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_initiateReceiver(__p_ident, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::VpsAgent::Session::end_initiateReceiver(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__Session__initiateReceiver_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::VpsAgent::Session::refresh(const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __VpsAgent__Session__refresh_name, ::Ice::Idempotent, __ctx);
    __og.writeEmptyParams();
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Session::begin_refresh(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__Session__refresh_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__Session__refresh_name, ::Ice::Idempotent, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::VpsAgent::Session::end_refresh(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __VpsAgent__Session__refresh_name);
}

void
IceProxy::VpsAgent::Session::reportRestoreStatus(const ::std::string& __p_token, const ::BoxLogic::RestoreProgress& __p_progress, bool __p_finished, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__Session__reportRestoreStatus_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__Session__reportRestoreStatus_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_token);
        __os->write(__p_progress);
        __os->write(__p_finished);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Session::begin_reportRestoreStatus(const ::std::string& __p_token, const ::BoxLogic::RestoreProgress& __p_progress, bool __p_finished, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__Session__reportRestoreStatus_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__Session__reportRestoreStatus_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__Session__reportRestoreStatus_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_token);
        __os->write(__p_progress);
        __os->write(__p_finished);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Session::__begin_reportRestoreStatus(const ::std::string& __p_token, const ::BoxLogic::RestoreProgress& __p_progress, bool __p_finished, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::SessionPrx __proxy = ::VpsAgent::SessionPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_reportRestoreStatus(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_reportRestoreStatus(__p_token, __p_progress, __p_finished, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::VpsAgent::Session::end_reportRestoreStatus(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__Session__reportRestoreStatus_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

::BoxLogic::LastCdpDetail
IceProxy::VpsAgent::Session::queryLastCdpDetailByRestoreToken(const ::std::string& __p_token, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__Session__queryLastCdpDetailByRestoreToken_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__Session__queryLastCdpDetailByRestoreToken_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_token);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::BoxLogic::LastCdpDetail __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Session::begin_queryLastCdpDetailByRestoreToken(const ::std::string& __p_token, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__Session__queryLastCdpDetailByRestoreToken_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__Session__queryLastCdpDetailByRestoreToken_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__Session__queryLastCdpDetailByRestoreToken_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_token);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Session::__begin_queryLastCdpDetailByRestoreToken(const ::std::string& __p_token, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::BoxLogic::LastCdpDetail&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::BoxLogic::LastCdpDetail&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::SessionPrx __proxy = ::VpsAgent::SessionPrx::uncheckedCast(__result->getProxy());
            ::BoxLogic::LastCdpDetail __ret;
            try
            {
                __ret = __proxy->end_queryLastCdpDetailByRestoreToken(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::BoxLogic::LastCdpDetail&)> _response;
    };
    return begin_queryLastCdpDetailByRestoreToken(__p_token, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::BoxLogic::LastCdpDetail
IceProxy::VpsAgent::Session::end_queryLastCdpDetailByRestoreToken(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__Session__queryLastCdpDetailByRestoreToken_name);
    ::BoxLogic::LastCdpDetail __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

bool
IceProxy::VpsAgent::Session::queryLastCdpDetailByCdpToken(const ::std::string& __p_token, ::BoxLogic::LastCdpDetail& __p_detail, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__Session__queryLastCdpDetailByCdpToken_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__Session__queryLastCdpDetailByCdpToken_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_token);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_detail);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Session::begin_queryLastCdpDetailByCdpToken(const ::std::string& __p_token, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__Session__queryLastCdpDetailByCdpToken_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__Session__queryLastCdpDetailByCdpToken_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__Session__queryLastCdpDetailByCdpToken_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_token);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Session::__begin_queryLastCdpDetailByCdpToken(const ::std::string& __p_token, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool, const ::BoxLogic::LastCdpDetail&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool, const ::BoxLogic::LastCdpDetail&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::SessionPrx __proxy = ::VpsAgent::SessionPrx::uncheckedCast(__result->getProxy());
            ::BoxLogic::LastCdpDetail __p_detail;
            bool __ret;
            try
            {
                __ret = __proxy->end_queryLastCdpDetailByCdpToken(__p_detail, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_detail);
            }
        }
    
    private:
        
        ::std::function<void (bool, const ::BoxLogic::LastCdpDetail&)> _response;
    };
    return begin_queryLastCdpDetailByCdpToken(__p_token, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::VpsAgent::Session::end_queryLastCdpDetailByCdpToken(::BoxLogic::LastCdpDetail& __p_detail, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__Session__queryLastCdpDetailByCdpToken_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_detail);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::VpsAgent::Session::setPreReadBitmap(const ::std::string& __p_token, ::Ice::Long __p_index, const ::VpsAgent::BinaryStream& __p_bitmap, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__Session__setPreReadBitmap_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__Session__setPreReadBitmap_name, ::Ice::Idempotent, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_token);
        __os->write(__p_index);
        __os->write(__p_bitmap);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Session::begin_setPreReadBitmap(const ::std::string& __p_token, ::Ice::Long __p_index, const ::VpsAgent::BinaryStream& __p_bitmap, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__Session__setPreReadBitmap_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__Session__setPreReadBitmap_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__Session__setPreReadBitmap_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_token);
        __os->write(__p_index);
        __os->write(__p_bitmap);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::Session::__begin_setPreReadBitmap(const ::std::string& __p_token, ::Ice::Long __p_index, const ::VpsAgent::BinaryStream& __p_bitmap, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::SessionPrx __proxy = ::VpsAgent::SessionPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_setPreReadBitmap(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_setPreReadBitmap(__p_token, __p_index, __p_bitmap, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::VpsAgent::Session::end_setPreReadBitmap(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__Session__setPreReadBitmap_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

const ::std::string&
IceProxy::VpsAgent::Session::ice_staticId()
{
    return ::VpsAgent::Session::ice_staticId();
}

::IceProxy::Ice::Object*
IceProxy::VpsAgent::Session::__newInstance() const
{
    return new Session;
}
::IceProxy::Ice::Object* ::IceProxy::VpsAgent::upCast(::IceProxy::VpsAgent::SessionFactory* p) { return p; }

void
::IceProxy::VpsAgent::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::VpsAgent::SessionFactory>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::VpsAgent::SessionFactory;
        v->__copyFrom(proxy);
    }
}

::VpsAgent::SessionPrx
IceProxy::VpsAgent::SessionFactory::create(const ::VpsAgent::AgentIdentification& __p_id, const ::std::string& __p_info, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__VpsAgent__SessionFactory__create_name);
    ::IceInternal::Outgoing __og(this, __VpsAgent__SessionFactory__create_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_id);
        __os->write(__p_info);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::VpsAgent::SessionPrx __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::VpsAgent::SessionFactory::begin_create(const ::VpsAgent::AgentIdentification& __p_id, const ::std::string& __p_info, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__VpsAgent__SessionFactory__create_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __VpsAgent__SessionFactory__create_name, __del, __cookie);
    try
    {
        __result->prepare(__VpsAgent__SessionFactory__create_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_id);
        __os->write(__p_info);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::VpsAgent::SessionFactory::__begin_create(const ::VpsAgent::AgentIdentification& __p_id, const ::std::string& __p_info, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::VpsAgent::SessionPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::VpsAgent::SessionPrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::VpsAgent::SessionFactoryPrx __proxy = ::VpsAgent::SessionFactoryPrx::uncheckedCast(__result->getProxy());
            ::VpsAgent::SessionPrx __ret;
            try
            {
                __ret = __proxy->end_create(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::VpsAgent::SessionPrx&)> _response;
    };
    return begin_create(__p_id, __p_info, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::VpsAgent::SessionPrx
IceProxy::VpsAgent::SessionFactory::end_create(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __VpsAgent__SessionFactory__create_name);
    ::VpsAgent::SessionPrx __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

const ::std::string&
IceProxy::VpsAgent::SessionFactory::ice_staticId()
{
    return ::VpsAgent::SessionFactory::ice_staticId();
}

::IceProxy::Ice::Object*
IceProxy::VpsAgent::SessionFactory::__newInstance() const
{
    return new SessionFactory;
}

::Ice::Object* VpsAgent::upCast(::VpsAgent::Services* p) { return p; }

namespace
{
const ::std::string __VpsAgent__Services_ids[2] =
{
    "::Ice::Object",
    "::VpsAgent::Services"
};

}

bool
VpsAgent::Services::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__VpsAgent__Services_ids, __VpsAgent__Services_ids + 2, _s);
}

::std::vector< ::std::string>
VpsAgent::Services::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__VpsAgent__Services_ids[0], &__VpsAgent__Services_ids[2]);
}

const ::std::string&
VpsAgent::Services::ice_id(const ::Ice::Current&) const
{
    return __VpsAgent__Services_ids[1];
}

const ::std::string&
VpsAgent::Services::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::VpsAgent::Services";
    return typeId;
#else
    return __VpsAgent__Services_ids[1];
#endif
}

::Ice::DispatchStatus
VpsAgent::Services::___ping(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ping(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __VpsAgent__Services_all[] =
{
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "ping"
};

}

::Ice::DispatchStatus
VpsAgent::Services::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__VpsAgent__Services_all, __VpsAgent__Services_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __VpsAgent__Services_all)
    {
        case 0:
        {
            return ___ice_id(in, current);
        }
        case 1:
        {
            return ___ice_ids(in, current);
        }
        case 2:
        {
            return ___ice_isA(in, current);
        }
        case 3:
        {
            return ___ice_ping(in, current);
        }
        case 4:
        {
            return ___ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
VpsAgent::Services::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
VpsAgent::Services::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
VpsAgent::__patch(ServicesPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::VpsAgent::ServicesPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::VpsAgent::Services::ice_staticId(), v);
    }
}

::Ice::Object* VpsAgent::upCast(::VpsAgent::Backup* p) { return p; }

namespace
{
const ::std::string __VpsAgent__Backup_ids[2] =
{
    "::Ice::Object",
    "::VpsAgent::Backup"
};

}

bool
VpsAgent::Backup::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__VpsAgent__Backup_ids, __VpsAgent__Backup_ids + 2, _s);
}

::std::vector< ::std::string>
VpsAgent::Backup::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__VpsAgent__Backup_ids[0], &__VpsAgent__Backup_ids[2]);
}

const ::std::string&
VpsAgent::Backup::ice_id(const ::Ice::Current&) const
{
    return __VpsAgent__Backup_ids[1];
}

const ::std::string&
VpsAgent::Backup::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::VpsAgent::Backup";
    return typeId;
#else
    return __VpsAgent__Backup_ids[1];
#endif
}

::Ice::DispatchStatus
VpsAgent::Backup::___PostSectorData(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int __p_diskIndex;
    ::VpsAgent::SectorRange __p_range;
    ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> __p_data;
    __is->read(__p_diskIndex);
    __is->read(__p_range);
    __is->read(__p_data);
    __inS.endReadParams();
    try
    {
        PostSectorData(__p_diskIndex, __p_range, __p_data, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::Backup::___PostSectorDataEx(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int __p_type;
    ::Ice::Int __p_diskIndex;
    ::VpsAgent::SectorRange __p_range;
    ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> __p_data;
    __is->read(__p_type);
    __is->read(__p_diskIndex);
    __is->read(__p_range);
    __is->read(__p_data);
    __inS.endReadParams();
    try
    {
        PostSectorDataEx(__p_type, __p_diskIndex, __p_range, __p_data, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::Backup::___PostSectorDataExV2(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::VpsAgent::PostSectors __p_sectors;
    ::std::pair<const ::Ice::Byte*, const ::Ice::Byte*> __p_data;
    __is->read(__p_sectors);
    __is->read(__p_data);
    __inS.endReadParams();
    try
    {
        PostSectorDataExV2(__p_sectors, __p_data, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::Backup::___PostBakDataExt(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::VpsAgent::PostExtDataVector __p_extDataVector;
    __is->read(__p_extDataVector);
    __inS.endReadParams();
    try
    {
        PostBakDataExt(__p_extDataVector, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::Backup::___GetBakDataExt(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::VpsAgent::GetExtDataVector __p_extTypeVector;
    __is->read(__p_extTypeVector);
    __inS.endReadParams();
    ::VpsAgent::PostExtDataVector __p_extDataVector;
    try
    {
        bool __ret = GetBakDataExt(__p_extTypeVector, __p_extDataVector, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_extDataVector);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::Backup::___PostUsedBlockBitmap(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int __p_diskIndex;
    ::VpsAgent::BinaryStream __p_bitmap;
    bool __p_completed;
    __is->read(__p_diskIndex);
    __is->read(__p_bitmap);
    __is->read(__p_completed);
    __inS.endReadParams();
    try
    {
        PostUsedBlockBitmap(__p_diskIndex, __p_bitmap, __p_completed, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::Backup::___PostDuplicateFileSectors(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int __p_diskIndex;
    ::IMG::DuplicateFileSectors __p_sectors;
    bool __p_completed;
    __is->read(__p_diskIndex);
    __is->read(__p_sectors);
    __is->read(__p_completed);
    __inS.endReadParams();
    try
    {
        PostDuplicateFileSectors(__p_diskIndex, __p_sectors, __p_completed, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::Backup::___PostCurrentFileList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::VpsAgent::BinaryStream __p_bitmap;
    bool __p_completed;
    __is->read(__p_bitmap);
    __is->read(__p_completed);
    __inS.endReadParams();
    try
    {
        PostCurrentFileList(__p_bitmap, __p_completed, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::Backup::___GetFileListFromDuplicateFilePool(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::VpsAgent::BinaryStream __p_bitmap;
    try
    {
        bool __ret = GetFileListFromDuplicateFilePool(__p_bitmap, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_bitmap);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::NeedRetryLaterError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::Backup::___ReportStatus(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::BoxLogic::BackupProgress __p_progress;
    __is->read(__p_progress);
    __inS.endReadParams();
    try
    {
        ReportStatus(__p_progress, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::Backup::___Exit(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::BoxLogic::BackupFinishCode __p_code;
    __is->read(__p_code);
    __inS.endReadParams();
    try
    {
        Exit(__p_code, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __VpsAgent__Backup_all[] =
{
    "Exit",
    "GetBakDataExt",
    "GetFileListFromDuplicateFilePool",
    "PostBakDataExt",
    "PostCurrentFileList",
    "PostDuplicateFileSectors",
    "PostSectorData",
    "PostSectorDataEx",
    "PostSectorDataExV2",
    "PostUsedBlockBitmap",
    "ReportStatus",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
VpsAgent::Backup::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__VpsAgent__Backup_all, __VpsAgent__Backup_all + 15, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __VpsAgent__Backup_all)
    {
        case 0:
        {
            return ___Exit(in, current);
        }
        case 1:
        {
            return ___GetBakDataExt(in, current);
        }
        case 2:
        {
            return ___GetFileListFromDuplicateFilePool(in, current);
        }
        case 3:
        {
            return ___PostBakDataExt(in, current);
        }
        case 4:
        {
            return ___PostCurrentFileList(in, current);
        }
        case 5:
        {
            return ___PostDuplicateFileSectors(in, current);
        }
        case 6:
        {
            return ___PostSectorData(in, current);
        }
        case 7:
        {
            return ___PostSectorDataEx(in, current);
        }
        case 8:
        {
            return ___PostSectorDataExV2(in, current);
        }
        case 9:
        {
            return ___PostUsedBlockBitmap(in, current);
        }
        case 10:
        {
            return ___ReportStatus(in, current);
        }
        case 11:
        {
            return ___ice_id(in, current);
        }
        case 12:
        {
            return ___ice_ids(in, current);
        }
        case 13:
        {
            return ___ice_isA(in, current);
        }
        case 14:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
VpsAgent::Backup::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
VpsAgent::Backup::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
VpsAgent::__patch(BackupPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::VpsAgent::BackupPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::VpsAgent::Backup::ice_staticId(), v);
    }
}

::Ice::Object* VpsAgent::upCast(::VpsAgent::Restore* p) { return p; }

namespace
{
const ::std::string __VpsAgent__Restore_ids[2] =
{
    "::Ice::Object",
    "::VpsAgent::Restore"
};

}

bool
VpsAgent::Restore::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__VpsAgent__Restore_ids, __VpsAgent__Restore_ids + 2, _s);
}

::std::vector< ::std::string>
VpsAgent::Restore::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__VpsAgent__Restore_ids[0], &__VpsAgent__Restore_ids[2]);
}

const ::std::string&
VpsAgent::Restore::ice_id(const ::Ice::Current&) const
{
    return __VpsAgent__Restore_ids[1];
}

const ::std::string&
VpsAgent::Restore::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::VpsAgent::Restore";
    return typeId;
#else
    return __VpsAgent__Restore_ids[1];
#endif
}

::Ice::DispatchStatus
VpsAgent::Restore::___getUesdBlockBitmap(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_token;
    ::Ice::Int __p_index;
    __is->read(__p_token);
    __is->read(__p_index);
    __inS.endReadParams();
    ::VpsAgent::BinaryStream __p_bitmap;
    try
    {
        ::Ice::Int __ret = getUesdBlockBitmap(__p_token, __p_index, __p_bitmap, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_bitmap);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::Restore::___reportStatus(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::BoxLogic::RestoreStageCode __p_code;
    ::std::string __p_msg;
    ::std::string __p_debug;
    __is->read(__p_code);
    __is->read(__p_msg);
    __is->read(__p_debug);
    __inS.endReadParams();
    try
    {
        reportStatus(__p_code, __p_msg, __p_debug, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __VpsAgent__Restore_all[] =
{
    "getUesdBlockBitmap",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "reportStatus"
};

}

::Ice::DispatchStatus
VpsAgent::Restore::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__VpsAgent__Restore_all, __VpsAgent__Restore_all + 6, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __VpsAgent__Restore_all)
    {
        case 0:
        {
            return ___getUesdBlockBitmap(in, current);
        }
        case 1:
        {
            return ___ice_id(in, current);
        }
        case 2:
        {
            return ___ice_ids(in, current);
        }
        case 3:
        {
            return ___ice_isA(in, current);
        }
        case 4:
        {
            return ___ice_ping(in, current);
        }
        case 5:
        {
            return ___reportStatus(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
VpsAgent::Restore::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
VpsAgent::Restore::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
VpsAgent::__patch(RestorePtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::VpsAgent::RestorePtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::VpsAgent::Restore::ice_staticId(), v);
    }
}

::Ice::Object* VpsAgent::upCast(::VpsAgent::AgentReceiver* p) { return p; }

namespace
{
const ::std::string __VpsAgent__AgentReceiver_ids[2] =
{
    "::Ice::Object",
    "::VpsAgent::AgentReceiver"
};

}

bool
VpsAgent::AgentReceiver::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__VpsAgent__AgentReceiver_ids, __VpsAgent__AgentReceiver_ids + 2, _s);
}

::std::vector< ::std::string>
VpsAgent::AgentReceiver::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__VpsAgent__AgentReceiver_ids[0], &__VpsAgent__AgentReceiver_ids[2]);
}

const ::std::string&
VpsAgent::AgentReceiver::ice_id(const ::Ice::Current&) const
{
    return __VpsAgent__AgentReceiver_ids[1];
}

const ::std::string&
VpsAgent::AgentReceiver::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::VpsAgent::AgentReceiver";
    return typeId;
#else
    return __VpsAgent__AgentReceiver_ids[1];
#endif
}

::Ice::DispatchStatus
VpsAgent::AgentReceiver::___check(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    try
    {
        check(__current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::VpsAgent::AgentModuleError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::AgentReceiver::___JsonFunc(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_InputParam;
    __is->read(__p_InputParam);
    __inS.endReadParams();
    try
    {
        ::std::string __ret = JsonFunc(__p_InputParam, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::AgentReceiver::___QuerySystemInfo(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    try
    {
        ::std::string __ret = QuerySystemInfo(__current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::AgentReceiver::___QueryDisksStatus(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::BoxLogic::Disks __p_disks;
    IceUtil::Optional< ::std::string> __p_more;
    try
    {
        QueryDisksStatus(__p_disks, __p_more, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_disks);
        __os->write(1, __p_more);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::AgentReceiver::___DoBackup(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::VpsAgent::SnapshotNames __p_snapshots;
    ::VpsAgent::BackupPrx __p_prx;
    __is->read(__p_snapshots);
    __is->read(__p_prx);
    __inS.endReadParams();
    try
    {
        DoBackup(__p_snapshots, __p_prx, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::AgentReceiver::___DoBackupEx(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::VpsAgent::SnapshotNames __p_snapshots;
    ::VpsAgent::SnapshotConfigs __p_configs;
    ::VpsAgent::BackupPrx __p_prx;
    IceUtil::Optional< ::std::string> __p_jsonConfig;
    __is->read(__p_snapshots);
    __is->read(__p_configs);
    __is->read(__p_prx);
    __is->read(1, __p_jsonConfig);
    __inS.endReadParams();
    try
    {
        DoBackupEx(__p_snapshots, __p_configs, __p_prx, __p_jsonConfig, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::AgentReceiver::___GetLastBackupError(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::std::string __ret = GetLastBackupError(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
VpsAgent::AgentReceiver::___GetLastCdpError(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::std::string __ret = GetLastCdpError(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
VpsAgent::AgentReceiver::___StartAgentPe(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::std::string __p_peHostIdent;
    try
    {
        ::Ice::Int __ret = StartAgentPe(__p_peHostIdent, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_peHostIdent);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::AgentReceiver::___CancelBackup(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    try
    {
        CancelBackup(__current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::AgentReceiver::___NotifyHighPriority(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_diskIdent;
    ::Ice::Long __p_byteOffset;
    __is->read(__p_diskIdent);
    __is->read(__p_byteOffset);
    __inS.endReadParams();
    try
    {
        NotifyHighPriority(__p_diskIdent, __p_byteOffset, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::AgentReceiver::___GetStatus(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::BoxLogic::AgentStatus __ret = GetStatus(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
VpsAgent::AgentReceiver::___StopCdpStatus(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    StopCdpStatus(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
VpsAgent::AgentReceiver::___PackDebugFiles(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    bool __ret = PackDebugFiles(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
VpsAgent::AgentReceiver::___FetchDebugPacket(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int __p_index;
    __is->read(__p_index);
    __inS.endReadParams();
    ::VpsAgent::BinaryStream __p_data;
    ::Ice::Int __ret = FetchDebugPacket(__p_index, __p_data, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__p_data);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
VpsAgent::AgentReceiver::___DoRestore(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_json;
    ::VpsAgent::RestorePrx __p_prx;
    __is->read(__p_json);
    __is->read(__p_prx);
    __inS.endReadParams();
    try
    {
        DoRestore(__p_json, __p_prx, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::AgentReceiver::___CancelRestore(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    try
    {
        CancelRestore(__current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::AgentReceiver::___GetServiceList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::Box::ServiceInfoStatusS __p_ServiceList;
    try
    {
        ::Ice::Int __ret = GetServiceList(__p_ServiceList, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_ServiceList);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::AgentReceiver::___GetTcpListenList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Box::vectorINT __p_portList;
    __is->read(__p_portList);
    __inS.endReadParams();
    ::Box::vectorINT __p_pidList;
    try
    {
        ::Ice::Int __ret = GetTcpListenList(__p_portList, __p_pidList, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_pidList);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::AgentReceiver::___StartServiceSync(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_ServiceName;
    __is->read(__p_ServiceName);
    __inS.endReadParams();
    try
    {
        ::Ice::Int __ret = StartServiceSync(__p_ServiceName, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::AgentReceiver::___StopServiceSync(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_ServiceName;
    __is->read(__p_ServiceName);
    __inS.endReadParams();
    try
    {
        ::Ice::Int __ret = StopServiceSync(__p_ServiceName, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::AgentReceiver::___StartHttpDServiceAsync(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int __p_port;
    ::VpsAgent::BinaryStream __p_bs;
    __is->read(__p_port);
    __is->read(__p_bs);
    __inS.endReadParams();
    try
    {
        ::Ice::Int __ret = StartHttpDServiceAsync(__p_port, __p_bs, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::AgentReceiver::___GetHttpDServiceListSync(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::Box::vectorINT __p_pidList;
    try
    {
        ::Ice::Int __ret = GetHttpDServiceListSync(__p_pidList, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_pidList);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::AgentReceiver::___StopAllHttpDServiceSync(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    try
    {
        ::Ice::Int __ret = StopAllHttpDServiceSync(__current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::AgentReceiver::___testdisk(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int __p_diskIndex;
    ::Ice::Long __p_sectorOffset;
    ::Ice::Short __p_numberOfSectors;
    __is->read(__p_diskIndex);
    __is->read(__p_sectorOffset);
    __is->read(__p_numberOfSectors);
    __inS.endReadParams();
    try
    {
        ::Ice::Int __ret = testdisk(__p_diskIndex, __p_sectorOffset, __p_numberOfSectors, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::AgentReceiver::___readdisk(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int __p_diskIndex;
    ::Ice::Long __p_sectorOffset;
    ::Ice::Short __p_numberOfSectors;
    __is->read(__p_diskIndex);
    __is->read(__p_sectorOffset);
    __is->read(__p_numberOfSectors);
    __inS.endReadParams();
    ::VpsAgent::BinaryStream __p_bs;
    try
    {
        ::Ice::Int __ret = readdisk(__p_diskIndex, __p_sectorOffset, __p_numberOfSectors, __p_bs, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_bs);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::AgentReceiver::___writedisk(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int __p_diskIndex;
    ::Ice::Long __p_sectorOffset;
    ::Ice::Short __p_numberOfSector;
    ::VpsAgent::BinaryStream __p_bs;
    __is->read(__p_diskIndex);
    __is->read(__p_sectorOffset);
    __is->read(__p_numberOfSector);
    __is->read(__p_bs);
    __inS.endReadParams();
    try
    {
        ::Ice::Int __ret = writedisk(__p_diskIndex, __p_sectorOffset, __p_numberOfSector, __p_bs, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::AgentReceiver::___JsonFuncV2(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_inputJson;
    ::VpsAgent::BinaryStream __p_inputBs;
    __is->read(__p_inputJson);
    __is->read(__p_inputBs);
    __inS.endReadParams();
    ::VpsAgent::BinaryStream __p_outputBs;
    try
    {
        ::std::string __ret = JsonFuncV2(__p_inputJson, __p_inputBs, __p_outputBs, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_outputBs);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __VpsAgent__AgentReceiver_all[] =
{
    "CancelBackup",
    "CancelRestore",
    "DoBackup",
    "DoBackupEx",
    "DoRestore",
    "FetchDebugPacket",
    "GetHttpDServiceListSync",
    "GetLastBackupError",
    "GetLastCdpError",
    "GetServiceList",
    "GetStatus",
    "GetTcpListenList",
    "JsonFunc",
    "JsonFuncV2",
    "NotifyHighPriority",
    "PackDebugFiles",
    "QueryDisksStatus",
    "QuerySystemInfo",
    "StartAgentPe",
    "StartHttpDServiceAsync",
    "StartServiceSync",
    "StopAllHttpDServiceSync",
    "StopCdpStatus",
    "StopServiceSync",
    "check",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "readdisk",
    "testdisk",
    "writedisk"
};

}

::Ice::DispatchStatus
VpsAgent::AgentReceiver::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__VpsAgent__AgentReceiver_all, __VpsAgent__AgentReceiver_all + 32, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __VpsAgent__AgentReceiver_all)
    {
        case 0:
        {
            return ___CancelBackup(in, current);
        }
        case 1:
        {
            return ___CancelRestore(in, current);
        }
        case 2:
        {
            return ___DoBackup(in, current);
        }
        case 3:
        {
            return ___DoBackupEx(in, current);
        }
        case 4:
        {
            return ___DoRestore(in, current);
        }
        case 5:
        {
            return ___FetchDebugPacket(in, current);
        }
        case 6:
        {
            return ___GetHttpDServiceListSync(in, current);
        }
        case 7:
        {
            return ___GetLastBackupError(in, current);
        }
        case 8:
        {
            return ___GetLastCdpError(in, current);
        }
        case 9:
        {
            return ___GetServiceList(in, current);
        }
        case 10:
        {
            return ___GetStatus(in, current);
        }
        case 11:
        {
            return ___GetTcpListenList(in, current);
        }
        case 12:
        {
            return ___JsonFunc(in, current);
        }
        case 13:
        {
            return ___JsonFuncV2(in, current);
        }
        case 14:
        {
            return ___NotifyHighPriority(in, current);
        }
        case 15:
        {
            return ___PackDebugFiles(in, current);
        }
        case 16:
        {
            return ___QueryDisksStatus(in, current);
        }
        case 17:
        {
            return ___QuerySystemInfo(in, current);
        }
        case 18:
        {
            return ___StartAgentPe(in, current);
        }
        case 19:
        {
            return ___StartHttpDServiceAsync(in, current);
        }
        case 20:
        {
            return ___StartServiceSync(in, current);
        }
        case 21:
        {
            return ___StopAllHttpDServiceSync(in, current);
        }
        case 22:
        {
            return ___StopCdpStatus(in, current);
        }
        case 23:
        {
            return ___StopServiceSync(in, current);
        }
        case 24:
        {
            return ___check(in, current);
        }
        case 25:
        {
            return ___ice_id(in, current);
        }
        case 26:
        {
            return ___ice_ids(in, current);
        }
        case 27:
        {
            return ___ice_isA(in, current);
        }
        case 28:
        {
            return ___ice_ping(in, current);
        }
        case 29:
        {
            return ___readdisk(in, current);
        }
        case 30:
        {
            return ___testdisk(in, current);
        }
        case 31:
        {
            return ___writedisk(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
VpsAgent::AgentReceiver::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
VpsAgent::AgentReceiver::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
VpsAgent::__patch(AgentReceiverPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::VpsAgent::AgentReceiverPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::VpsAgent::AgentReceiver::ice_staticId(), v);
    }
}

::Ice::Object* VpsAgent::upCast(::VpsAgent::Session* p) { return p; }

namespace
{
const ::std::string __VpsAgent__Session_ids[2] =
{
    "::Ice::Object",
    "::VpsAgent::Session"
};

}

bool
VpsAgent::Session::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__VpsAgent__Session_ids, __VpsAgent__Session_ids + 2, _s);
}

::std::vector< ::std::string>
VpsAgent::Session::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__VpsAgent__Session_ids[0], &__VpsAgent__Session_ids[2]);
}

const ::std::string&
VpsAgent::Session::ice_id(const ::Ice::Current&) const
{
    return __VpsAgent__Session_ids[1];
}

const ::std::string&
VpsAgent::Session::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::VpsAgent::Session";
    return typeId;
#else
    return __VpsAgent__Session_ids[1];
#endif
}

::Ice::DispatchStatus
VpsAgent::Session::___QueryName(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::std::string __ret = QueryName(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
VpsAgent::Session::___QueryIdentity(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::std::string __ret = QueryIdentity(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
VpsAgent::Session::___QuerySoftIdent(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::std::string __ret = QuerySoftIdent(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
VpsAgent::Session::___QueryJsonData(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_inputJson;
    __is->read(__p_inputJson);
    __inS.endReadParams();
    try
    {
        ::std::string __ret = QueryJsonData(__p_inputJson, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::Session::___destroy(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    destroy(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
VpsAgent::Session::___initiateReceiver(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Identity __p_ident;
    __is->read(__p_ident);
    __inS.endReadParams();
    try
    {
        initiateReceiver(__p_ident, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::Session::___refresh(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    refresh(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
VpsAgent::Session::___reportRestoreStatus(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_token;
    ::BoxLogic::RestoreProgress __p_progress;
    bool __p_finished;
    __is->read(__p_token);
    __is->read(__p_progress);
    __is->read(__p_finished);
    __inS.endReadParams();
    try
    {
        reportRestoreStatus(__p_token, __p_progress, __p_finished, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::Session::___queryLastCdpDetailByRestoreToken(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_token;
    __is->read(__p_token);
    __inS.endReadParams();
    try
    {
        ::BoxLogic::LastCdpDetail __ret = queryLastCdpDetailByRestoreToken(__p_token, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::Session::___queryLastCdpDetailByCdpToken(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_token;
    __is->read(__p_token);
    __inS.endReadParams();
    ::BoxLogic::LastCdpDetail __p_detail;
    try
    {
        bool __ret = queryLastCdpDetailByCdpToken(__p_token, __p_detail, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_detail);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
VpsAgent::Session::___setPreReadBitmap(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_token;
    ::Ice::Long __p_index;
    ::VpsAgent::BinaryStream __p_bitmap;
    __is->read(__p_token);
    __is->read(__p_index);
    __is->read(__p_bitmap);
    __inS.endReadParams();
    try
    {
        setPreReadBitmap(__p_token, __p_index, __p_bitmap, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __VpsAgent__Session_all[] =
{
    "QueryIdentity",
    "QueryJsonData",
    "QueryName",
    "QuerySoftIdent",
    "destroy",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "initiateReceiver",
    "queryLastCdpDetailByCdpToken",
    "queryLastCdpDetailByRestoreToken",
    "refresh",
    "reportRestoreStatus",
    "setPreReadBitmap"
};

}

::Ice::DispatchStatus
VpsAgent::Session::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__VpsAgent__Session_all, __VpsAgent__Session_all + 15, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __VpsAgent__Session_all)
    {
        case 0:
        {
            return ___QueryIdentity(in, current);
        }
        case 1:
        {
            return ___QueryJsonData(in, current);
        }
        case 2:
        {
            return ___QueryName(in, current);
        }
        case 3:
        {
            return ___QuerySoftIdent(in, current);
        }
        case 4:
        {
            return ___destroy(in, current);
        }
        case 5:
        {
            return ___ice_id(in, current);
        }
        case 6:
        {
            return ___ice_ids(in, current);
        }
        case 7:
        {
            return ___ice_isA(in, current);
        }
        case 8:
        {
            return ___ice_ping(in, current);
        }
        case 9:
        {
            return ___initiateReceiver(in, current);
        }
        case 10:
        {
            return ___queryLastCdpDetailByCdpToken(in, current);
        }
        case 11:
        {
            return ___queryLastCdpDetailByRestoreToken(in, current);
        }
        case 12:
        {
            return ___refresh(in, current);
        }
        case 13:
        {
            return ___reportRestoreStatus(in, current);
        }
        case 14:
        {
            return ___setPreReadBitmap(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
VpsAgent::Session::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
VpsAgent::Session::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
VpsAgent::__patch(SessionPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::VpsAgent::SessionPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::VpsAgent::Session::ice_staticId(), v);
    }
}

::Ice::Object* VpsAgent::upCast(::VpsAgent::SessionFactory* p) { return p; }

namespace
{
const ::std::string __VpsAgent__SessionFactory_ids[2] =
{
    "::Ice::Object",
    "::VpsAgent::SessionFactory"
};

}

bool
VpsAgent::SessionFactory::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__VpsAgent__SessionFactory_ids, __VpsAgent__SessionFactory_ids + 2, _s);
}

::std::vector< ::std::string>
VpsAgent::SessionFactory::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__VpsAgent__SessionFactory_ids[0], &__VpsAgent__SessionFactory_ids[2]);
}

const ::std::string&
VpsAgent::SessionFactory::ice_id(const ::Ice::Current&) const
{
    return __VpsAgent__SessionFactory_ids[1];
}

const ::std::string&
VpsAgent::SessionFactory::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::VpsAgent::SessionFactory";
    return typeId;
#else
    return __VpsAgent__SessionFactory_ids[1];
#endif
}

::Ice::DispatchStatus
VpsAgent::SessionFactory::___create(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::VpsAgent::AgentIdentification __p_id;
    ::std::string __p_info;
    __is->read(__p_id);
    __is->read(__p_info);
    __inS.endReadParams();
    try
    {
        ::VpsAgent::SessionPrx __ret = create(__p_id, __p_info, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __VpsAgent__SessionFactory_all[] =
{
    "create",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
VpsAgent::SessionFactory::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__VpsAgent__SessionFactory_all, __VpsAgent__SessionFactory_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __VpsAgent__SessionFactory_all)
    {
        case 0:
        {
            return ___create(in, current);
        }
        case 1:
        {
            return ___ice_id(in, current);
        }
        case 2:
        {
            return ___ice_ids(in, current);
        }
        case 3:
        {
            return ___ice_isA(in, current);
        }
        case 4:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
VpsAgent::SessionFactory::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
VpsAgent::SessionFactory::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
VpsAgent::__patch(SessionFactoryPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::VpsAgent::SessionFactoryPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::VpsAgent::SessionFactory::ice_staticId(), v);
    }
}
