// **********************************************************************
//
// Copyright (c) 2003-2015 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.6.1
//
// <auto-generated>
//
// Generated from file `box_api.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <box_api.h>
#include <IceUtil/PushDisableWarnings.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/BasicStream.h>
#include <IceUtil/Iterator.h>
#include <IceUtil/PopDisableWarnings.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 306
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace
{

const ::std::string __Box__Apis__ping_name = "ping";

const ::std::string __Box__Apis__reloginAllHostSession_name = "reloginAllHostSession";

const ::std::string __Box__Apis__isAgentLinked_name = "isAgentLinked";

const ::std::string __Box__Apis__GetStatus_name = "GetStatus";

const ::std::string __Box__Apis__queryDisksStatus_name = "queryDisksStatus";

const ::std::string __Box__Apis__JsonFunc_name = "JsonFunc";

const ::std::string __Box__Apis__querySystemInfo_name = "querySystemInfo";

const ::std::string __Box__Apis__backup_name = "backup";

const ::std::string __Box__Apis__forceCloseBackupFiles_name = "forceCloseBackupFiles";

const ::std::string __Box__Apis__getBackupInfo_name = "getBackupInfo";

const ::std::string __Box__Apis__setBackupInfo_name = "setBackupInfo";

const ::std::string __Box__Apis__queryLastBackupError_name = "queryLastBackupError";

const ::std::string __Box__Apis__queryLastCdpError_name = "queryLastCdpError";

const ::std::string __Box__Apis__stopCdpStatus_name = "stopCdpStatus";

const ::std::string __Box__Apis__volumeRestore_name = "volumeRestore";

const ::std::string __Box__Apis__restore_name = "restore";

const ::std::string __Box__Apis__setBootDataList_name = "setBootDataList";

const ::std::string __Box__Apis__notifyHighPriority_name = "notifyHighPriority";

const ::std::string __Box__Apis__ReadDiskWithPeHost_name = "ReadDiskWithPeHost";

const ::std::string __Box__Apis__WriteDiskWithPeHost_name = "WriteDiskWithPeHost";

const ::std::string __Box__Apis__QueryRWDiskWithPeHost_name = "QueryRWDiskWithPeHost";

const ::std::string __Box__Apis__KvmStopped_name = "KvmStopped";

const ::std::string __Box__Apis__GetPeHostClassHWInfo_name = "GetPeHostClassHWInfo";

const ::std::string __Box__Apis__GetPeHostNetAdapterInfo_name = "GetPeHostNetAdapterInfo";

const ::std::string __Box__Apis__isPeHostLinked_name = "isPeHostLinked";

const ::std::string __Box__Apis__StartAgentPe_name = "StartAgentPe";

const ::std::string __Box__Apis__fetchAgentDebugFile_name = "fetchAgentDebugFile";

const ::std::string __Box__Apis__queryRunnerAbsPathOnAgentSetup_name = "queryRunnerAbsPathOnAgentSetup";

const ::std::string __Box__Apis__prepareInfoOnAgentSetup_name = "prepareInfoOnAgentSetup";

const ::std::string __Box__Apis__getFileInfoOnAgentSetup_name = "getFileInfoOnAgentSetup";

const ::std::string __Box__Apis__searchBootFileAbsPathOnAgentSetup_name = "searchBootFileAbsPathOnAgentSetup";

const ::std::string __Box__Apis__generateKeyInfosOnAgentSetup_name = "generateKeyInfosOnAgentSetup";

const ::std::string __Box__Apis__openOnAgentSetup_name = "openOnAgentSetup";

const ::std::string __Box__Apis__preadOnAgentSetup_name = "preadOnAgentSetup";

const ::std::string __Box__Apis__pwriteOnAgentSetup_name = "pwriteOnAgentSetup";

const ::std::string __Box__Apis__closeOnAgentSetup_name = "closeOnAgentSetup";

const ::std::string __Box__Apis__extractFileOnAgentSetup_name = "extractFileOnAgentSetup";

const ::std::string __Box__Apis__executeCommandOnAgentSetup_name = "executeCommandOnAgentSetup";

const ::std::string __Box__Apis__reportStatusOnAgentSetup_name = "reportStatusOnAgentSetup";

const ::std::string __Box__Apis__exitOnAgentSetup_name = "exitOnAgentSetup";

const ::std::string __Box__Apis__forceOfflineAgent_name = "forceOfflineAgent";

const ::std::string __Box__Apis__forceOfflinePeHost_name = "forceOfflinePeHost";

const ::std::string __Box__Apis__refreshNetwork_name = "refreshNetwork";

const ::std::string __Box__Apis__GetServiceList_name = "GetServiceList";

const ::std::string __Box__Apis__GetTcpListenList_name = "GetTcpListenList";

const ::std::string __Box__Apis__StartServiceSync_name = "StartServiceSync";

const ::std::string __Box__Apis__StopServiceSync_name = "StopServiceSync";

const ::std::string __Box__Apis__StartHttpDServiceAsync_name = "StartHttpDServiceAsync";

const ::std::string __Box__Apis__GetHttpDServiceListSync_name = "GetHttpDServiceListSync";

const ::std::string __Box__Apis__StopAllHttpDServiceSync_name = "StopAllHttpDServiceSync";

const ::std::string __Box__Apis__testDisk_name = "testDisk";

const ::std::string __Box__Apis__readDisk_name = "readDisk";

const ::std::string __Box__Apis__writeDisk_name = "writeDisk";

const ::std::string __Box__Apis__JsonFuncV2_name = "JsonFuncV2";

const ::std::string __Box__Apis__PEJsonFunc_name = "PEJsonFunc";

}

namespace Ice
{
}
::IceProxy::Ice::Object* ::IceProxy::Box::upCast(::IceProxy::Box::Apis* p) { return p; }

void
::IceProxy::Box::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Box::Apis>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Box::Apis;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Box::Apis::ping(const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __Box__Apis__ping_name, ::Ice::Normal, __ctx);
    __og.writeEmptyParams();
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_ping(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__ping_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__ping_name, ::Ice::Normal, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::Box::Apis::end_ping(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Box__Apis__ping_name);
}

void
IceProxy::Box::Apis::reloginAllHostSession(::Ice::Int __p_delaySeconds, const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __Box__Apis__reloginAllHostSession_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_delaySeconds);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_reloginAllHostSession(::Ice::Int __p_delaySeconds, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__reloginAllHostSession_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__reloginAllHostSession_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_delaySeconds);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::Box::Apis::end_reloginAllHostSession(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Box__Apis__reloginAllHostSession_name);
}

bool
IceProxy::Box::Apis::isAgentLinked(const ::std::string& __p_hostName, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__isAgentLinked_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__isAgentLinked_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_isAgentLinked(const ::std::string& __p_hostName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__isAgentLinked_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__isAgentLinked_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__isAgentLinked_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_isAgentLinked(const ::std::string& __p_hostName, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            bool __ret;
            try
            {
                __ret = __proxy->end_isAgentLinked(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (bool)> _response;
    };
    return begin_isAgentLinked(__p_hostName, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::Box::Apis::end_isAgentLinked(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__isAgentLinked_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::BoxLogic::AgentStatus
IceProxy::Box::Apis::GetStatus(const ::std::string& __p_hostName, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__GetStatus_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__GetStatus_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::BoxLogic::AgentStatus __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_GetStatus(const ::std::string& __p_hostName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__GetStatus_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__GetStatus_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__GetStatus_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_GetStatus(const ::std::string& __p_hostName, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::BoxLogic::AgentStatus&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::BoxLogic::AgentStatus&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            ::BoxLogic::AgentStatus __ret;
            try
            {
                __ret = __proxy->end_GetStatus(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::BoxLogic::AgentStatus&)> _response;
    };
    return begin_GetStatus(__p_hostName, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::BoxLogic::AgentStatus
IceProxy::Box::Apis::end_GetStatus(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__GetStatus_name);
    ::BoxLogic::AgentStatus __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::Box::Apis::queryDisksStatus(const ::std::string& __p_hostName, ::BoxLogic::Disks& __p_disks, IceUtil::Optional< ::std::string>& __p_more, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__queryDisksStatus_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__queryDisksStatus_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_disks);
    __is->read(1, __p_more);
    __og.endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_queryDisksStatus(const ::std::string& __p_hostName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__queryDisksStatus_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__queryDisksStatus_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__queryDisksStatus_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_queryDisksStatus(const ::std::string& __p_hostName, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::BoxLogic::Disks&, const IceUtil::Optional< ::std::string>&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::BoxLogic::Disks&, const IceUtil::Optional< ::std::string>&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            ::BoxLogic::Disks __p_disks;
            IceUtil::Optional< ::std::string> __p_more;
            try
            {
                __proxy->end_queryDisksStatus(__p_disks, __p_more, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__p_disks, __p_more);
            }
        }
    
    private:
        
        ::std::function<void (const ::BoxLogic::Disks&, const IceUtil::Optional< ::std::string>&)> _response;
    };
    return begin_queryDisksStatus(__p_hostName, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::Box::Apis::end_queryDisksStatus(::BoxLogic::Disks& __p_disks, IceUtil::Optional< ::std::string>& __p_more, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__queryDisksStatus_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_disks);
    __is->read(1, __p_more);
    __result->__endReadParams();
}

::std::string
IceProxy::Box::Apis::JsonFunc(const ::std::string& __p_hostName, const ::std::string& __p_inputParam, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__JsonFunc_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__JsonFunc_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_inputParam);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_JsonFunc(const ::std::string& __p_hostName, const ::std::string& __p_inputParam, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__JsonFunc_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__JsonFunc_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__JsonFunc_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_inputParam);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_JsonFunc(const ::std::string& __p_hostName, const ::std::string& __p_inputParam, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_JsonFunc(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_JsonFunc(__p_hostName, __p_inputParam, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::Box::Apis::end_JsonFunc(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__JsonFunc_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::std::string
IceProxy::Box::Apis::querySystemInfo(const ::std::string& __p_hostName, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__querySystemInfo_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__querySystemInfo_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_querySystemInfo(const ::std::string& __p_hostName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__querySystemInfo_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__querySystemInfo_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__querySystemInfo_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_querySystemInfo(const ::std::string& __p_hostName, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_querySystemInfo(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_querySystemInfo(__p_hostName, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::Box::Apis::end_querySystemInfo(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__querySystemInfo_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::Box::Apis::backup(const ::std::string& __p_hostName, const ::Box::BackupFiles& __p_images, ::Ice::Int __p_kiloBytesPerSecond, const IceUtil::Optional< ::std::string>& __p_jsonConfig, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__backup_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__backup_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_images);
        __os->write(__p_kiloBytesPerSecond);
        __os->write(1, __p_jsonConfig);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::CreateSnapshotImageError&)
        {
            throw;
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_backup(const ::std::string& __p_hostName, const ::Box::BackupFiles& __p_images, ::Ice::Int __p_kiloBytesPerSecond, const IceUtil::Optional< ::std::string>& __p_jsonConfig, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__backup_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__backup_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__backup_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_images);
        __os->write(__p_kiloBytesPerSecond);
        __os->write(1, __p_jsonConfig);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_backup(const ::std::string& __p_hostName, const ::Box::BackupFiles& __p_images, ::Ice::Int __p_kiloBytesPerSecond, const IceUtil::Optional< ::std::string>& __p_jsonConfig, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_backup(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_backup(__p_hostName, __p_images, __p_kiloBytesPerSecond, __p_jsonConfig, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::Box::Apis::end_backup(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__backup_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::CreateSnapshotImageError&)
        {
            throw;
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::Box::Apis::forceCloseBackupFiles(const ::Ice::StringSeq& __p_files, const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __Box__Apis__forceCloseBackupFiles_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_files);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_forceCloseBackupFiles(const ::Ice::StringSeq& __p_files, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__forceCloseBackupFiles_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__forceCloseBackupFiles_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_files);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::Box::Apis::end_forceCloseBackupFiles(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Box__Apis__forceCloseBackupFiles_name);
}

::std::string
IceProxy::Box::Apis::getBackupInfo(const ::std::string& __p_hostName, const ::std::string& __p_inputJson, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__getBackupInfo_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__getBackupInfo_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_inputJson);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_getBackupInfo(const ::std::string& __p_hostName, const ::std::string& __p_inputJson, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__getBackupInfo_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__getBackupInfo_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__getBackupInfo_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_inputJson);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_getBackupInfo(const ::std::string& __p_hostName, const ::std::string& __p_inputJson, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_getBackupInfo(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_getBackupInfo(__p_hostName, __p_inputJson, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::Box::Apis::end_getBackupInfo(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__getBackupInfo_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::Box::Apis::setBackupInfo(const ::std::string& __p_hostName, const ::std::string& __p_inputJson, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__setBackupInfo_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__setBackupInfo_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_inputJson);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_setBackupInfo(const ::std::string& __p_hostName, const ::std::string& __p_inputJson, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__setBackupInfo_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__setBackupInfo_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__setBackupInfo_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_inputJson);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_setBackupInfo(const ::std::string& __p_hostName, const ::std::string& __p_inputJson, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_setBackupInfo(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_setBackupInfo(__p_hostName, __p_inputJson, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::Box::Apis::end_setBackupInfo(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__setBackupInfo_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

::std::string
IceProxy::Box::Apis::queryLastBackupError(const ::std::string& __p_hostName, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__queryLastBackupError_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__queryLastBackupError_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_queryLastBackupError(const ::std::string& __p_hostName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__queryLastBackupError_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__queryLastBackupError_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__queryLastBackupError_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_queryLastBackupError(const ::std::string& __p_hostName, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_queryLastBackupError(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_queryLastBackupError(__p_hostName, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::Box::Apis::end_queryLastBackupError(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__queryLastBackupError_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::std::string
IceProxy::Box::Apis::queryLastCdpError(const ::std::string& __p_hostName, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__queryLastCdpError_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__queryLastCdpError_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_queryLastCdpError(const ::std::string& __p_hostName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__queryLastCdpError_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__queryLastCdpError_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__queryLastCdpError_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_queryLastCdpError(const ::std::string& __p_hostName, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_queryLastCdpError(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_queryLastCdpError(__p_hostName, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::Box::Apis::end_queryLastCdpError(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__queryLastCdpError_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::Box::Apis::stopCdpStatus(const ::std::string& __p_hostName, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__stopCdpStatus_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__stopCdpStatus_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_stopCdpStatus(const ::std::string& __p_hostName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__stopCdpStatus_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__stopCdpStatus_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__stopCdpStatus_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_stopCdpStatus(const ::std::string& __p_hostName, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_stopCdpStatus(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_stopCdpStatus(__p_hostName, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::Box::Apis::end_stopCdpStatus(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__stopCdpStatus_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::Box::Apis::volumeRestore(const ::std::string& __p_hostName, const ::std::string& __p_jsonConfig, const ::Box::RestoreFiles& __p_images, const ::std::string& __p_dummyHost, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__volumeRestore_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__volumeRestore_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_jsonConfig);
        __os->write(__p_images);
        __os->write(__p_dummyHost);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_volumeRestore(const ::std::string& __p_hostName, const ::std::string& __p_jsonConfig, const ::Box::RestoreFiles& __p_images, const ::std::string& __p_dummyHost, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__volumeRestore_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__volumeRestore_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__volumeRestore_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_jsonConfig);
        __os->write(__p_images);
        __os->write(__p_dummyHost);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_volumeRestore(const ::std::string& __p_hostName, const ::std::string& __p_jsonConfig, const ::Box::RestoreFiles& __p_images, const ::std::string& __p_dummyHost, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_volumeRestore(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_volumeRestore(__p_hostName, __p_jsonConfig, __p_images, __p_dummyHost, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::Box::Apis::end_volumeRestore(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__volumeRestore_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::Box::Apis::restore(const ::std::string& __p_hostName, const ::PerpcIce::PeRestoreInfo& __p_info, const ::Box::RestoreFiles& __p_images, const ::std::string& __p_jsonConfig, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__restore_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__restore_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_info);
        __os->write(__p_images);
        __os->write(__p_jsonConfig);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_restore(const ::std::string& __p_hostName, const ::PerpcIce::PeRestoreInfo& __p_info, const ::Box::RestoreFiles& __p_images, const ::std::string& __p_jsonConfig, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__restore_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__restore_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__restore_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_info);
        __os->write(__p_images);
        __os->write(__p_jsonConfig);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_restore(const ::std::string& __p_hostName, const ::PerpcIce::PeRestoreInfo& __p_info, const ::Box::RestoreFiles& __p_images, const ::std::string& __p_jsonConfig, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_restore(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_restore(__p_hostName, __p_info, __p_images, __p_jsonConfig, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::Box::Apis::end_restore(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__restore_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::Box::Apis::setBootDataList(const ::std::string& __p_hostName, const ::std::string& __p_filePath, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__setBootDataList_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__setBootDataList_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_filePath);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_setBootDataList(const ::std::string& __p_hostName, const ::std::string& __p_filePath, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__setBootDataList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__setBootDataList_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__setBootDataList_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_filePath);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_setBootDataList(const ::std::string& __p_hostName, const ::std::string& __p_filePath, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_setBootDataList(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_setBootDataList(__p_hostName, __p_filePath, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::Box::Apis::end_setBootDataList(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__setBootDataList_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::Box::Apis::notifyHighPriority(::Ice::Long __p_imageFileHandle, ::Ice::Long __p_byteOffset, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__notifyHighPriority_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__notifyHighPriority_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_imageFileHandle);
        __os->write(__p_byteOffset);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_notifyHighPriority(::Ice::Long __p_imageFileHandle, ::Ice::Long __p_byteOffset, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__notifyHighPriority_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__notifyHighPriority_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__notifyHighPriority_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_imageFileHandle);
        __os->write(__p_byteOffset);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_notifyHighPriority(::Ice::Long __p_imageFileHandle, ::Ice::Long __p_byteOffset, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_notifyHighPriority(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_notifyHighPriority(__p_imageFileHandle, __p_byteOffset, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::Box::Apis::end_notifyHighPriority(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__notifyHighPriority_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

::Ice::Int
IceProxy::Box::Apis::ReadDiskWithPeHost(const ::std::string& __p_peHostIdent, const ::std::string& __p_token, ::Ice::Long __p_sectorOffset, ::Ice::Int __p_sectors, ::Box::BinaryStream& __p_data, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__ReadDiskWithPeHost_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__ReadDiskWithPeHost_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_peHostIdent);
        __os->write(__p_token);
        __os->write(__p_sectorOffset);
        __os->write(__p_sectors);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_data);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_ReadDiskWithPeHost(const ::std::string& __p_peHostIdent, const ::std::string& __p_token, ::Ice::Long __p_sectorOffset, ::Ice::Int __p_sectors, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__ReadDiskWithPeHost_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__ReadDiskWithPeHost_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__ReadDiskWithPeHost_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_peHostIdent);
        __os->write(__p_token);
        __os->write(__p_sectorOffset);
        __os->write(__p_sectors);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_ReadDiskWithPeHost(const ::std::string& __p_peHostIdent, const ::std::string& __p_token, ::Ice::Long __p_sectorOffset, ::Ice::Int __p_sectors, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int, const ::Box::BinaryStream&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int, const ::Box::BinaryStream&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            ::Box::BinaryStream __p_data;
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_ReadDiskWithPeHost(__p_data, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_data);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int, const ::Box::BinaryStream&)> _response;
    };
    return begin_ReadDiskWithPeHost(__p_peHostIdent, __p_token, __p_sectorOffset, __p_sectors, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::Box::Apis::end_ReadDiskWithPeHost(::Box::BinaryStream& __p_data, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__ReadDiskWithPeHost_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_data);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::Ice::Int
IceProxy::Box::Apis::WriteDiskWithPeHost(const ::std::string& __p_peHostIdent, const ::std::string& __p_token, ::Ice::Long __p_sectorOffset, ::Ice::Int __p_sectors, const ::Box::BinaryStream& __p_data, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__WriteDiskWithPeHost_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__WriteDiskWithPeHost_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_peHostIdent);
        __os->write(__p_token);
        __os->write(__p_sectorOffset);
        __os->write(__p_sectors);
        __os->write(__p_data);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_WriteDiskWithPeHost(const ::std::string& __p_peHostIdent, const ::std::string& __p_token, ::Ice::Long __p_sectorOffset, ::Ice::Int __p_sectors, const ::Box::BinaryStream& __p_data, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__WriteDiskWithPeHost_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__WriteDiskWithPeHost_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__WriteDiskWithPeHost_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_peHostIdent);
        __os->write(__p_token);
        __os->write(__p_sectorOffset);
        __os->write(__p_sectors);
        __os->write(__p_data);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_WriteDiskWithPeHost(const ::std::string& __p_peHostIdent, const ::std::string& __p_token, ::Ice::Long __p_sectorOffset, ::Ice::Int __p_sectors, const ::Box::BinaryStream& __p_data, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_WriteDiskWithPeHost(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int)> _response;
    };
    return begin_WriteDiskWithPeHost(__p_peHostIdent, __p_token, __p_sectorOffset, __p_sectors, __p_data, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::Box::Apis::end_WriteDiskWithPeHost(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__WriteDiskWithPeHost_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

bool
IceProxy::Box::Apis::QueryRWDiskWithPeHost(const ::std::string& __p_peHostIdent, ::Ice::Long& __p_totalSectors, ::Ice::Long& __p_sentSectors, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__QueryRWDiskWithPeHost_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__QueryRWDiskWithPeHost_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_peHostIdent);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_totalSectors);
    __is->read(__p_sentSectors);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_QueryRWDiskWithPeHost(const ::std::string& __p_peHostIdent, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__QueryRWDiskWithPeHost_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__QueryRWDiskWithPeHost_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__QueryRWDiskWithPeHost_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_peHostIdent);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_QueryRWDiskWithPeHost(const ::std::string& __p_peHostIdent, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool, ::Ice::Long, ::Ice::Long)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool, ::Ice::Long, ::Ice::Long)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            ::Ice::Long __p_totalSectors;
            ::Ice::Long __p_sentSectors;
            bool __ret;
            try
            {
                __ret = __proxy->end_QueryRWDiskWithPeHost(__p_totalSectors, __p_sentSectors, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_totalSectors, __p_sentSectors);
            }
        }
    
    private:
        
        ::std::function<void (bool, ::Ice::Long, ::Ice::Long)> _response;
    };
    return begin_QueryRWDiskWithPeHost(__p_peHostIdent, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::Box::Apis::end_QueryRWDiskWithPeHost(::Ice::Long& __p_totalSectors, ::Ice::Long& __p_sentSectors, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__QueryRWDiskWithPeHost_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_totalSectors);
    __is->read(__p_sentSectors);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::Box::Apis::KvmStopped(const ::std::string& __p_peHostIdent, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__KvmStopped_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__KvmStopped_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_peHostIdent);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_KvmStopped(const ::std::string& __p_peHostIdent, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__KvmStopped_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__KvmStopped_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__KvmStopped_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_peHostIdent);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_KvmStopped(const ::std::string& __p_peHostIdent, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_KvmStopped(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_KvmStopped(__p_peHostIdent, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::Box::Apis::end_KvmStopped(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__KvmStopped_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

::Ice::Int
IceProxy::Box::Apis::GetPeHostClassHWInfo(const ::std::string& __p_peHostIdent, const ::std::string& __p_classname, ::Ice::Int __p_parentLevel, ::PerpcIce::HWInfos& __p_hwinfo, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__GetPeHostClassHWInfo_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__GetPeHostClassHWInfo_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_peHostIdent);
        __os->write(__p_classname);
        __os->write(__p_parentLevel);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_hwinfo);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_GetPeHostClassHWInfo(const ::std::string& __p_peHostIdent, const ::std::string& __p_classname, ::Ice::Int __p_parentLevel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__GetPeHostClassHWInfo_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__GetPeHostClassHWInfo_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__GetPeHostClassHWInfo_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_peHostIdent);
        __os->write(__p_classname);
        __os->write(__p_parentLevel);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_GetPeHostClassHWInfo(const ::std::string& __p_peHostIdent, const ::std::string& __p_classname, ::Ice::Int __p_parentLevel, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int, const ::PerpcIce::HWInfos&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int, const ::PerpcIce::HWInfos&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            ::PerpcIce::HWInfos __p_hwinfo;
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_GetPeHostClassHWInfo(__p_hwinfo, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_hwinfo);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int, const ::PerpcIce::HWInfos&)> _response;
    };
    return begin_GetPeHostClassHWInfo(__p_peHostIdent, __p_classname, __p_parentLevel, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::Box::Apis::end_GetPeHostClassHWInfo(::PerpcIce::HWInfos& __p_hwinfo, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__GetPeHostClassHWInfo_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_hwinfo);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::Ice::Int
IceProxy::Box::Apis::GetPeHostNetAdapterInfo(const ::std::string& __p_peHostIdent, ::PerpcIce::NetAdapterInfos& __p_adapterInfos, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__GetPeHostNetAdapterInfo_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__GetPeHostNetAdapterInfo_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_peHostIdent);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_adapterInfos);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_GetPeHostNetAdapterInfo(const ::std::string& __p_peHostIdent, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__GetPeHostNetAdapterInfo_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__GetPeHostNetAdapterInfo_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__GetPeHostNetAdapterInfo_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_peHostIdent);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_GetPeHostNetAdapterInfo(const ::std::string& __p_peHostIdent, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int, const ::PerpcIce::NetAdapterInfos&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int, const ::PerpcIce::NetAdapterInfos&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            ::PerpcIce::NetAdapterInfos __p_adapterInfos;
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_GetPeHostNetAdapterInfo(__p_adapterInfos, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_adapterInfos);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int, const ::PerpcIce::NetAdapterInfos&)> _response;
    };
    return begin_GetPeHostNetAdapterInfo(__p_peHostIdent, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::Box::Apis::end_GetPeHostNetAdapterInfo(::PerpcIce::NetAdapterInfos& __p_adapterInfos, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__GetPeHostNetAdapterInfo_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_adapterInfos);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

bool
IceProxy::Box::Apis::isPeHostLinked(const ::std::string& __p_peHostName, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__isPeHostLinked_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__isPeHostLinked_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_peHostName);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    bool __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_isPeHostLinked(const ::std::string& __p_peHostName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__isPeHostLinked_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__isPeHostLinked_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__isPeHostLinked_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_peHostName);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_isPeHostLinked(const ::std::string& __p_peHostName, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (bool)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            bool __ret;
            try
            {
                __ret = __proxy->end_isPeHostLinked(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (bool)> _response;
    };
    return begin_isPeHostLinked(__p_peHostName, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

bool
IceProxy::Box::Apis::end_isPeHostLinked(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__isPeHostLinked_name);
    bool __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::std::string
IceProxy::Box::Apis::StartAgentPe(const ::std::string& __p_hostName, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__StartAgentPe_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__StartAgentPe_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_StartAgentPe(const ::std::string& __p_hostName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__StartAgentPe_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__StartAgentPe_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__StartAgentPe_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_StartAgentPe(const ::std::string& __p_hostName, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_StartAgentPe(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_StartAgentPe(__p_hostName, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::Box::Apis::end_StartAgentPe(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__StartAgentPe_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::Box::Apis::fetchAgentDebugFile(const ::std::string& __p_hostName, const ::std::string& __p_path, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__fetchAgentDebugFile_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__fetchAgentDebugFile_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_path);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_fetchAgentDebugFile(const ::std::string& __p_hostName, const ::std::string& __p_path, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__fetchAgentDebugFile_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__fetchAgentDebugFile_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__fetchAgentDebugFile_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_path);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_fetchAgentDebugFile(const ::std::string& __p_hostName, const ::std::string& __p_path, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_fetchAgentDebugFile(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_fetchAgentDebugFile(__p_hostName, __p_path, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::Box::Apis::end_fetchAgentDebugFile(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__fetchAgentDebugFile_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

::std::string
IceProxy::Box::Apis::queryRunnerAbsPathOnAgentSetup(const ::std::string& __p_session, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__queryRunnerAbsPathOnAgentSetup_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__queryRunnerAbsPathOnAgentSetup_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_session);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_queryRunnerAbsPathOnAgentSetup(const ::std::string& __p_session, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__queryRunnerAbsPathOnAgentSetup_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__queryRunnerAbsPathOnAgentSetup_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__queryRunnerAbsPathOnAgentSetup_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_session);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_queryRunnerAbsPathOnAgentSetup(const ::std::string& __p_session, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_queryRunnerAbsPathOnAgentSetup(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_queryRunnerAbsPathOnAgentSetup(__p_session, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::Box::Apis::end_queryRunnerAbsPathOnAgentSetup(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__queryRunnerAbsPathOnAgentSetup_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::std::string
IceProxy::Box::Apis::prepareInfoOnAgentSetup(const ::std::string& __p_session, const ::std::string& __p_flagJson, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__prepareInfoOnAgentSetup_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__prepareInfoOnAgentSetup_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_session);
        __os->write(__p_flagJson);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_prepareInfoOnAgentSetup(const ::std::string& __p_session, const ::std::string& __p_flagJson, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__prepareInfoOnAgentSetup_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__prepareInfoOnAgentSetup_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__prepareInfoOnAgentSetup_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_session);
        __os->write(__p_flagJson);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_prepareInfoOnAgentSetup(const ::std::string& __p_session, const ::std::string& __p_flagJson, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_prepareInfoOnAgentSetup(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_prepareInfoOnAgentSetup(__p_session, __p_flagJson, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::Box::Apis::end_prepareInfoOnAgentSetup(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__prepareInfoOnAgentSetup_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::std::string
IceProxy::Box::Apis::getFileInfoOnAgentSetup(const ::std::string& __p_session, const ::std::string& __p_fileName, const ::std::string& __p_flagJson, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__getFileInfoOnAgentSetup_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__getFileInfoOnAgentSetup_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_session);
        __os->write(__p_fileName);
        __os->write(__p_flagJson);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_getFileInfoOnAgentSetup(const ::std::string& __p_session, const ::std::string& __p_fileName, const ::std::string& __p_flagJson, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__getFileInfoOnAgentSetup_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__getFileInfoOnAgentSetup_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__getFileInfoOnAgentSetup_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_session);
        __os->write(__p_fileName);
        __os->write(__p_flagJson);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_getFileInfoOnAgentSetup(const ::std::string& __p_session, const ::std::string& __p_fileName, const ::std::string& __p_flagJson, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_getFileInfoOnAgentSetup(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_getFileInfoOnAgentSetup(__p_session, __p_fileName, __p_flagJson, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::Box::Apis::end_getFileInfoOnAgentSetup(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__getFileInfoOnAgentSetup_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::std::string
IceProxy::Box::Apis::searchBootFileAbsPathOnAgentSetup(const ::std::string& __p_session, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__searchBootFileAbsPathOnAgentSetup_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__searchBootFileAbsPathOnAgentSetup_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_session);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_searchBootFileAbsPathOnAgentSetup(const ::std::string& __p_session, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__searchBootFileAbsPathOnAgentSetup_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__searchBootFileAbsPathOnAgentSetup_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__searchBootFileAbsPathOnAgentSetup_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_session);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_searchBootFileAbsPathOnAgentSetup(const ::std::string& __p_session, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_searchBootFileAbsPathOnAgentSetup(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_searchBootFileAbsPathOnAgentSetup(__p_session, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::Box::Apis::end_searchBootFileAbsPathOnAgentSetup(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__searchBootFileAbsPathOnAgentSetup_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::Box::Apis::generateKeyInfosOnAgentSetup(const ::std::string& __p_session, const ::std::string& __p_absFilePath, const ::std::string& __p_flagJson, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__generateKeyInfosOnAgentSetup_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__generateKeyInfosOnAgentSetup_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_session);
        __os->write(__p_absFilePath);
        __os->write(__p_flagJson);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_generateKeyInfosOnAgentSetup(const ::std::string& __p_session, const ::std::string& __p_absFilePath, const ::std::string& __p_flagJson, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__generateKeyInfosOnAgentSetup_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__generateKeyInfosOnAgentSetup_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__generateKeyInfosOnAgentSetup_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_session);
        __os->write(__p_absFilePath);
        __os->write(__p_flagJson);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_generateKeyInfosOnAgentSetup(const ::std::string& __p_session, const ::std::string& __p_absFilePath, const ::std::string& __p_flagJson, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_generateKeyInfosOnAgentSetup(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_generateKeyInfosOnAgentSetup(__p_session, __p_absFilePath, __p_flagJson, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::Box::Apis::end_generateKeyInfosOnAgentSetup(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__generateKeyInfosOnAgentSetup_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

::std::string
IceProxy::Box::Apis::openOnAgentSetup(const ::std::string& __p_session, const ::std::string& __p_absFilePath, const ::std::string& __p_flagJson, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__openOnAgentSetup_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__openOnAgentSetup_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_session);
        __os->write(__p_absFilePath);
        __os->write(__p_flagJson);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_openOnAgentSetup(const ::std::string& __p_session, const ::std::string& __p_absFilePath, const ::std::string& __p_flagJson, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__openOnAgentSetup_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__openOnAgentSetup_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__openOnAgentSetup_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_session);
        __os->write(__p_absFilePath);
        __os->write(__p_flagJson);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_openOnAgentSetup(const ::std::string& __p_session, const ::std::string& __p_absFilePath, const ::std::string& __p_flagJson, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_openOnAgentSetup(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&)> _response;
    };
    return begin_openOnAgentSetup(__p_session, __p_absFilePath, __p_flagJson, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::Box::Apis::end_openOnAgentSetup(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__openOnAgentSetup_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::Ice::ByteSeq
IceProxy::Box::Apis::preadOnAgentSetup(const ::std::string& __p_session, const ::std::string& __p_handle, ::Ice::Long __p_byteOffset, ::Ice::Int __p_bytes, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__preadOnAgentSetup_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__preadOnAgentSetup_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_session);
        __os->write(__p_handle);
        __os->write(__p_byteOffset);
        __os->write(__p_bytes);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::ByteSeq __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_preadOnAgentSetup(const ::std::string& __p_session, const ::std::string& __p_handle, ::Ice::Long __p_byteOffset, ::Ice::Int __p_bytes, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__preadOnAgentSetup_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__preadOnAgentSetup_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__preadOnAgentSetup_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_session);
        __os->write(__p_handle);
        __os->write(__p_byteOffset);
        __os->write(__p_bytes);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_preadOnAgentSetup(const ::std::string& __p_session, const ::std::string& __p_handle, ::Ice::Long __p_byteOffset, ::Ice::Int __p_bytes, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Ice::ByteSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::Ice::ByteSeq&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            ::Ice::ByteSeq __ret;
            try
            {
                __ret = __proxy->end_preadOnAgentSetup(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (const ::Ice::ByteSeq&)> _response;
    };
    return begin_preadOnAgentSetup(__p_session, __p_handle, __p_byteOffset, __p_bytes, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::ByteSeq
IceProxy::Box::Apis::end_preadOnAgentSetup(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__preadOnAgentSetup_name);
    ::Ice::ByteSeq __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::Box::Apis::pwriteOnAgentSetup(const ::std::string& __p_session, const ::std::string& __p_handle, ::Ice::Long __p_byteOffset, ::Ice::Int __p_bytes, const ::Ice::ByteSeq& __p_data, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__pwriteOnAgentSetup_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__pwriteOnAgentSetup_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_session);
        __os->write(__p_handle);
        __os->write(__p_byteOffset);
        __os->write(__p_bytes);
        __os->write(__p_data);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_pwriteOnAgentSetup(const ::std::string& __p_session, const ::std::string& __p_handle, ::Ice::Long __p_byteOffset, ::Ice::Int __p_bytes, const ::Ice::ByteSeq& __p_data, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__pwriteOnAgentSetup_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__pwriteOnAgentSetup_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__pwriteOnAgentSetup_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_session);
        __os->write(__p_handle);
        __os->write(__p_byteOffset);
        __os->write(__p_bytes);
        __os->write(__p_data);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_pwriteOnAgentSetup(const ::std::string& __p_session, const ::std::string& __p_handle, ::Ice::Long __p_byteOffset, ::Ice::Int __p_bytes, const ::Ice::ByteSeq& __p_data, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_pwriteOnAgentSetup(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_pwriteOnAgentSetup(__p_session, __p_handle, __p_byteOffset, __p_bytes, __p_data, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::Box::Apis::end_pwriteOnAgentSetup(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__pwriteOnAgentSetup_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::Box::Apis::closeOnAgentSetup(const ::std::string& __p_session, const ::std::string& __p_handle, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__closeOnAgentSetup_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__closeOnAgentSetup_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_session);
        __os->write(__p_handle);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_closeOnAgentSetup(const ::std::string& __p_session, const ::std::string& __p_handle, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__closeOnAgentSetup_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__closeOnAgentSetup_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__closeOnAgentSetup_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_session);
        __os->write(__p_handle);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_closeOnAgentSetup(const ::std::string& __p_session, const ::std::string& __p_handle, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_closeOnAgentSetup(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_closeOnAgentSetup(__p_session, __p_handle, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::Box::Apis::end_closeOnAgentSetup(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__closeOnAgentSetup_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::Box::Apis::extractFileOnAgentSetup(const ::std::string& __p_session, const ::std::string& __p_absSourceFilePath, const ::std::string& __p_absDestinationPath, const ::std::string& __p_flagJson, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__extractFileOnAgentSetup_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__extractFileOnAgentSetup_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_session);
        __os->write(__p_absSourceFilePath);
        __os->write(__p_absDestinationPath);
        __os->write(__p_flagJson);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_extractFileOnAgentSetup(const ::std::string& __p_session, const ::std::string& __p_absSourceFilePath, const ::std::string& __p_absDestinationPath, const ::std::string& __p_flagJson, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__extractFileOnAgentSetup_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__extractFileOnAgentSetup_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__extractFileOnAgentSetup_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_session);
        __os->write(__p_absSourceFilePath);
        __os->write(__p_absDestinationPath);
        __os->write(__p_flagJson);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_extractFileOnAgentSetup(const ::std::string& __p_session, const ::std::string& __p_absSourceFilePath, const ::std::string& __p_absDestinationPath, const ::std::string& __p_flagJson, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_extractFileOnAgentSetup(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_extractFileOnAgentSetup(__p_session, __p_absSourceFilePath, __p_absDestinationPath, __p_flagJson, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::Box::Apis::end_extractFileOnAgentSetup(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__extractFileOnAgentSetup_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

::Ice::Int
IceProxy::Box::Apis::executeCommandOnAgentSetup(const ::std::string& __p_session, const ::std::string& __p_cmd, const ::std::string& __p_flagJson, ::Ice::StringSeq& __p_stdout, ::Ice::StringSeq& __p_stderr, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__executeCommandOnAgentSetup_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__executeCommandOnAgentSetup_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_session);
        __os->write(__p_cmd);
        __os->write(__p_flagJson);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_stdout);
    __is->read(__p_stderr);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_executeCommandOnAgentSetup(const ::std::string& __p_session, const ::std::string& __p_cmd, const ::std::string& __p_flagJson, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__executeCommandOnAgentSetup_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__executeCommandOnAgentSetup_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__executeCommandOnAgentSetup_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_session);
        __os->write(__p_cmd);
        __os->write(__p_flagJson);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_executeCommandOnAgentSetup(const ::std::string& __p_session, const ::std::string& __p_cmd, const ::std::string& __p_flagJson, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int, const ::Ice::StringSeq&, const ::Ice::StringSeq&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int, const ::Ice::StringSeq&, const ::Ice::StringSeq&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            ::Ice::StringSeq __p_stdout;
            ::Ice::StringSeq __p_stderr;
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_executeCommandOnAgentSetup(__p_stdout, __p_stderr, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_stdout, __p_stderr);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int, const ::Ice::StringSeq&, const ::Ice::StringSeq&)> _response;
    };
    return begin_executeCommandOnAgentSetup(__p_session, __p_cmd, __p_flagJson, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::Box::Apis::end_executeCommandOnAgentSetup(::Ice::StringSeq& __p_stdout, ::Ice::StringSeq& __p_stderr, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__executeCommandOnAgentSetup_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_stdout);
    __is->read(__p_stderr);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

void
IceProxy::Box::Apis::reportStatusOnAgentSetup(const ::std::string& __p_session, const ::std::string& __p_contentJson, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__reportStatusOnAgentSetup_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__reportStatusOnAgentSetup_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_session);
        __os->write(__p_contentJson);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_reportStatusOnAgentSetup(const ::std::string& __p_session, const ::std::string& __p_contentJson, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__reportStatusOnAgentSetup_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__reportStatusOnAgentSetup_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__reportStatusOnAgentSetup_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_session);
        __os->write(__p_contentJson);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_reportStatusOnAgentSetup(const ::std::string& __p_session, const ::std::string& __p_contentJson, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_reportStatusOnAgentSetup(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_reportStatusOnAgentSetup(__p_session, __p_contentJson, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::Box::Apis::end_reportStatusOnAgentSetup(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__reportStatusOnAgentSetup_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::Box::Apis::exitOnAgentSetup(const ::std::string& __p_session, ::Ice::Int __p_returnCode, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__exitOnAgentSetup_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__exitOnAgentSetup_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_session);
        __os->write(__p_returnCode);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_exitOnAgentSetup(const ::std::string& __p_session, ::Ice::Int __p_returnCode, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__exitOnAgentSetup_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__exitOnAgentSetup_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__exitOnAgentSetup_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_session);
        __os->write(__p_returnCode);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_exitOnAgentSetup(const ::std::string& __p_session, ::Ice::Int __p_returnCode, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_exitOnAgentSetup(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_exitOnAgentSetup(__p_session, __p_returnCode, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::Box::Apis::end_exitOnAgentSetup(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__exitOnAgentSetup_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::Box::Apis::forceOfflineAgent(const ::std::string& __p_hostName, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__forceOfflineAgent_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__forceOfflineAgent_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_forceOfflineAgent(const ::std::string& __p_hostName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__forceOfflineAgent_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__forceOfflineAgent_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__forceOfflineAgent_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_forceOfflineAgent(const ::std::string& __p_hostName, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_forceOfflineAgent(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_forceOfflineAgent(__p_hostName, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::Box::Apis::end_forceOfflineAgent(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__forceOfflineAgent_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::Box::Apis::forceOfflinePeHost(const ::std::string& __p_peHostIdent, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__forceOfflinePeHost_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__forceOfflinePeHost_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_peHostIdent);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_forceOfflinePeHost(const ::std::string& __p_peHostIdent, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__forceOfflinePeHost_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__forceOfflinePeHost_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__forceOfflinePeHost_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_peHostIdent);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_forceOfflinePeHost(const ::std::string& __p_peHostIdent, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            try
            {
                __proxy->end_forceOfflinePeHost(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response();
            }
        }
    
    private:
        
        ::std::function<void ()> _response;
    };
    return begin_forceOfflinePeHost(__p_peHostIdent, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

void
IceProxy::Box::Apis::end_forceOfflinePeHost(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__forceOfflinePeHost_name);
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    __result->__readEmptyParams();
}

void
IceProxy::Box::Apis::refreshNetwork(const ::Ice::Context* __ctx)
{
    ::IceInternal::Outgoing __og(this, __Box__Apis__refreshNetwork_name, ::Ice::Normal, __ctx);
    __og.writeEmptyParams();
    __invoke(__og);
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_refreshNetwork(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__refreshNetwork_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__refreshNetwork_name, ::Ice::Normal, __ctx);
        __result->writeEmptyParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

void
IceProxy::Box::Apis::end_refreshNetwork(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Box__Apis__refreshNetwork_name);
}

::Ice::Int
IceProxy::Box::Apis::GetServiceList(const ::std::string& __p_hostName, ::Box::ServiceInfoStatusS& __p_ServiceList, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__GetServiceList_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__GetServiceList_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_ServiceList);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_GetServiceList(const ::std::string& __p_hostName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__GetServiceList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__GetServiceList_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__GetServiceList_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_GetServiceList(const ::std::string& __p_hostName, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int, const ::Box::ServiceInfoStatusS&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int, const ::Box::ServiceInfoStatusS&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            ::Box::ServiceInfoStatusS __p_ServiceList;
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_GetServiceList(__p_ServiceList, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_ServiceList);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int, const ::Box::ServiceInfoStatusS&)> _response;
    };
    return begin_GetServiceList(__p_hostName, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::Box::Apis::end_GetServiceList(::Box::ServiceInfoStatusS& __p_ServiceList, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__GetServiceList_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_ServiceList);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::Ice::Int
IceProxy::Box::Apis::GetTcpListenList(const ::std::string& __p_hostName, const ::Box::vectorINT& __p_portList, ::Box::vectorINT& __p_pidList, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__GetTcpListenList_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__GetTcpListenList_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_portList);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_pidList);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_GetTcpListenList(const ::std::string& __p_hostName, const ::Box::vectorINT& __p_portList, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__GetTcpListenList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__GetTcpListenList_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__GetTcpListenList_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_portList);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_GetTcpListenList(const ::std::string& __p_hostName, const ::Box::vectorINT& __p_portList, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int, const ::Box::vectorINT&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int, const ::Box::vectorINT&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            ::Box::vectorINT __p_pidList;
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_GetTcpListenList(__p_pidList, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_pidList);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int, const ::Box::vectorINT&)> _response;
    };
    return begin_GetTcpListenList(__p_hostName, __p_portList, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::Box::Apis::end_GetTcpListenList(::Box::vectorINT& __p_pidList, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__GetTcpListenList_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_pidList);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::Ice::Int
IceProxy::Box::Apis::StartServiceSync(const ::std::string& __p_hostName, const ::std::string& __p_ServiceName, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__StartServiceSync_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__StartServiceSync_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_ServiceName);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_StartServiceSync(const ::std::string& __p_hostName, const ::std::string& __p_ServiceName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__StartServiceSync_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__StartServiceSync_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__StartServiceSync_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_ServiceName);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_StartServiceSync(const ::std::string& __p_hostName, const ::std::string& __p_ServiceName, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_StartServiceSync(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int)> _response;
    };
    return begin_StartServiceSync(__p_hostName, __p_ServiceName, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::Box::Apis::end_StartServiceSync(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__StartServiceSync_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::Ice::Int
IceProxy::Box::Apis::StopServiceSync(const ::std::string& __p_hostName, const ::std::string& __p_ServiceName, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__StopServiceSync_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__StopServiceSync_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_ServiceName);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_StopServiceSync(const ::std::string& __p_hostName, const ::std::string& __p_ServiceName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__StopServiceSync_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__StopServiceSync_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__StopServiceSync_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_ServiceName);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_StopServiceSync(const ::std::string& __p_hostName, const ::std::string& __p_ServiceName, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_StopServiceSync(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int)> _response;
    };
    return begin_StopServiceSync(__p_hostName, __p_ServiceName, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::Box::Apis::end_StopServiceSync(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__StopServiceSync_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::Ice::Int
IceProxy::Box::Apis::StartHttpDServiceAsync(const ::std::string& __p_hostName, ::Ice::Int __p_port, const ::Box::BinaryStream& __p_bs, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__StartHttpDServiceAsync_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__StartHttpDServiceAsync_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_port);
        __os->write(__p_bs);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_StartHttpDServiceAsync(const ::std::string& __p_hostName, ::Ice::Int __p_port, const ::Box::BinaryStream& __p_bs, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__StartHttpDServiceAsync_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__StartHttpDServiceAsync_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__StartHttpDServiceAsync_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_port);
        __os->write(__p_bs);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_StartHttpDServiceAsync(const ::std::string& __p_hostName, ::Ice::Int __p_port, const ::Box::BinaryStream& __p_bs, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_StartHttpDServiceAsync(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int)> _response;
    };
    return begin_StartHttpDServiceAsync(__p_hostName, __p_port, __p_bs, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::Box::Apis::end_StartHttpDServiceAsync(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__StartHttpDServiceAsync_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::Ice::Int
IceProxy::Box::Apis::GetHttpDServiceListSync(const ::std::string& __p_hostName, ::Box::vectorINT& __p_pidList, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__GetHttpDServiceListSync_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__GetHttpDServiceListSync_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_pidList);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_GetHttpDServiceListSync(const ::std::string& __p_hostName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__GetHttpDServiceListSync_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__GetHttpDServiceListSync_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__GetHttpDServiceListSync_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_GetHttpDServiceListSync(const ::std::string& __p_hostName, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int, const ::Box::vectorINT&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int, const ::Box::vectorINT&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            ::Box::vectorINT __p_pidList;
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_GetHttpDServiceListSync(__p_pidList, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_pidList);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int, const ::Box::vectorINT&)> _response;
    };
    return begin_GetHttpDServiceListSync(__p_hostName, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::Box::Apis::end_GetHttpDServiceListSync(::Box::vectorINT& __p_pidList, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__GetHttpDServiceListSync_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_pidList);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::Ice::Int
IceProxy::Box::Apis::StopAllHttpDServiceSync(const ::std::string& __p_hostName, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__StopAllHttpDServiceSync_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__StopAllHttpDServiceSync_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_StopAllHttpDServiceSync(const ::std::string& __p_hostName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__StopAllHttpDServiceSync_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__StopAllHttpDServiceSync_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__StopAllHttpDServiceSync_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_StopAllHttpDServiceSync(const ::std::string& __p_hostName, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_StopAllHttpDServiceSync(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int)> _response;
    };
    return begin_StopAllHttpDServiceSync(__p_hostName, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::Box::Apis::end_StopAllHttpDServiceSync(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__StopAllHttpDServiceSync_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::Ice::Int
IceProxy::Box::Apis::testDisk(const ::std::string& __p_hostName, ::Ice::Int __p_diskIndex, ::Ice::Long __p_sectorOffset, ::Ice::Short __p_numberOfSectors, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__testDisk_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__testDisk_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_diskIndex);
        __os->write(__p_sectorOffset);
        __os->write(__p_numberOfSectors);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_testDisk(const ::std::string& __p_hostName, ::Ice::Int __p_diskIndex, ::Ice::Long __p_sectorOffset, ::Ice::Short __p_numberOfSectors, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__testDisk_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__testDisk_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__testDisk_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_diskIndex);
        __os->write(__p_sectorOffset);
        __os->write(__p_numberOfSectors);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_testDisk(const ::std::string& __p_hostName, ::Ice::Int __p_diskIndex, ::Ice::Long __p_sectorOffset, ::Ice::Short __p_numberOfSectors, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_testDisk(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int)> _response;
    };
    return begin_testDisk(__p_hostName, __p_diskIndex, __p_sectorOffset, __p_numberOfSectors, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::Box::Apis::end_testDisk(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__testDisk_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::Ice::Int
IceProxy::Box::Apis::readDisk(const ::std::string& __p_hostName, ::Ice::Int __p_diskIndex, ::Ice::Long __p_sectorOffset, ::Ice::Short __p_numberOfSectors, ::Box::BinaryStream& __p_bs, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__readDisk_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__readDisk_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_diskIndex);
        __os->write(__p_sectorOffset);
        __os->write(__p_numberOfSectors);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_bs);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_readDisk(const ::std::string& __p_hostName, ::Ice::Int __p_diskIndex, ::Ice::Long __p_sectorOffset, ::Ice::Short __p_numberOfSectors, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__readDisk_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__readDisk_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__readDisk_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_diskIndex);
        __os->write(__p_sectorOffset);
        __os->write(__p_numberOfSectors);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_readDisk(const ::std::string& __p_hostName, ::Ice::Int __p_diskIndex, ::Ice::Long __p_sectorOffset, ::Ice::Short __p_numberOfSectors, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int, const ::Box::BinaryStream&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int, const ::Box::BinaryStream&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            ::Box::BinaryStream __p_bs;
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_readDisk(__p_bs, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_bs);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int, const ::Box::BinaryStream&)> _response;
    };
    return begin_readDisk(__p_hostName, __p_diskIndex, __p_sectorOffset, __p_numberOfSectors, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::Box::Apis::end_readDisk(::Box::BinaryStream& __p_bs, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__readDisk_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_bs);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::Ice::Int
IceProxy::Box::Apis::writeDisk(const ::std::string& __p_hostName, ::Ice::Int __p_diskIndex, ::Ice::Long __p_sectorOffset, ::Ice::Short __p_numberOfSector, const ::Box::BinaryStream& __p_bs, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__writeDisk_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__writeDisk_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_diskIndex);
        __os->write(__p_sectorOffset);
        __os->write(__p_numberOfSector);
        __os->write(__p_bs);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::Ice::Int __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_writeDisk(const ::std::string& __p_hostName, ::Ice::Int __p_diskIndex, ::Ice::Long __p_sectorOffset, ::Ice::Short __p_numberOfSector, const ::Box::BinaryStream& __p_bs, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__writeDisk_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__writeDisk_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__writeDisk_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_diskIndex);
        __os->write(__p_sectorOffset);
        __os->write(__p_numberOfSector);
        __os->write(__p_bs);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_writeDisk(const ::std::string& __p_hostName, ::Ice::Int __p_diskIndex, ::Ice::Long __p_sectorOffset, ::Ice::Short __p_numberOfSector, const ::Box::BinaryStream& __p_bs, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (::Ice::Int)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            ::Ice::Int __ret;
            try
            {
                __ret = __proxy->end_writeDisk(__result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret);
            }
        }
    
    private:
        
        ::std::function<void (::Ice::Int)> _response;
    };
    return begin_writeDisk(__p_hostName, __p_diskIndex, __p_sectorOffset, __p_numberOfSector, __p_bs, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::Ice::Int
IceProxy::Box::Apis::end_writeDisk(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__writeDisk_name);
    ::Ice::Int __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::std::string
IceProxy::Box::Apis::JsonFuncV2(const ::std::string& __p_hostName, const ::std::string& __p_inputJson, const ::Box::BinaryStream& __p_inputBs, ::Box::BinaryStream& __p_outputBs, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__JsonFuncV2_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__JsonFuncV2_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_inputJson);
        __os->write(__p_inputBs);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_outputBs);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_JsonFuncV2(const ::std::string& __p_hostName, const ::std::string& __p_inputJson, const ::Box::BinaryStream& __p_inputBs, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__JsonFuncV2_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__JsonFuncV2_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__JsonFuncV2_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hostName);
        __os->write(__p_inputJson);
        __os->write(__p_inputBs);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_JsonFuncV2(const ::std::string& __p_hostName, const ::std::string& __p_inputJson, const ::Box::BinaryStream& __p_inputBs, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&, const ::Box::BinaryStream&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&, const ::Box::BinaryStream&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            ::Box::BinaryStream __p_outputBs;
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_JsonFuncV2(__p_outputBs, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_outputBs);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&, const ::Box::BinaryStream&)> _response;
    };
    return begin_JsonFuncV2(__p_hostName, __p_inputJson, __p_inputBs, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::Box::Apis::end_JsonFuncV2(::Box::BinaryStream& __p_outputBs, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__JsonFuncV2_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_outputBs);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

::std::string
IceProxy::Box::Apis::PEJsonFunc(const ::std::string& __p_peHostIdent, const ::std::string& __p_inputJson, const ::Box::BinaryStream& __p_inputBs, ::Box::BinaryStream& __p_outputBs, const ::Ice::Context* __ctx)
{
    __checkTwowayOnly(__Box__Apis__PEJsonFunc_name);
    ::IceInternal::Outgoing __og(this, __Box__Apis__PEJsonFunc_name, ::Ice::Normal, __ctx);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_peHostIdent);
        __os->write(__p_inputJson);
        __os->write(__p_inputBs);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    if(!__og.invoke())
    {
        try
        {
            __og.throwUserException();
        }
        catch(const ::Utils::OperationNotExistError&)
        {
            throw;
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
            throw __uue;
        }
    }
    ::std::string __ret;
    ::IceInternal::BasicStream* __is = __og.startReadParams();
    __is->read(__p_outputBs);
    __is->read(__ret);
    __og.endReadParams();
    return __ret;
}

::Ice::AsyncResultPtr
IceProxy::Box::Apis::begin_PEJsonFunc(const ::std::string& __p_peHostIdent, const ::std::string& __p_inputJson, const ::Box::BinaryStream& __p_inputBs, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Box__Apis__PEJsonFunc_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Box__Apis__PEJsonFunc_name, __del, __cookie);
    try
    {
        __result->prepare(__Box__Apis__PEJsonFunc_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_peHostIdent);
        __os->write(__p_inputJson);
        __os->write(__p_inputBs);
        __result->endWriteParams();
        __result->invoke();
    }
    catch(const ::Ice::Exception& __ex)
    {
        __result->abort(__ex);
    }
    return __result;
}

#ifdef ICE_CPP11

::Ice::AsyncResultPtr
IceProxy::Box::Apis::__begin_PEJsonFunc(const ::std::string& __p_peHostIdent, const ::std::string& __p_inputJson, const ::Box::BinaryStream& __p_inputBs, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&, const ::Box::BinaryStream&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
{
    class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
    {
    public:

        Cpp11CB(const ::std::function<void (const ::std::string&, const ::Box::BinaryStream&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
            ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
            _response(responseFunc)
        {
            CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
        }

        virtual void completed(const ::Ice::AsyncResultPtr& __result) const
        {
            ::Box::ApisPrx __proxy = ::Box::ApisPrx::uncheckedCast(__result->getProxy());
            ::Box::BinaryStream __p_outputBs;
            ::std::string __ret;
            try
            {
                __ret = __proxy->end_PEJsonFunc(__p_outputBs, __result);
            }
            catch(const ::Ice::Exception& ex)
            {
                Cpp11FnCallbackNC::exception(__result, ex);
                return;
            }
            if(_response != nullptr)
            {
                _response(__ret, __p_outputBs);
            }
        }
    
    private:
        
        ::std::function<void (const ::std::string&, const ::Box::BinaryStream&)> _response;
    };
    return begin_PEJsonFunc(__p_peHostIdent, __p_inputJson, __p_inputBs, __ctx, new Cpp11CB(__response, __exception, __sent));
}
#endif

::std::string
IceProxy::Box::Apis::end_PEJsonFunc(::Box::BinaryStream& __p_outputBs, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Box__Apis__PEJsonFunc_name);
    ::std::string __ret;
    if(!__result->__wait())
    {
        try
        {
            __result->__throwUserException();
        }
        catch(const ::Utils::OperationNotExistError&)
        {
            throw;
        }
        catch(const ::Utils::SystemError&)
        {
            throw;
        }
        catch(const ::Ice::UserException& __ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
        }
    }
    ::IceInternal::BasicStream* __is = __result->__startReadParams();
    __is->read(__p_outputBs);
    __is->read(__ret);
    __result->__endReadParams();
    return __ret;
}

const ::std::string&
IceProxy::Box::Apis::ice_staticId()
{
    return ::Box::Apis::ice_staticId();
}

::IceProxy::Ice::Object*
IceProxy::Box::Apis::__newInstance() const
{
    return new Apis;
}

::Ice::Object* Box::upCast(::Box::Apis* p) { return p; }

namespace
{
const ::std::string __Box__Apis_ids[2] =
{
    "::Box::Apis",
    "::Ice::Object"
};

}

bool
Box::Apis::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Box__Apis_ids, __Box__Apis_ids + 2, _s);
}

::std::vector< ::std::string>
Box::Apis::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Box__Apis_ids[0], &__Box__Apis_ids[2]);
}

const ::std::string&
Box::Apis::ice_id(const ::Ice::Current&) const
{
    return __Box__Apis_ids[0];
}

const ::std::string&
Box::Apis::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::Box::Apis";
    return typeId;
#else
    return __Box__Apis_ids[0];
#endif
}

::Ice::DispatchStatus
Box::Apis::___ping(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ping(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Box::Apis::___reloginAllHostSession(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int __p_delaySeconds;
    __is->read(__p_delaySeconds);
    __inS.endReadParams();
    reloginAllHostSession(__p_delaySeconds, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Box::Apis::___isAgentLinked(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    __is->read(__p_hostName);
    __inS.endReadParams();
    bool __ret = isAgentLinked(__p_hostName, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Box::Apis::___GetStatus(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    __is->read(__p_hostName);
    __inS.endReadParams();
    ::BoxLogic::AgentStatus __ret = GetStatus(__p_hostName, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Box::Apis::___queryDisksStatus(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    __is->read(__p_hostName);
    __inS.endReadParams();
    ::BoxLogic::Disks __p_disks;
    IceUtil::Optional< ::std::string> __p_more;
    try
    {
        queryDisksStatus(__p_hostName, __p_disks, __p_more, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_disks);
        __os->write(1, __p_more);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___JsonFunc(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    ::std::string __p_inputParam;
    __is->read(__p_hostName);
    __is->read(__p_inputParam);
    __inS.endReadParams();
    try
    {
        ::std::string __ret = JsonFunc(__p_hostName, __p_inputParam, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___querySystemInfo(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    __is->read(__p_hostName);
    __inS.endReadParams();
    try
    {
        ::std::string __ret = querySystemInfo(__p_hostName, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___backup(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    ::Box::BackupFiles __p_images;
    ::Ice::Int __p_kiloBytesPerSecond;
    IceUtil::Optional< ::std::string> __p_jsonConfig;
    __is->read(__p_hostName);
    __is->read(__p_images);
    __is->read(__p_kiloBytesPerSecond);
    __is->read(1, __p_jsonConfig);
    __inS.endReadParams();
    try
    {
        backup(__p_hostName, __p_images, __p_kiloBytesPerSecond, __p_jsonConfig, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::CreateSnapshotImageError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___forceCloseBackupFiles(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::StringSeq __p_files;
    __is->read(__p_files);
    __inS.endReadParams();
    forceCloseBackupFiles(__p_files, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Box::Apis::___getBackupInfo(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    ::std::string __p_inputJson;
    __is->read(__p_hostName);
    __is->read(__p_inputJson);
    __inS.endReadParams();
    try
    {
        ::std::string __ret = getBackupInfo(__p_hostName, __p_inputJson, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___setBackupInfo(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    ::std::string __p_inputJson;
    __is->read(__p_hostName);
    __is->read(__p_inputJson);
    __inS.endReadParams();
    try
    {
        setBackupInfo(__p_hostName, __p_inputJson, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___queryLastBackupError(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    __is->read(__p_hostName);
    __inS.endReadParams();
    ::std::string __ret = queryLastBackupError(__p_hostName, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Box::Apis::___queryLastCdpError(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    __is->read(__p_hostName);
    __inS.endReadParams();
    ::std::string __ret = queryLastCdpError(__p_hostName, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Box::Apis::___stopCdpStatus(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    __is->read(__p_hostName);
    __inS.endReadParams();
    try
    {
        stopCdpStatus(__p_hostName, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___volumeRestore(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    ::std::string __p_jsonConfig;
    ::Box::RestoreFiles __p_images;
    ::std::string __p_dummyHost;
    __is->read(__p_hostName);
    __is->read(__p_jsonConfig);
    __is->read(__p_images);
    __is->read(__p_dummyHost);
    __inS.endReadParams();
    try
    {
        volumeRestore(__p_hostName, __p_jsonConfig, __p_images, __p_dummyHost, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___restore(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    ::PerpcIce::PeRestoreInfo __p_info;
    ::Box::RestoreFiles __p_images;
    ::std::string __p_jsonConfig;
    __is->read(__p_hostName);
    __is->read(__p_info);
    __is->read(__p_images);
    __is->read(__p_jsonConfig);
    __inS.endReadParams();
    try
    {
        restore(__p_hostName, __p_info, __p_images, __p_jsonConfig, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___setBootDataList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    ::std::string __p_filePath;
    __is->read(__p_hostName);
    __is->read(__p_filePath);
    __inS.endReadParams();
    try
    {
        setBootDataList(__p_hostName, __p_filePath, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___notifyHighPriority(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Long __p_imageFileHandle;
    ::Ice::Long __p_byteOffset;
    __is->read(__p_imageFileHandle);
    __is->read(__p_byteOffset);
    __inS.endReadParams();
    try
    {
        notifyHighPriority(__p_imageFileHandle, __p_byteOffset, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___ReadDiskWithPeHost(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_peHostIdent;
    ::std::string __p_token;
    ::Ice::Long __p_sectorOffset;
    ::Ice::Int __p_sectors;
    __is->read(__p_peHostIdent);
    __is->read(__p_token);
    __is->read(__p_sectorOffset);
    __is->read(__p_sectors);
    __inS.endReadParams();
    ::Box::BinaryStream __p_data;
    try
    {
        ::Ice::Int __ret = ReadDiskWithPeHost(__p_peHostIdent, __p_token, __p_sectorOffset, __p_sectors, __p_data, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_data);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___WriteDiskWithPeHost(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_peHostIdent;
    ::std::string __p_token;
    ::Ice::Long __p_sectorOffset;
    ::Ice::Int __p_sectors;
    ::Box::BinaryStream __p_data;
    __is->read(__p_peHostIdent);
    __is->read(__p_token);
    __is->read(__p_sectorOffset);
    __is->read(__p_sectors);
    __is->read(__p_data);
    __inS.endReadParams();
    try
    {
        ::Ice::Int __ret = WriteDiskWithPeHost(__p_peHostIdent, __p_token, __p_sectorOffset, __p_sectors, __p_data, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___QueryRWDiskWithPeHost(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_peHostIdent;
    __is->read(__p_peHostIdent);
    __inS.endReadParams();
    ::Ice::Long __p_totalSectors;
    ::Ice::Long __p_sentSectors;
    try
    {
        bool __ret = QueryRWDiskWithPeHost(__p_peHostIdent, __p_totalSectors, __p_sentSectors, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_totalSectors);
        __os->write(__p_sentSectors);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___KvmStopped(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_peHostIdent;
    __is->read(__p_peHostIdent);
    __inS.endReadParams();
    try
    {
        KvmStopped(__p_peHostIdent, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___GetPeHostClassHWInfo(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_peHostIdent;
    ::std::string __p_classname;
    ::Ice::Int __p_parentLevel;
    __is->read(__p_peHostIdent);
    __is->read(__p_classname);
    __is->read(__p_parentLevel);
    __inS.endReadParams();
    ::PerpcIce::HWInfos __p_hwinfo;
    try
    {
        ::Ice::Int __ret = GetPeHostClassHWInfo(__p_peHostIdent, __p_classname, __p_parentLevel, __p_hwinfo, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_hwinfo);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___GetPeHostNetAdapterInfo(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_peHostIdent;
    __is->read(__p_peHostIdent);
    __inS.endReadParams();
    ::PerpcIce::NetAdapterInfos __p_adapterInfos;
    try
    {
        ::Ice::Int __ret = GetPeHostNetAdapterInfo(__p_peHostIdent, __p_adapterInfos, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_adapterInfos);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___isPeHostLinked(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_peHostName;
    __is->read(__p_peHostName);
    __inS.endReadParams();
    bool __ret = isPeHostLinked(__p_peHostName, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Box::Apis::___StartAgentPe(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    __is->read(__p_hostName);
    __inS.endReadParams();
    try
    {
        ::std::string __ret = StartAgentPe(__p_hostName, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___fetchAgentDebugFile(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    ::std::string __p_path;
    __is->read(__p_hostName);
    __is->read(__p_path);
    __inS.endReadParams();
    try
    {
        fetchAgentDebugFile(__p_hostName, __p_path, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___queryRunnerAbsPathOnAgentSetup(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_session;
    __is->read(__p_session);
    __inS.endReadParams();
    try
    {
        ::std::string __ret = queryRunnerAbsPathOnAgentSetup(__p_session, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___prepareInfoOnAgentSetup(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_session;
    ::std::string __p_flagJson;
    __is->read(__p_session);
    __is->read(__p_flagJson);
    __inS.endReadParams();
    try
    {
        ::std::string __ret = prepareInfoOnAgentSetup(__p_session, __p_flagJson, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___getFileInfoOnAgentSetup(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_session;
    ::std::string __p_fileName;
    ::std::string __p_flagJson;
    __is->read(__p_session);
    __is->read(__p_fileName);
    __is->read(__p_flagJson);
    __inS.endReadParams();
    try
    {
        ::std::string __ret = getFileInfoOnAgentSetup(__p_session, __p_fileName, __p_flagJson, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___searchBootFileAbsPathOnAgentSetup(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_session;
    __is->read(__p_session);
    __inS.endReadParams();
    try
    {
        ::std::string __ret = searchBootFileAbsPathOnAgentSetup(__p_session, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___generateKeyInfosOnAgentSetup(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_session;
    ::std::string __p_absFilePath;
    ::std::string __p_flagJson;
    __is->read(__p_session);
    __is->read(__p_absFilePath);
    __is->read(__p_flagJson);
    __inS.endReadParams();
    try
    {
        generateKeyInfosOnAgentSetup(__p_session, __p_absFilePath, __p_flagJson, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___openOnAgentSetup(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_session;
    ::std::string __p_absFilePath;
    ::std::string __p_flagJson;
    __is->read(__p_session);
    __is->read(__p_absFilePath);
    __is->read(__p_flagJson);
    __inS.endReadParams();
    try
    {
        ::std::string __ret = openOnAgentSetup(__p_session, __p_absFilePath, __p_flagJson, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___preadOnAgentSetup(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_session;
    ::std::string __p_handle;
    ::Ice::Long __p_byteOffset;
    ::Ice::Int __p_bytes;
    __is->read(__p_session);
    __is->read(__p_handle);
    __is->read(__p_byteOffset);
    __is->read(__p_bytes);
    __inS.endReadParams();
    try
    {
        ::Ice::ByteSeq __ret = preadOnAgentSetup(__p_session, __p_handle, __p_byteOffset, __p_bytes, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___pwriteOnAgentSetup(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_session;
    ::std::string __p_handle;
    ::Ice::Long __p_byteOffset;
    ::Ice::Int __p_bytes;
    ::Ice::ByteSeq __p_data;
    __is->read(__p_session);
    __is->read(__p_handle);
    __is->read(__p_byteOffset);
    __is->read(__p_bytes);
    __is->read(__p_data);
    __inS.endReadParams();
    try
    {
        pwriteOnAgentSetup(__p_session, __p_handle, __p_byteOffset, __p_bytes, __p_data, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___closeOnAgentSetup(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_session;
    ::std::string __p_handle;
    __is->read(__p_session);
    __is->read(__p_handle);
    __inS.endReadParams();
    try
    {
        closeOnAgentSetup(__p_session, __p_handle, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___extractFileOnAgentSetup(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_session;
    ::std::string __p_absSourceFilePath;
    ::std::string __p_absDestinationPath;
    ::std::string __p_flagJson;
    __is->read(__p_session);
    __is->read(__p_absSourceFilePath);
    __is->read(__p_absDestinationPath);
    __is->read(__p_flagJson);
    __inS.endReadParams();
    try
    {
        extractFileOnAgentSetup(__p_session, __p_absSourceFilePath, __p_absDestinationPath, __p_flagJson, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___executeCommandOnAgentSetup(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_session;
    ::std::string __p_cmd;
    ::std::string __p_flagJson;
    __is->read(__p_session);
    __is->read(__p_cmd);
    __is->read(__p_flagJson);
    __inS.endReadParams();
    ::Ice::StringSeq __p_stdout;
    ::Ice::StringSeq __p_stderr;
    try
    {
        ::Ice::Int __ret = executeCommandOnAgentSetup(__p_session, __p_cmd, __p_flagJson, __p_stdout, __p_stderr, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_stdout);
        __os->write(__p_stderr);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___reportStatusOnAgentSetup(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_session;
    ::std::string __p_contentJson;
    __is->read(__p_session);
    __is->read(__p_contentJson);
    __inS.endReadParams();
    try
    {
        reportStatusOnAgentSetup(__p_session, __p_contentJson, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___exitOnAgentSetup(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_session;
    ::Ice::Int __p_returnCode;
    __is->read(__p_session);
    __is->read(__p_returnCode);
    __inS.endReadParams();
    try
    {
        exitOnAgentSetup(__p_session, __p_returnCode, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___forceOfflineAgent(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    __is->read(__p_hostName);
    __inS.endReadParams();
    try
    {
        forceOfflineAgent(__p_hostName, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___forceOfflinePeHost(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_peHostIdent;
    __is->read(__p_peHostIdent);
    __inS.endReadParams();
    try
    {
        forceOfflinePeHost(__p_peHostIdent, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___refreshNetwork(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    refreshNetwork(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Box::Apis::___GetServiceList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    __is->read(__p_hostName);
    __inS.endReadParams();
    ::Box::ServiceInfoStatusS __p_ServiceList;
    try
    {
        ::Ice::Int __ret = GetServiceList(__p_hostName, __p_ServiceList, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_ServiceList);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___GetTcpListenList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    ::Box::vectorINT __p_portList;
    __is->read(__p_hostName);
    __is->read(__p_portList);
    __inS.endReadParams();
    ::Box::vectorINT __p_pidList;
    try
    {
        ::Ice::Int __ret = GetTcpListenList(__p_hostName, __p_portList, __p_pidList, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_pidList);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___StartServiceSync(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    ::std::string __p_ServiceName;
    __is->read(__p_hostName);
    __is->read(__p_ServiceName);
    __inS.endReadParams();
    try
    {
        ::Ice::Int __ret = StartServiceSync(__p_hostName, __p_ServiceName, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___StopServiceSync(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    ::std::string __p_ServiceName;
    __is->read(__p_hostName);
    __is->read(__p_ServiceName);
    __inS.endReadParams();
    try
    {
        ::Ice::Int __ret = StopServiceSync(__p_hostName, __p_ServiceName, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___StartHttpDServiceAsync(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    ::Ice::Int __p_port;
    ::Box::BinaryStream __p_bs;
    __is->read(__p_hostName);
    __is->read(__p_port);
    __is->read(__p_bs);
    __inS.endReadParams();
    try
    {
        ::Ice::Int __ret = StartHttpDServiceAsync(__p_hostName, __p_port, __p_bs, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___GetHttpDServiceListSync(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    __is->read(__p_hostName);
    __inS.endReadParams();
    ::Box::vectorINT __p_pidList;
    try
    {
        ::Ice::Int __ret = GetHttpDServiceListSync(__p_hostName, __p_pidList, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_pidList);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___StopAllHttpDServiceSync(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    __is->read(__p_hostName);
    __inS.endReadParams();
    try
    {
        ::Ice::Int __ret = StopAllHttpDServiceSync(__p_hostName, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___testDisk(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    ::Ice::Int __p_diskIndex;
    ::Ice::Long __p_sectorOffset;
    ::Ice::Short __p_numberOfSectors;
    __is->read(__p_hostName);
    __is->read(__p_diskIndex);
    __is->read(__p_sectorOffset);
    __is->read(__p_numberOfSectors);
    __inS.endReadParams();
    try
    {
        ::Ice::Int __ret = testDisk(__p_hostName, __p_diskIndex, __p_sectorOffset, __p_numberOfSectors, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___readDisk(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    ::Ice::Int __p_diskIndex;
    ::Ice::Long __p_sectorOffset;
    ::Ice::Short __p_numberOfSectors;
    __is->read(__p_hostName);
    __is->read(__p_diskIndex);
    __is->read(__p_sectorOffset);
    __is->read(__p_numberOfSectors);
    __inS.endReadParams();
    ::Box::BinaryStream __p_bs;
    try
    {
        ::Ice::Int __ret = readDisk(__p_hostName, __p_diskIndex, __p_sectorOffset, __p_numberOfSectors, __p_bs, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_bs);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___writeDisk(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    ::Ice::Int __p_diskIndex;
    ::Ice::Long __p_sectorOffset;
    ::Ice::Short __p_numberOfSector;
    ::Box::BinaryStream __p_bs;
    __is->read(__p_hostName);
    __is->read(__p_diskIndex);
    __is->read(__p_sectorOffset);
    __is->read(__p_numberOfSector);
    __is->read(__p_bs);
    __inS.endReadParams();
    try
    {
        ::Ice::Int __ret = writeDisk(__p_hostName, __p_diskIndex, __p_sectorOffset, __p_numberOfSector, __p_bs, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___JsonFuncV2(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_hostName;
    ::std::string __p_inputJson;
    ::Box::BinaryStream __p_inputBs;
    __is->read(__p_hostName);
    __is->read(__p_inputJson);
    __is->read(__p_inputBs);
    __inS.endReadParams();
    ::Box::BinaryStream __p_outputBs;
    try
    {
        ::std::string __ret = JsonFuncV2(__p_hostName, __p_inputJson, __p_inputBs, __p_outputBs, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_outputBs);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Box::Apis::___PEJsonFunc(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string __p_peHostIdent;
    ::std::string __p_inputJson;
    ::Box::BinaryStream __p_inputBs;
    __is->read(__p_peHostIdent);
    __is->read(__p_inputJson);
    __is->read(__p_inputBs);
    __inS.endReadParams();
    ::Box::BinaryStream __p_outputBs;
    try
    {
        ::std::string __ret = PEJsonFunc(__p_peHostIdent, __p_inputJson, __p_inputBs, __p_outputBs, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__p_outputBs);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::OperationNotExistError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __Box__Apis_all[] =
{
    "GetHttpDServiceListSync",
    "GetPeHostClassHWInfo",
    "GetPeHostNetAdapterInfo",
    "GetServiceList",
    "GetStatus",
    "GetTcpListenList",
    "JsonFunc",
    "JsonFuncV2",
    "KvmStopped",
    "PEJsonFunc",
    "QueryRWDiskWithPeHost",
    "ReadDiskWithPeHost",
    "StartAgentPe",
    "StartHttpDServiceAsync",
    "StartServiceSync",
    "StopAllHttpDServiceSync",
    "StopServiceSync",
    "WriteDiskWithPeHost",
    "backup",
    "closeOnAgentSetup",
    "executeCommandOnAgentSetup",
    "exitOnAgentSetup",
    "extractFileOnAgentSetup",
    "fetchAgentDebugFile",
    "forceCloseBackupFiles",
    "forceOfflineAgent",
    "forceOfflinePeHost",
    "generateKeyInfosOnAgentSetup",
    "getBackupInfo",
    "getFileInfoOnAgentSetup",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "isAgentLinked",
    "isPeHostLinked",
    "notifyHighPriority",
    "openOnAgentSetup",
    "ping",
    "preadOnAgentSetup",
    "prepareInfoOnAgentSetup",
    "pwriteOnAgentSetup",
    "queryDisksStatus",
    "queryLastBackupError",
    "queryLastCdpError",
    "queryRunnerAbsPathOnAgentSetup",
    "querySystemInfo",
    "readDisk",
    "refreshNetwork",
    "reloginAllHostSession",
    "reportStatusOnAgentSetup",
    "restore",
    "searchBootFileAbsPathOnAgentSetup",
    "setBackupInfo",
    "setBootDataList",
    "stopCdpStatus",
    "testDisk",
    "volumeRestore",
    "writeDisk"
};

}

::Ice::DispatchStatus
Box::Apis::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Box__Apis_all, __Box__Apis_all + 59, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Box__Apis_all)
    {
        case 0:
        {
            return ___GetHttpDServiceListSync(in, current);
        }
        case 1:
        {
            return ___GetPeHostClassHWInfo(in, current);
        }
        case 2:
        {
            return ___GetPeHostNetAdapterInfo(in, current);
        }
        case 3:
        {
            return ___GetServiceList(in, current);
        }
        case 4:
        {
            return ___GetStatus(in, current);
        }
        case 5:
        {
            return ___GetTcpListenList(in, current);
        }
        case 6:
        {
            return ___JsonFunc(in, current);
        }
        case 7:
        {
            return ___JsonFuncV2(in, current);
        }
        case 8:
        {
            return ___KvmStopped(in, current);
        }
        case 9:
        {
            return ___PEJsonFunc(in, current);
        }
        case 10:
        {
            return ___QueryRWDiskWithPeHost(in, current);
        }
        case 11:
        {
            return ___ReadDiskWithPeHost(in, current);
        }
        case 12:
        {
            return ___StartAgentPe(in, current);
        }
        case 13:
        {
            return ___StartHttpDServiceAsync(in, current);
        }
        case 14:
        {
            return ___StartServiceSync(in, current);
        }
        case 15:
        {
            return ___StopAllHttpDServiceSync(in, current);
        }
        case 16:
        {
            return ___StopServiceSync(in, current);
        }
        case 17:
        {
            return ___WriteDiskWithPeHost(in, current);
        }
        case 18:
        {
            return ___backup(in, current);
        }
        case 19:
        {
            return ___closeOnAgentSetup(in, current);
        }
        case 20:
        {
            return ___executeCommandOnAgentSetup(in, current);
        }
        case 21:
        {
            return ___exitOnAgentSetup(in, current);
        }
        case 22:
        {
            return ___extractFileOnAgentSetup(in, current);
        }
        case 23:
        {
            return ___fetchAgentDebugFile(in, current);
        }
        case 24:
        {
            return ___forceCloseBackupFiles(in, current);
        }
        case 25:
        {
            return ___forceOfflineAgent(in, current);
        }
        case 26:
        {
            return ___forceOfflinePeHost(in, current);
        }
        case 27:
        {
            return ___generateKeyInfosOnAgentSetup(in, current);
        }
        case 28:
        {
            return ___getBackupInfo(in, current);
        }
        case 29:
        {
            return ___getFileInfoOnAgentSetup(in, current);
        }
        case 30:
        {
            return ___ice_id(in, current);
        }
        case 31:
        {
            return ___ice_ids(in, current);
        }
        case 32:
        {
            return ___ice_isA(in, current);
        }
        case 33:
        {
            return ___ice_ping(in, current);
        }
        case 34:
        {
            return ___isAgentLinked(in, current);
        }
        case 35:
        {
            return ___isPeHostLinked(in, current);
        }
        case 36:
        {
            return ___notifyHighPriority(in, current);
        }
        case 37:
        {
            return ___openOnAgentSetup(in, current);
        }
        case 38:
        {
            return ___ping(in, current);
        }
        case 39:
        {
            return ___preadOnAgentSetup(in, current);
        }
        case 40:
        {
            return ___prepareInfoOnAgentSetup(in, current);
        }
        case 41:
        {
            return ___pwriteOnAgentSetup(in, current);
        }
        case 42:
        {
            return ___queryDisksStatus(in, current);
        }
        case 43:
        {
            return ___queryLastBackupError(in, current);
        }
        case 44:
        {
            return ___queryLastCdpError(in, current);
        }
        case 45:
        {
            return ___queryRunnerAbsPathOnAgentSetup(in, current);
        }
        case 46:
        {
            return ___querySystemInfo(in, current);
        }
        case 47:
        {
            return ___readDisk(in, current);
        }
        case 48:
        {
            return ___refreshNetwork(in, current);
        }
        case 49:
        {
            return ___reloginAllHostSession(in, current);
        }
        case 50:
        {
            return ___reportStatusOnAgentSetup(in, current);
        }
        case 51:
        {
            return ___restore(in, current);
        }
        case 52:
        {
            return ___searchBootFileAbsPathOnAgentSetup(in, current);
        }
        case 53:
        {
            return ___setBackupInfo(in, current);
        }
        case 54:
        {
            return ___setBootDataList(in, current);
        }
        case 55:
        {
            return ___stopCdpStatus(in, current);
        }
        case 56:
        {
            return ___testDisk(in, current);
        }
        case 57:
        {
            return ___volumeRestore(in, current);
        }
        case 58:
        {
            return ___writeDisk(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Box::Apis::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Box::Apis::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Box::__patch(ApisPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Box::ApisPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Box::Apis::ice_staticId(), v);
    }
}
