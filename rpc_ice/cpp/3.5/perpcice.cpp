// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `perpcice.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <perpcice.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/BasicStream.h>
#include <Ice/Object.h>
#include <IceUtil/Iterator.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace
{

const ::std::string __PerpcIce__PeGuestReceiver__ReadDisk_name = "ReadDisk";

const ::std::string __PerpcIce__PeGuestReceiver__WriteDisk_name = "WriteDisk";

const ::std::string __PerpcIce__PeGuestReceiver__SetRestoreExcludeInfo_name = "SetRestoreExcludeInfo";

const ::std::string __PerpcIce__PeGuestReceiver__KvmEnd_name = "KvmEnd";

const ::std::string __PerpcIce__PeGuestReceiver__GetClassHWInfo_name = "GetClassHWInfo";

const ::std::string __PerpcIce__PeGuestReceiver__GetNetAdapterInfo_name = "GetNetAdapterInfo";

const ::std::string __PerpcIce__PeGuestReceiver__SetRestoreInfo_name = "SetRestoreInfo";

const ::std::string __PerpcIce__PeGuestReceiver__JsonFunc_name = "JsonFunc";

const ::std::string __PerpcIce__PeSession__InitiatePeReceiver_name = "InitiatePeReceiver";

const ::std::string __PerpcIce__PeSession__GetPeHostIdent_name = "GetPeHostIdent";

const ::std::string __PerpcIce__PeSession__UnInit_name = "UnInit";

const ::std::string __PerpcIce__PeSession__GetBootList_name = "GetBootList";

const ::std::string __PerpcIce__PeSession__GetKvmBitmapFile_name = "GetKvmBitmapFile";

const ::std::string __PerpcIce__PeSession__ReadDiskData_name = "ReadDiskData";

const ::std::string __PerpcIce__PeSession__ReadKvmBootData_name = "ReadKvmBootData";

const ::std::string __PerpcIce__PeSession__getUesdBlockBitmap_name = "getUesdBlockBitmap";

const ::std::string __PerpcIce__PeSession__Refresh_name = "Refresh";

const ::std::string __PerpcIce__PeSession__StartKvm_name = "StartKvm";

const ::std::string __PerpcIce__PeSession__destroy_name = "destroy";

const ::std::string __PerpcIce__PeSessionFactory__CreateSession_name = "CreateSession";

}

namespace Ice
{
}
::IceProxy::Ice::Object* ::IceProxy::PerpcIce::upCast(::IceProxy::PerpcIce::PeGuestReceiver* p) { return p; }

void
::IceProxy::PerpcIce::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::PerpcIce::PeGuestReceiver>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::PerpcIce::PeGuestReceiver;
        v->__copyFrom(proxy);
    }
}

::Ice::Int
IceProxy::PerpcIce::PeGuestReceiver::ReadDisk(const ::std::string& token, ::Ice::Long LBA, ::Ice::Int dwSectorCount, ::PerpcIce::BinaryStream& pBuf, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __PerpcIce__PeGuestReceiver__ReadDisk_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__PerpcIce__PeGuestReceiver__ReadDisk_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::PerpcIce::PeGuestReceiver* __del = dynamic_cast< ::IceDelegate::PerpcIce::PeGuestReceiver*>(__delBase.get());
            return __del->ReadDisk(token, LBA, dwSectorCount, pBuf, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeGuestReceiver::begin_ReadDisk(const ::std::string& token, ::Ice::Long LBA, ::Ice::Int dwSectorCount, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__PerpcIce__PeGuestReceiver__ReadDisk_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeGuestReceiver__ReadDisk_name, __del, __cookie);
    try
    {
        __result->__prepare(__PerpcIce__PeGuestReceiver__ReadDisk_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(token);
        __os->write(LBA);
        __os->write(dwSectorCount);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::PerpcIce::PeGuestReceiver::end_ReadDisk(::PerpcIce::BinaryStream& pBuf, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __PerpcIce__PeGuestReceiver__ReadDisk_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Utils::SystemError&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(pBuf);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::PerpcIce::PeGuestReceiver::WriteDisk(const ::std::string& token, ::Ice::Long LBA, ::Ice::Int dwSectorCount, const ::PerpcIce::BinaryStream& pBuf, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __PerpcIce__PeGuestReceiver__WriteDisk_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__PerpcIce__PeGuestReceiver__WriteDisk_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::PerpcIce::PeGuestReceiver* __del = dynamic_cast< ::IceDelegate::PerpcIce::PeGuestReceiver*>(__delBase.get());
            return __del->WriteDisk(token, LBA, dwSectorCount, pBuf, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeGuestReceiver::begin_WriteDisk(const ::std::string& token, ::Ice::Long LBA, ::Ice::Int dwSectorCount, const ::PerpcIce::BinaryStream& pBuf, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__PerpcIce__PeGuestReceiver__WriteDisk_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeGuestReceiver__WriteDisk_name, __del, __cookie);
    try
    {
        __result->__prepare(__PerpcIce__PeGuestReceiver__WriteDisk_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(token);
        __os->write(LBA);
        __os->write(dwSectorCount);
        __os->write(pBuf);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::PerpcIce::PeGuestReceiver::end_WriteDisk(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __PerpcIce__PeGuestReceiver__WriteDisk_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Utils::SystemError&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::PerpcIce::PeGuestReceiver::SetRestoreExcludeInfo(const ::PerpcIce::ExcludeBrokenBlocks& brokenBlocks, const ::PerpcIce::ExcludeBlockRuns& blockRuns, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __PerpcIce__PeGuestReceiver__SetRestoreExcludeInfo_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__PerpcIce__PeGuestReceiver__SetRestoreExcludeInfo_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::PerpcIce::PeGuestReceiver* __del = dynamic_cast< ::IceDelegate::PerpcIce::PeGuestReceiver*>(__delBase.get());
            __del->SetRestoreExcludeInfo(brokenBlocks, blockRuns, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeGuestReceiver::begin_SetRestoreExcludeInfo(const ::PerpcIce::ExcludeBrokenBlocks& brokenBlocks, const ::PerpcIce::ExcludeBlockRuns& blockRuns, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__PerpcIce__PeGuestReceiver__SetRestoreExcludeInfo_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeGuestReceiver__SetRestoreExcludeInfo_name, __del, __cookie);
    try
    {
        __result->__prepare(__PerpcIce__PeGuestReceiver__SetRestoreExcludeInfo_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(brokenBlocks);
        __os->write(blockRuns);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::PerpcIce::PeGuestReceiver::end_SetRestoreExcludeInfo(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __PerpcIce__PeGuestReceiver__SetRestoreExcludeInfo_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Utils::SystemError&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::PerpcIce::PeGuestReceiver::KvmEnd(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __PerpcIce__PeGuestReceiver__KvmEnd_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__PerpcIce__PeGuestReceiver__KvmEnd_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::PerpcIce::PeGuestReceiver* __del = dynamic_cast< ::IceDelegate::PerpcIce::PeGuestReceiver*>(__delBase.get());
            __del->KvmEnd(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeGuestReceiver::begin_KvmEnd(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__PerpcIce__PeGuestReceiver__KvmEnd_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeGuestReceiver__KvmEnd_name, __del, __cookie);
    try
    {
        __result->__prepare(__PerpcIce__PeGuestReceiver__KvmEnd_name, ::Ice::Idempotent, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::PerpcIce::PeGuestReceiver::end_KvmEnd(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __PerpcIce__PeGuestReceiver__KvmEnd_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Utils::SystemError&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::PerpcIce::PeGuestReceiver::GetClassHWInfo(const ::std::string& classname, ::Ice::Int requestParentLevel, ::PerpcIce::HWInfos& hwinfo, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __PerpcIce__PeGuestReceiver__GetClassHWInfo_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__PerpcIce__PeGuestReceiver__GetClassHWInfo_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::PerpcIce::PeGuestReceiver* __del = dynamic_cast< ::IceDelegate::PerpcIce::PeGuestReceiver*>(__delBase.get());
            return __del->GetClassHWInfo(classname, requestParentLevel, hwinfo, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeGuestReceiver::begin_GetClassHWInfo(const ::std::string& classname, ::Ice::Int requestParentLevel, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__PerpcIce__PeGuestReceiver__GetClassHWInfo_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeGuestReceiver__GetClassHWInfo_name, __del, __cookie);
    try
    {
        __result->__prepare(__PerpcIce__PeGuestReceiver__GetClassHWInfo_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(classname);
        __os->write(requestParentLevel);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::PerpcIce::PeGuestReceiver::end_GetClassHWInfo(::PerpcIce::HWInfos& hwinfo, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __PerpcIce__PeGuestReceiver__GetClassHWInfo_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Utils::SystemError&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(hwinfo);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::PerpcIce::PeGuestReceiver::GetNetAdapterInfo(::PerpcIce::NetAdapterInfos& adapterInfos, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __PerpcIce__PeGuestReceiver__GetNetAdapterInfo_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__PerpcIce__PeGuestReceiver__GetNetAdapterInfo_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::PerpcIce::PeGuestReceiver* __del = dynamic_cast< ::IceDelegate::PerpcIce::PeGuestReceiver*>(__delBase.get());
            return __del->GetNetAdapterInfo(adapterInfos, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeGuestReceiver::begin_GetNetAdapterInfo(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__PerpcIce__PeGuestReceiver__GetNetAdapterInfo_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeGuestReceiver__GetNetAdapterInfo_name, __del, __cookie);
    try
    {
        __result->__prepare(__PerpcIce__PeGuestReceiver__GetNetAdapterInfo_name, ::Ice::Idempotent, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::PerpcIce::PeGuestReceiver::end_GetNetAdapterInfo(::PerpcIce::NetAdapterInfos& adapterInfos, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __PerpcIce__PeGuestReceiver__GetNetAdapterInfo_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Utils::SystemError&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(adapterInfos);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::PerpcIce::PeGuestReceiver::SetRestoreInfo(const ::PerpcIce::PeRestoreInfo& restoreInfo, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __PerpcIce__PeGuestReceiver__SetRestoreInfo_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__PerpcIce__PeGuestReceiver__SetRestoreInfo_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::PerpcIce::PeGuestReceiver* __del = dynamic_cast< ::IceDelegate::PerpcIce::PeGuestReceiver*>(__delBase.get());
            __del->SetRestoreInfo(restoreInfo, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeGuestReceiver::begin_SetRestoreInfo(const ::PerpcIce::PeRestoreInfo& restoreInfo, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__PerpcIce__PeGuestReceiver__SetRestoreInfo_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeGuestReceiver__SetRestoreInfo_name, __del, __cookie);
    try
    {
        __result->__prepare(__PerpcIce__PeGuestReceiver__SetRestoreInfo_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(restoreInfo);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::PerpcIce::PeGuestReceiver::end_SetRestoreInfo(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __PerpcIce__PeGuestReceiver__SetRestoreInfo_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Utils::SystemError&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::std::string
IceProxy::PerpcIce::PeGuestReceiver::JsonFunc(const ::std::string& inputJson, const ::PerpcIce::BinaryStream& inputBs, ::PerpcIce::BinaryStream& outputBs, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __PerpcIce__PeGuestReceiver__JsonFunc_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__PerpcIce__PeGuestReceiver__JsonFunc_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::PerpcIce::PeGuestReceiver* __del = dynamic_cast< ::IceDelegate::PerpcIce::PeGuestReceiver*>(__delBase.get());
            return __del->JsonFunc(inputJson, inputBs, outputBs, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeGuestReceiver::begin_JsonFunc(const ::std::string& inputJson, const ::PerpcIce::BinaryStream& inputBs, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__PerpcIce__PeGuestReceiver__JsonFunc_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeGuestReceiver__JsonFunc_name, __del, __cookie);
    try
    {
        __result->__prepare(__PerpcIce__PeGuestReceiver__JsonFunc_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(inputJson);
        __os->write(inputBs);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::std::string
IceProxy::PerpcIce::PeGuestReceiver::end_JsonFunc(::PerpcIce::BinaryStream& outputBs, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __PerpcIce__PeGuestReceiver__JsonFunc_name);
    ::std::string __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Utils::SystemError&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(outputBs);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::PerpcIce::PeGuestReceiver::ice_staticId()
{
    return ::PerpcIce::PeGuestReceiver::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::PerpcIce::PeGuestReceiver::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::PerpcIce::PeGuestReceiver);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::PerpcIce::PeGuestReceiver::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::PerpcIce::PeGuestReceiver);
}

::IceProxy::Ice::Object*
IceProxy::PerpcIce::PeGuestReceiver::__newInstance() const
{
    return new PeGuestReceiver;
}
::IceProxy::Ice::Object* ::IceProxy::PerpcIce::upCast(::IceProxy::PerpcIce::PeSession* p) { return p; }

void
::IceProxy::PerpcIce::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::PerpcIce::PeSession>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::PerpcIce::PeSession;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::PerpcIce::PeSession::InitiatePeReceiver(const ::Ice::Identity& ident, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __PerpcIce__PeSession__InitiatePeReceiver_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__PerpcIce__PeSession__InitiatePeReceiver_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::PerpcIce::PeSession* __del = dynamic_cast< ::IceDelegate::PerpcIce::PeSession*>(__delBase.get());
            __del->InitiatePeReceiver(ident, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeSession::begin_InitiatePeReceiver(const ::Ice::Identity& ident, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__PerpcIce__PeSession__InitiatePeReceiver_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeSession__InitiatePeReceiver_name, __del, __cookie);
    try
    {
        __result->__prepare(__PerpcIce__PeSession__InitiatePeReceiver_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(ident);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::PerpcIce::PeSession::end_InitiatePeReceiver(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __PerpcIce__PeSession__InitiatePeReceiver_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Utils::SystemError&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::PerpcIce::PeSession::GetPeHostIdent(::std::string& peHostIdent, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __PerpcIce__PeSession__GetPeHostIdent_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__PerpcIce__PeSession__GetPeHostIdent_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::PerpcIce::PeSession* __del = dynamic_cast< ::IceDelegate::PerpcIce::PeSession*>(__delBase.get());
            __del->GetPeHostIdent(peHostIdent, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeSession::begin_GetPeHostIdent(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__PerpcIce__PeSession__GetPeHostIdent_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeSession__GetPeHostIdent_name, __del, __cookie);
    try
    {
        __result->__prepare(__PerpcIce__PeSession__GetPeHostIdent_name, ::Ice::Idempotent, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::PerpcIce::PeSession::end_GetPeHostIdent(::std::string& peHostIdent, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __PerpcIce__PeSession__GetPeHostIdent_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(peHostIdent);
        __result->__endReadParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::PerpcIce::PeSession::UnInit(::Ice::Int dwStatus, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __PerpcIce__PeSession__UnInit_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::PerpcIce::PeSession* __del = dynamic_cast< ::IceDelegate::PerpcIce::PeSession*>(__delBase.get());
            __del->UnInit(dwStatus, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeSession::begin_UnInit(::Ice::Int dwStatus, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeSession__UnInit_name, __del, __cookie);
    try
    {
        __result->__prepare(__PerpcIce__PeSession__UnInit_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(dwStatus);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::PerpcIce::PeSession::end_UnInit(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __PerpcIce__PeSession__UnInit_name);
}

::Ice::Int
IceProxy::PerpcIce::PeSession::GetBootList(::Ice::Int index, ::std::string& bootlist, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __PerpcIce__PeSession__GetBootList_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__PerpcIce__PeSession__GetBootList_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::PerpcIce::PeSession* __del = dynamic_cast< ::IceDelegate::PerpcIce::PeSession*>(__delBase.get());
            return __del->GetBootList(index, bootlist, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeSession::begin_GetBootList(::Ice::Int index, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__PerpcIce__PeSession__GetBootList_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeSession__GetBootList_name, __del, __cookie);
    try
    {
        __result->__prepare(__PerpcIce__PeSession__GetBootList_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(index);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::PerpcIce::PeSession::end_GetBootList(::std::string& bootlist, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __PerpcIce__PeSession__GetBootList_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Utils::NeedRetryLaterError&)
            {
                throw;
            }
            catch(const ::Utils::SystemError&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(bootlist);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::PerpcIce::PeSession::GetKvmBitmapFile(::Ice::Int index, ::PerpcIce::BinaryStream& data, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __PerpcIce__PeSession__GetKvmBitmapFile_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__PerpcIce__PeSession__GetKvmBitmapFile_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::PerpcIce::PeSession* __del = dynamic_cast< ::IceDelegate::PerpcIce::PeSession*>(__delBase.get());
            return __del->GetKvmBitmapFile(index, data, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeSession::begin_GetKvmBitmapFile(::Ice::Int index, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__PerpcIce__PeSession__GetKvmBitmapFile_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeSession__GetKvmBitmapFile_name, __del, __cookie);
    try
    {
        __result->__prepare(__PerpcIce__PeSession__GetKvmBitmapFile_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(index);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::PerpcIce::PeSession::end_GetKvmBitmapFile(::PerpcIce::BinaryStream& data, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __PerpcIce__PeSession__GetKvmBitmapFile_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Utils::NeedRetryLaterError&)
            {
                throw;
            }
            catch(const ::Utils::SystemError&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(data);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::PerpcIce::PeSession::ReadDiskData(const ::std::string& token, ::Ice::Long LBA, ::Ice::Int dwSectorCount, ::PerpcIce::BinaryStream& pBuf, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __PerpcIce__PeSession__ReadDiskData_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__PerpcIce__PeSession__ReadDiskData_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::PerpcIce::PeSession* __del = dynamic_cast< ::IceDelegate::PerpcIce::PeSession*>(__delBase.get());
            return __del->ReadDiskData(token, LBA, dwSectorCount, pBuf, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeSession::begin_ReadDiskData(const ::std::string& token, ::Ice::Long LBA, ::Ice::Int dwSectorCount, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__PerpcIce__PeSession__ReadDiskData_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeSession__ReadDiskData_name, __del, __cookie);
    try
    {
        __result->__prepare(__PerpcIce__PeSession__ReadDiskData_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(token);
        __os->write(LBA);
        __os->write(dwSectorCount);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::PerpcIce::PeSession::end_ReadDiskData(::PerpcIce::BinaryStream& pBuf, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __PerpcIce__PeSession__ReadDiskData_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Utils::SystemError&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(pBuf);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::PerpcIce::PeSession::ReadKvmBootData(::Ice::Int threadIndex, ::Ice::Int blockIndex, bool& isEnd, bool& isSkip, ::std::string& diskToken, ::Ice::Long& LBA, ::Ice::Int& dwSectorCount, ::PerpcIce::BinaryStream& data, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __PerpcIce__PeSession__ReadKvmBootData_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__PerpcIce__PeSession__ReadKvmBootData_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::PerpcIce::PeSession* __del = dynamic_cast< ::IceDelegate::PerpcIce::PeSession*>(__delBase.get());
            return __del->ReadKvmBootData(threadIndex, blockIndex, isEnd, isSkip, diskToken, LBA, dwSectorCount, data, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeSession::begin_ReadKvmBootData(::Ice::Int threadIndex, ::Ice::Int blockIndex, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__PerpcIce__PeSession__ReadKvmBootData_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeSession__ReadKvmBootData_name, __del, __cookie);
    try
    {
        __result->__prepare(__PerpcIce__PeSession__ReadKvmBootData_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(threadIndex);
        __os->write(blockIndex);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::PerpcIce::PeSession::end_ReadKvmBootData(bool& isEnd, bool& isSkip, ::std::string& diskToken, ::Ice::Long& LBA, ::Ice::Int& dwSectorCount, ::PerpcIce::BinaryStream& data, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __PerpcIce__PeSession__ReadKvmBootData_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Utils::SystemError&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(isEnd);
        __is->read(isSkip);
        __is->read(diskToken);
        __is->read(LBA);
        __is->read(dwSectorCount);
        __is->read(data);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Ice::Int
IceProxy::PerpcIce::PeSession::getUesdBlockBitmap(const ::std::string& token, ::Ice::Int index, ::PerpcIce::BinaryStream& bitmap, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __PerpcIce__PeSession__getUesdBlockBitmap_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__PerpcIce__PeSession__getUesdBlockBitmap_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::PerpcIce::PeSession* __del = dynamic_cast< ::IceDelegate::PerpcIce::PeSession*>(__delBase.get());
            return __del->getUesdBlockBitmap(token, index, bitmap, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeSession::begin_getUesdBlockBitmap(const ::std::string& token, ::Ice::Int index, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__PerpcIce__PeSession__getUesdBlockBitmap_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeSession__getUesdBlockBitmap_name, __del, __cookie);
    try
    {
        __result->__prepare(__PerpcIce__PeSession__getUesdBlockBitmap_name, ::Ice::Idempotent, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(token);
        __os->write(index);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Ice::Int
IceProxy::PerpcIce::PeSession::end_getUesdBlockBitmap(::PerpcIce::BinaryStream& bitmap, const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __PerpcIce__PeSession__getUesdBlockBitmap_name);
    ::Ice::Int __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Utils::SystemError&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(bitmap);
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::PerpcIce::PeSession::Refresh(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __PerpcIce__PeSession__Refresh_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::PerpcIce::PeSession* __del = dynamic_cast< ::IceDelegate::PerpcIce::PeSession*>(__delBase.get());
            __del->Refresh(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapperRelaxed(__delBase, __ex, true, __cnt, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeSession::begin_Refresh(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeSession__Refresh_name, __del, __cookie);
    try
    {
        __result->__prepare(__PerpcIce__PeSession__Refresh_name, ::Ice::Idempotent, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::PerpcIce::PeSession::end_Refresh(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __PerpcIce__PeSession__Refresh_name);
}

void
IceProxy::PerpcIce::PeSession::StartKvm(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __PerpcIce__PeSession__StartKvm_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::PerpcIce::PeSession* __del = dynamic_cast< ::IceDelegate::PerpcIce::PeSession*>(__delBase.get());
            __del->StartKvm(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeSession::begin_StartKvm(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeSession__StartKvm_name, __del, __cookie);
    try
    {
        __result->__prepare(__PerpcIce__PeSession__StartKvm_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::PerpcIce::PeSession::end_StartKvm(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __PerpcIce__PeSession__StartKvm_name);
}

void
IceProxy::PerpcIce::PeSession::destroy(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __PerpcIce__PeSession__destroy_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::PerpcIce::PeSession* __del = dynamic_cast< ::IceDelegate::PerpcIce::PeSession*>(__delBase.get());
            __del->destroy(__ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeSession::begin_destroy(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeSession__destroy_name, __del, __cookie);
    try
    {
        __result->__prepare(__PerpcIce__PeSession__destroy_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::PerpcIce::PeSession::end_destroy(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __PerpcIce__PeSession__destroy_name);
}

const ::std::string&
IceProxy::PerpcIce::PeSession::ice_staticId()
{
    return ::PerpcIce::PeSession::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::PerpcIce::PeSession::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::PerpcIce::PeSession);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::PerpcIce::PeSession::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::PerpcIce::PeSession);
}

::IceProxy::Ice::Object*
IceProxy::PerpcIce::PeSession::__newInstance() const
{
    return new PeSession;
}
::IceProxy::Ice::Object* ::IceProxy::PerpcIce::upCast(::IceProxy::PerpcIce::PeSessionFactory* p) { return p; }

void
::IceProxy::PerpcIce::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::PerpcIce::PeSessionFactory>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::PerpcIce::PeSessionFactory;
        v->__copyFrom(proxy);
    }
}

::PerpcIce::PeSessionPrx
IceProxy::PerpcIce::PeSessionFactory::CreateSession(const ::PerpcIce::PeGuestInfo& guestInfo, ::Ice::Int kvmSocketCount, const IceUtil::Optional< ::std::string>& moreInfo, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __PerpcIce__PeSessionFactory__CreateSession_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__PerpcIce__PeSessionFactory__CreateSession_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::PerpcIce::PeSessionFactory* __del = dynamic_cast< ::IceDelegate::PerpcIce::PeSessionFactory*>(__delBase.get());
            return __del->CreateSession(guestInfo, kvmSocketCount, moreInfo, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::PerpcIce::PeSessionFactory::begin_CreateSession(const ::PerpcIce::PeGuestInfo& guestInfo, ::Ice::Int kvmSocketCount, const IceUtil::Optional< ::std::string>& moreInfo, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__PerpcIce__PeSessionFactory__CreateSession_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __PerpcIce__PeSessionFactory__CreateSession_name, __del, __cookie);
    try
    {
        __result->__prepare(__PerpcIce__PeSessionFactory__CreateSession_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(guestInfo);
        __os->write(kvmSocketCount);
        __os->write(1, moreInfo);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::PerpcIce::PeSessionPrx
IceProxy::PerpcIce::PeSessionFactory::end_CreateSession(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __PerpcIce__PeSessionFactory__CreateSession_name);
    ::PerpcIce::PeSessionPrx __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Utils::SystemError&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::PerpcIce::PeSessionFactory::ice_staticId()
{
    return ::PerpcIce::PeSessionFactory::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::PerpcIce::PeSessionFactory::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::PerpcIce::PeSessionFactory);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::PerpcIce::PeSessionFactory::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::PerpcIce::PeSessionFactory);
}

::IceProxy::Ice::Object*
IceProxy::PerpcIce::PeSessionFactory::__newInstance() const
{
    return new PeSessionFactory;
}

::Ice::Int
IceDelegateM::PerpcIce::PeGuestReceiver::ReadDisk(const ::std::string& token, ::Ice::Long LBA, ::Ice::Int dwSectorCount, ::PerpcIce::BinaryStream& pBuf, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __PerpcIce__PeGuestReceiver__ReadDisk_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(token);
        __os->write(LBA);
        __os->write(dwSectorCount);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Utils::SystemError&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(pBuf);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::PerpcIce::PeGuestReceiver::WriteDisk(const ::std::string& token, ::Ice::Long LBA, ::Ice::Int dwSectorCount, const ::PerpcIce::BinaryStream& pBuf, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __PerpcIce__PeGuestReceiver__WriteDisk_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(token);
        __os->write(LBA);
        __os->write(dwSectorCount);
        __os->write(pBuf);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Utils::SystemError&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::PerpcIce::PeGuestReceiver::SetRestoreExcludeInfo(const ::PerpcIce::ExcludeBrokenBlocks& brokenBlocks, const ::PerpcIce::ExcludeBlockRuns& blockRuns, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __PerpcIce__PeGuestReceiver__SetRestoreExcludeInfo_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(brokenBlocks);
        __os->write(blockRuns);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Utils::SystemError&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::PerpcIce::PeGuestReceiver::KvmEnd(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __PerpcIce__PeGuestReceiver__KvmEnd_name, ::Ice::Idempotent, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Utils::SystemError&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::PerpcIce::PeGuestReceiver::GetClassHWInfo(const ::std::string& classname, ::Ice::Int requestParentLevel, ::PerpcIce::HWInfos& hwinfo, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __PerpcIce__PeGuestReceiver__GetClassHWInfo_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(classname);
        __os->write(requestParentLevel);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Utils::SystemError&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(hwinfo);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::PerpcIce::PeGuestReceiver::GetNetAdapterInfo(::PerpcIce::NetAdapterInfos& adapterInfos, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __PerpcIce__PeGuestReceiver__GetNetAdapterInfo_name, ::Ice::Idempotent, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Utils::SystemError&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(adapterInfos);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::PerpcIce::PeGuestReceiver::SetRestoreInfo(const ::PerpcIce::PeRestoreInfo& restoreInfo, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __PerpcIce__PeGuestReceiver__SetRestoreInfo_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(restoreInfo);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Utils::SystemError&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::PerpcIce::PeGuestReceiver::JsonFunc(const ::std::string& inputJson, const ::PerpcIce::BinaryStream& inputBs, ::PerpcIce::BinaryStream& outputBs, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __PerpcIce__PeGuestReceiver__JsonFunc_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(inputJson);
        __os->write(inputBs);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::std::string __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Utils::SystemError&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(outputBs);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::PerpcIce::PeSession::InitiatePeReceiver(const ::Ice::Identity& ident, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __PerpcIce__PeSession__InitiatePeReceiver_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(ident);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Utils::SystemError&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::PerpcIce::PeSession::GetPeHostIdent(::std::string& peHostIdent, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __PerpcIce__PeSession__GetPeHostIdent_name, ::Ice::Idempotent, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(peHostIdent);
        __og.endReadParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::PerpcIce::PeSession::UnInit(::Ice::Int dwStatus, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __PerpcIce__PeSession__UnInit_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(dwStatus);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Ice::Int
IceDelegateM::PerpcIce::PeSession::GetBootList(::Ice::Int index, ::std::string& bootlist, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __PerpcIce__PeSession__GetBootList_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(index);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Utils::NeedRetryLaterError&)
            {
                throw;
            }
            catch(const ::Utils::SystemError&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(bootlist);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::PerpcIce::PeSession::GetKvmBitmapFile(::Ice::Int index, ::PerpcIce::BinaryStream& data, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __PerpcIce__PeSession__GetKvmBitmapFile_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(index);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Utils::NeedRetryLaterError&)
            {
                throw;
            }
            catch(const ::Utils::SystemError&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(data);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::PerpcIce::PeSession::ReadDiskData(const ::std::string& token, ::Ice::Long LBA, ::Ice::Int dwSectorCount, ::PerpcIce::BinaryStream& pBuf, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __PerpcIce__PeSession__ReadDiskData_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(token);
        __os->write(LBA);
        __os->write(dwSectorCount);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Utils::SystemError&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(pBuf);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::PerpcIce::PeSession::ReadKvmBootData(::Ice::Int threadIndex, ::Ice::Int blockIndex, bool& isEnd, bool& isSkip, ::std::string& diskToken, ::Ice::Long& LBA, ::Ice::Int& dwSectorCount, ::PerpcIce::BinaryStream& data, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __PerpcIce__PeSession__ReadKvmBootData_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(threadIndex);
        __os->write(blockIndex);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Utils::SystemError&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(isEnd);
        __is->read(isSkip);
        __is->read(diskToken);
        __is->read(LBA);
        __is->read(dwSectorCount);
        __is->read(data);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateM::PerpcIce::PeSession::getUesdBlockBitmap(const ::std::string& token, ::Ice::Int index, ::PerpcIce::BinaryStream& bitmap, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __PerpcIce__PeSession__getUesdBlockBitmap_name, ::Ice::Idempotent, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(token);
        __os->write(index);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Ice::Int __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Utils::SystemError&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(bitmap);
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::PerpcIce::PeSession::Refresh(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __PerpcIce__PeSession__Refresh_name, ::Ice::Idempotent, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::PerpcIce::PeSession::StartKvm(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __PerpcIce__PeSession__StartKvm_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::PerpcIce::PeSession::destroy(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __PerpcIce__PeSession__destroy_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::PerpcIce::PeSessionPrx
IceDelegateM::PerpcIce::PeSessionFactory::CreateSession(const ::PerpcIce::PeGuestInfo& guestInfo, ::Ice::Int kvmSocketCount, const IceUtil::Optional< ::std::string>& moreInfo, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __PerpcIce__PeSessionFactory__CreateSession_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(guestInfo);
        __os->write(kvmSocketCount);
        __os->write(1, moreInfo);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::PerpcIce::PeSessionPrx __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Utils::SystemError&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Ice::Int
IceDelegateD::PerpcIce::PeGuestReceiver::ReadDisk(const ::std::string& token, ::Ice::Long LBA, ::Ice::Int dwSectorCount, ::PerpcIce::BinaryStream& pBuf, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::std::string& __p_token, ::Ice::Long __p_LBA, ::Ice::Int __p_dwSectorCount, ::PerpcIce::BinaryStream& __p_pBuf, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_token(__p_token),
            _m_LBA(__p_LBA),
            _m_dwSectorCount(__p_dwSectorCount),
            _m_pBuf(__p_pBuf)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::PerpcIce::PeGuestReceiver* servant = dynamic_cast< ::PerpcIce::PeGuestReceiver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->ReadDisk(_m_token, _m_LBA, _m_dwSectorCount, _m_pBuf, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::std::string& _m_token;
        ::Ice::Long _m_LBA;
        ::Ice::Int _m_dwSectorCount;
        ::PerpcIce::BinaryStream& _m_pBuf;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __PerpcIce__PeGuestReceiver__ReadDisk_name, ::Ice::Idempotent, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, token, LBA, dwSectorCount, pBuf, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Utils::SystemError&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::PerpcIce::PeGuestReceiver::WriteDisk(const ::std::string& token, ::Ice::Long LBA, ::Ice::Int dwSectorCount, const ::PerpcIce::BinaryStream& pBuf, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::std::string& __p_token, ::Ice::Long __p_LBA, ::Ice::Int __p_dwSectorCount, const ::PerpcIce::BinaryStream& __p_pBuf, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_token(__p_token),
            _m_LBA(__p_LBA),
            _m_dwSectorCount(__p_dwSectorCount),
            _m_pBuf(__p_pBuf)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::PerpcIce::PeGuestReceiver* servant = dynamic_cast< ::PerpcIce::PeGuestReceiver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->WriteDisk(_m_token, _m_LBA, _m_dwSectorCount, _m_pBuf, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::std::string& _m_token;
        ::Ice::Long _m_LBA;
        ::Ice::Int _m_dwSectorCount;
        const ::PerpcIce::BinaryStream& _m_pBuf;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __PerpcIce__PeGuestReceiver__WriteDisk_name, ::Ice::Idempotent, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, token, LBA, dwSectorCount, pBuf, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Utils::SystemError&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::PerpcIce::PeGuestReceiver::SetRestoreExcludeInfo(const ::PerpcIce::ExcludeBrokenBlocks& brokenBlocks, const ::PerpcIce::ExcludeBlockRuns& blockRuns, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::PerpcIce::ExcludeBrokenBlocks& __p_brokenBlocks, const ::PerpcIce::ExcludeBlockRuns& __p_blockRuns, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_brokenBlocks(__p_brokenBlocks),
            _m_blockRuns(__p_blockRuns)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::PerpcIce::PeGuestReceiver* servant = dynamic_cast< ::PerpcIce::PeGuestReceiver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->SetRestoreExcludeInfo(_m_brokenBlocks, _m_blockRuns, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::PerpcIce::ExcludeBrokenBlocks& _m_brokenBlocks;
        const ::PerpcIce::ExcludeBlockRuns& _m_blockRuns;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __PerpcIce__PeGuestReceiver__SetRestoreExcludeInfo_name, ::Ice::Idempotent, __context);
    try
    {
        _DirectI __direct(brokenBlocks, blockRuns, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Utils::SystemError&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::PerpcIce::PeGuestReceiver::KvmEnd(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::PerpcIce::PeGuestReceiver* servant = dynamic_cast< ::PerpcIce::PeGuestReceiver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->KvmEnd(_current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __PerpcIce__PeGuestReceiver__KvmEnd_name, ::Ice::Idempotent, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Utils::SystemError&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Int
IceDelegateD::PerpcIce::PeGuestReceiver::GetClassHWInfo(const ::std::string& classname, ::Ice::Int requestParentLevel, ::PerpcIce::HWInfos& hwinfo, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::std::string& __p_classname, ::Ice::Int __p_requestParentLevel, ::PerpcIce::HWInfos& __p_hwinfo, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_classname(__p_classname),
            _m_requestParentLevel(__p_requestParentLevel),
            _m_hwinfo(__p_hwinfo)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::PerpcIce::PeGuestReceiver* servant = dynamic_cast< ::PerpcIce::PeGuestReceiver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->GetClassHWInfo(_m_classname, _m_requestParentLevel, _m_hwinfo, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::std::string& _m_classname;
        ::Ice::Int _m_requestParentLevel;
        ::PerpcIce::HWInfos& _m_hwinfo;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __PerpcIce__PeGuestReceiver__GetClassHWInfo_name, ::Ice::Idempotent, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, classname, requestParentLevel, hwinfo, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Utils::SystemError&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::PerpcIce::PeGuestReceiver::GetNetAdapterInfo(::PerpcIce::NetAdapterInfos& adapterInfos, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::PerpcIce::NetAdapterInfos& __p_adapterInfos, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_adapterInfos(__p_adapterInfos)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::PerpcIce::PeGuestReceiver* servant = dynamic_cast< ::PerpcIce::PeGuestReceiver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->GetNetAdapterInfo(_m_adapterInfos, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        ::PerpcIce::NetAdapterInfos& _m_adapterInfos;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __PerpcIce__PeGuestReceiver__GetNetAdapterInfo_name, ::Ice::Idempotent, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, adapterInfos, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Utils::SystemError&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::PerpcIce::PeGuestReceiver::SetRestoreInfo(const ::PerpcIce::PeRestoreInfo& restoreInfo, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::PerpcIce::PeRestoreInfo& __p_restoreInfo, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_restoreInfo(__p_restoreInfo)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::PerpcIce::PeGuestReceiver* servant = dynamic_cast< ::PerpcIce::PeGuestReceiver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->SetRestoreInfo(_m_restoreInfo, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::PerpcIce::PeRestoreInfo& _m_restoreInfo;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __PerpcIce__PeGuestReceiver__SetRestoreInfo_name, ::Ice::Idempotent, __context);
    try
    {
        _DirectI __direct(restoreInfo, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Utils::SystemError&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::std::string
IceDelegateD::PerpcIce::PeGuestReceiver::JsonFunc(const ::std::string& inputJson, const ::PerpcIce::BinaryStream& inputBs, ::PerpcIce::BinaryStream& outputBs, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::std::string& __result, const ::std::string& __p_inputJson, const ::PerpcIce::BinaryStream& __p_inputBs, ::PerpcIce::BinaryStream& __p_outputBs, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_inputJson(__p_inputJson),
            _m_inputBs(__p_inputBs),
            _m_outputBs(__p_outputBs)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::PerpcIce::PeGuestReceiver* servant = dynamic_cast< ::PerpcIce::PeGuestReceiver*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->JsonFunc(_m_inputJson, _m_inputBs, _m_outputBs, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::std::string& _result;
        const ::std::string& _m_inputJson;
        const ::PerpcIce::BinaryStream& _m_inputBs;
        ::PerpcIce::BinaryStream& _m_outputBs;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __PerpcIce__PeGuestReceiver__JsonFunc_name, ::Ice::Idempotent, __context);
    ::std::string __result;
    try
    {
        _DirectI __direct(__result, inputJson, inputBs, outputBs, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Utils::SystemError&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::PerpcIce::PeSession::InitiatePeReceiver(const ::Ice::Identity& ident, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Identity& __p_ident, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_ident(__p_ident)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::PerpcIce::PeSession* servant = dynamic_cast< ::PerpcIce::PeSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->InitiatePeReceiver(_m_ident, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::Ice::Identity& _m_ident;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __PerpcIce__PeSession__InitiatePeReceiver_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(ident, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Utils::SystemError&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::PerpcIce::PeSession::GetPeHostIdent(::std::string& peHostIdent, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::std::string& __p_peHostIdent, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_peHostIdent(__p_peHostIdent)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::PerpcIce::PeSession* servant = dynamic_cast< ::PerpcIce::PeSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->GetPeHostIdent(_m_peHostIdent, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::std::string& _m_peHostIdent;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __PerpcIce__PeSession__GetPeHostIdent_name, ::Ice::Idempotent, __context);
    try
    {
        _DirectI __direct(peHostIdent, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::PerpcIce::PeSession::UnInit(::Ice::Int dwStatus, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int __p_dwStatus, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_dwStatus(__p_dwStatus)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::PerpcIce::PeSession* servant = dynamic_cast< ::PerpcIce::PeSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->UnInit(_m_dwStatus, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Ice::Int _m_dwStatus;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __PerpcIce__PeSession__UnInit_name, ::Ice::Idempotent, __context);
    try
    {
        _DirectI __direct(dwStatus, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Ice::Int
IceDelegateD::PerpcIce::PeSession::GetBootList(::Ice::Int index, ::std::string& bootlist, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::Ice::Int __p_index, ::std::string& __p_bootlist, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_index(__p_index),
            _m_bootlist(__p_bootlist)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::PerpcIce::PeSession* servant = dynamic_cast< ::PerpcIce::PeSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->GetBootList(_m_index, _m_bootlist, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        ::Ice::Int _m_index;
        ::std::string& _m_bootlist;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __PerpcIce__PeSession__GetBootList_name, ::Ice::Idempotent, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, index, bootlist, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Utils::NeedRetryLaterError&)
    {
        throw;
    }
    catch(const ::Utils::SystemError&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::PerpcIce::PeSession::GetKvmBitmapFile(::Ice::Int index, ::PerpcIce::BinaryStream& data, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::Ice::Int __p_index, ::PerpcIce::BinaryStream& __p_data, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_index(__p_index),
            _m_data(__p_data)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::PerpcIce::PeSession* servant = dynamic_cast< ::PerpcIce::PeSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->GetKvmBitmapFile(_m_index, _m_data, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        ::Ice::Int _m_index;
        ::PerpcIce::BinaryStream& _m_data;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __PerpcIce__PeSession__GetKvmBitmapFile_name, ::Ice::Idempotent, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, index, data, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Utils::NeedRetryLaterError&)
    {
        throw;
    }
    catch(const ::Utils::SystemError&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::PerpcIce::PeSession::ReadDiskData(const ::std::string& token, ::Ice::Long LBA, ::Ice::Int dwSectorCount, ::PerpcIce::BinaryStream& pBuf, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::std::string& __p_token, ::Ice::Long __p_LBA, ::Ice::Int __p_dwSectorCount, ::PerpcIce::BinaryStream& __p_pBuf, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_token(__p_token),
            _m_LBA(__p_LBA),
            _m_dwSectorCount(__p_dwSectorCount),
            _m_pBuf(__p_pBuf)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::PerpcIce::PeSession* servant = dynamic_cast< ::PerpcIce::PeSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->ReadDiskData(_m_token, _m_LBA, _m_dwSectorCount, _m_pBuf, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::std::string& _m_token;
        ::Ice::Long _m_LBA;
        ::Ice::Int _m_dwSectorCount;
        ::PerpcIce::BinaryStream& _m_pBuf;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __PerpcIce__PeSession__ReadDiskData_name, ::Ice::Idempotent, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, token, LBA, dwSectorCount, pBuf, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Utils::SystemError&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::PerpcIce::PeSession::ReadKvmBootData(::Ice::Int threadIndex, ::Ice::Int blockIndex, bool& isEnd, bool& isSkip, ::std::string& diskToken, ::Ice::Long& LBA, ::Ice::Int& dwSectorCount, ::PerpcIce::BinaryStream& data, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, ::Ice::Int __p_threadIndex, ::Ice::Int __p_blockIndex, bool& __p_isEnd, bool& __p_isSkip, ::std::string& __p_diskToken, ::Ice::Long& __p_LBA, ::Ice::Int& __p_dwSectorCount, ::PerpcIce::BinaryStream& __p_data, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_threadIndex(__p_threadIndex),
            _m_blockIndex(__p_blockIndex),
            _m_isEnd(__p_isEnd),
            _m_isSkip(__p_isSkip),
            _m_diskToken(__p_diskToken),
            _m_LBA(__p_LBA),
            _m_dwSectorCount(__p_dwSectorCount),
            _m_data(__p_data)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::PerpcIce::PeSession* servant = dynamic_cast< ::PerpcIce::PeSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->ReadKvmBootData(_m_threadIndex, _m_blockIndex, _m_isEnd, _m_isSkip, _m_diskToken, _m_LBA, _m_dwSectorCount, _m_data, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        ::Ice::Int _m_threadIndex;
        ::Ice::Int _m_blockIndex;
        bool& _m_isEnd;
        bool& _m_isSkip;
        ::std::string& _m_diskToken;
        ::Ice::Long& _m_LBA;
        ::Ice::Int& _m_dwSectorCount;
        ::PerpcIce::BinaryStream& _m_data;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __PerpcIce__PeSession__ReadKvmBootData_name, ::Ice::Idempotent, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, threadIndex, blockIndex, isEnd, isSkip, diskToken, LBA, dwSectorCount, data, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Utils::SystemError&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Int
IceDelegateD::PerpcIce::PeSession::getUesdBlockBitmap(const ::std::string& token, ::Ice::Int index, ::PerpcIce::BinaryStream& bitmap, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Ice::Int& __result, const ::std::string& __p_token, ::Ice::Int __p_index, ::PerpcIce::BinaryStream& __p_bitmap, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_token(__p_token),
            _m_index(__p_index),
            _m_bitmap(__p_bitmap)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::PerpcIce::PeSession* servant = dynamic_cast< ::PerpcIce::PeSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->getUesdBlockBitmap(_m_token, _m_index, _m_bitmap, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Ice::Int& _result;
        const ::std::string& _m_token;
        ::Ice::Int _m_index;
        ::PerpcIce::BinaryStream& _m_bitmap;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __PerpcIce__PeSession__getUesdBlockBitmap_name, ::Ice::Idempotent, __context);
    ::Ice::Int __result;
    try
    {
        _DirectI __direct(__result, token, index, bitmap, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Utils::SystemError&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::PerpcIce::PeSession::Refresh(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::PerpcIce::PeSession* servant = dynamic_cast< ::PerpcIce::PeSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->Refresh(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __PerpcIce__PeSession__Refresh_name, ::Ice::Idempotent, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::PerpcIce::PeSession::StartKvm(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::PerpcIce::PeSession* servant = dynamic_cast< ::PerpcIce::PeSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->StartKvm(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __PerpcIce__PeSession__StartKvm_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::PerpcIce::PeSession::destroy(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::PerpcIce::PeSession* servant = dynamic_cast< ::PerpcIce::PeSession*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->destroy(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __PerpcIce__PeSession__destroy_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(__current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::PerpcIce::PeSessionPrx
IceDelegateD::PerpcIce::PeSessionFactory::CreateSession(const ::PerpcIce::PeGuestInfo& guestInfo, ::Ice::Int kvmSocketCount, const IceUtil::Optional< ::std::string>& moreInfo, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::PerpcIce::PeSessionPrx& __result, const ::PerpcIce::PeGuestInfo& __p_guestInfo, ::Ice::Int __p_kvmSocketCount, const IceUtil::Optional< ::std::string>& __p_moreInfo, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_guestInfo(__p_guestInfo),
            _m_kvmSocketCount(__p_kvmSocketCount),
            _m_moreInfo(__p_moreInfo)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::PerpcIce::PeSessionFactory* servant = dynamic_cast< ::PerpcIce::PeSessionFactory*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->CreateSession(_m_guestInfo, _m_kvmSocketCount, _m_moreInfo, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::PerpcIce::PeSessionPrx& _result;
        const ::PerpcIce::PeGuestInfo& _m_guestInfo;
        ::Ice::Int _m_kvmSocketCount;
        const IceUtil::Optional< ::std::string>& _m_moreInfo;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __PerpcIce__PeSessionFactory__CreateSession_name, ::Ice::Normal, __context);
    ::PerpcIce::PeSessionPrx __result;
    try
    {
        _DirectI __direct(__result, guestInfo, kvmSocketCount, moreInfo, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Utils::SystemError&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Object* PerpcIce::upCast(::PerpcIce::PeGuestReceiver* p) { return p; }

namespace
{
const ::std::string __PerpcIce__PeGuestReceiver_ids[2] =
{
    "::Ice::Object",
    "::PerpcIce::PeGuestReceiver"
};

}

bool
PerpcIce::PeGuestReceiver::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__PerpcIce__PeGuestReceiver_ids, __PerpcIce__PeGuestReceiver_ids + 2, _s);
}

::std::vector< ::std::string>
PerpcIce::PeGuestReceiver::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__PerpcIce__PeGuestReceiver_ids[0], &__PerpcIce__PeGuestReceiver_ids[2]);
}

const ::std::string&
PerpcIce::PeGuestReceiver::ice_id(const ::Ice::Current&) const
{
    return __PerpcIce__PeGuestReceiver_ids[1];
}

const ::std::string&
PerpcIce::PeGuestReceiver::ice_staticId()
{
    return __PerpcIce__PeGuestReceiver_ids[1];
}

::Ice::DispatchStatus
PerpcIce::PeGuestReceiver::___ReadDisk(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string token;
    ::Ice::Long LBA;
    ::Ice::Int dwSectorCount;
    __is->read(token);
    __is->read(LBA);
    __is->read(dwSectorCount);
    __inS.endReadParams();
    ::PerpcIce::BinaryStream pBuf;
    try
    {
        ::Ice::Int __ret = ReadDisk(token, LBA, dwSectorCount, pBuf, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(pBuf);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
PerpcIce::PeGuestReceiver::___WriteDisk(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string token;
    ::Ice::Long LBA;
    ::Ice::Int dwSectorCount;
    ::PerpcIce::BinaryStream pBuf;
    __is->read(token);
    __is->read(LBA);
    __is->read(dwSectorCount);
    __is->read(pBuf);
    __inS.endReadParams();
    try
    {
        ::Ice::Int __ret = WriteDisk(token, LBA, dwSectorCount, pBuf, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
PerpcIce::PeGuestReceiver::___SetRestoreExcludeInfo(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::PerpcIce::ExcludeBrokenBlocks brokenBlocks;
    ::PerpcIce::ExcludeBlockRuns blockRuns;
    __is->read(brokenBlocks);
    __is->read(blockRuns);
    __inS.endReadParams();
    try
    {
        SetRestoreExcludeInfo(brokenBlocks, blockRuns, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
PerpcIce::PeGuestReceiver::___KvmEnd(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    try
    {
        KvmEnd(__current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
PerpcIce::PeGuestReceiver::___GetClassHWInfo(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string classname;
    ::Ice::Int requestParentLevel;
    __is->read(classname);
    __is->read(requestParentLevel);
    __inS.endReadParams();
    ::PerpcIce::HWInfos hwinfo;
    try
    {
        ::Ice::Int __ret = GetClassHWInfo(classname, requestParentLevel, hwinfo, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(hwinfo);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
PerpcIce::PeGuestReceiver::___GetNetAdapterInfo(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::PerpcIce::NetAdapterInfos adapterInfos;
    try
    {
        ::Ice::Int __ret = GetNetAdapterInfo(adapterInfos, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(adapterInfos);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
PerpcIce::PeGuestReceiver::___SetRestoreInfo(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::PerpcIce::PeRestoreInfo restoreInfo;
    __is->read(restoreInfo);
    __inS.endReadParams();
    try
    {
        SetRestoreInfo(restoreInfo, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
PerpcIce::PeGuestReceiver::___JsonFunc(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string inputJson;
    ::PerpcIce::BinaryStream inputBs;
    __is->read(inputJson);
    __is->read(inputBs);
    __inS.endReadParams();
    ::PerpcIce::BinaryStream outputBs;
    try
    {
        ::std::string __ret = JsonFunc(inputJson, inputBs, outputBs, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(outputBs);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __PerpcIce__PeGuestReceiver_all[] =
{
    "GetClassHWInfo",
    "GetNetAdapterInfo",
    "JsonFunc",
    "KvmEnd",
    "ReadDisk",
    "SetRestoreExcludeInfo",
    "SetRestoreInfo",
    "WriteDisk",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
PerpcIce::PeGuestReceiver::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__PerpcIce__PeGuestReceiver_all, __PerpcIce__PeGuestReceiver_all + 12, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __PerpcIce__PeGuestReceiver_all)
    {
        case 0:
        {
            return ___GetClassHWInfo(in, current);
        }
        case 1:
        {
            return ___GetNetAdapterInfo(in, current);
        }
        case 2:
        {
            return ___JsonFunc(in, current);
        }
        case 3:
        {
            return ___KvmEnd(in, current);
        }
        case 4:
        {
            return ___ReadDisk(in, current);
        }
        case 5:
        {
            return ___SetRestoreExcludeInfo(in, current);
        }
        case 6:
        {
            return ___SetRestoreInfo(in, current);
        }
        case 7:
        {
            return ___WriteDisk(in, current);
        }
        case 8:
        {
            return ___ice_id(in, current);
        }
        case 9:
        {
            return ___ice_ids(in, current);
        }
        case 10:
        {
            return ___ice_isA(in, current);
        }
        case 11:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
PerpcIce::PeGuestReceiver::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
PerpcIce::PeGuestReceiver::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
PerpcIce::__patch(PeGuestReceiverPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::PerpcIce::PeGuestReceiverPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::PerpcIce::PeGuestReceiver::ice_staticId(), v);
    }
}

::Ice::Object* PerpcIce::upCast(::PerpcIce::PeSession* p) { return p; }

namespace
{
const ::std::string __PerpcIce__PeSession_ids[2] =
{
    "::Ice::Object",
    "::PerpcIce::PeSession"
};

}

bool
PerpcIce::PeSession::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__PerpcIce__PeSession_ids, __PerpcIce__PeSession_ids + 2, _s);
}

::std::vector< ::std::string>
PerpcIce::PeSession::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__PerpcIce__PeSession_ids[0], &__PerpcIce__PeSession_ids[2]);
}

const ::std::string&
PerpcIce::PeSession::ice_id(const ::Ice::Current&) const
{
    return __PerpcIce__PeSession_ids[1];
}

const ::std::string&
PerpcIce::PeSession::ice_staticId()
{
    return __PerpcIce__PeSession_ids[1];
}

::Ice::DispatchStatus
PerpcIce::PeSession::___InitiatePeReceiver(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Identity ident;
    __is->read(ident);
    __inS.endReadParams();
    try
    {
        InitiatePeReceiver(ident, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
PerpcIce::PeSession::___GetPeHostIdent(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    ::std::string peHostIdent;
    GetPeHostIdent(peHostIdent, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(peHostIdent);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
PerpcIce::PeSession::___UnInit(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int dwStatus;
    __is->read(dwStatus);
    __inS.endReadParams();
    UnInit(dwStatus, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
PerpcIce::PeSession::___GetBootList(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int index;
    __is->read(index);
    __inS.endReadParams();
    ::std::string bootlist;
    try
    {
        ::Ice::Int __ret = GetBootList(index, bootlist, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(bootlist);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::NeedRetryLaterError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
PerpcIce::PeSession::___GetKvmBitmapFile(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int index;
    __is->read(index);
    __inS.endReadParams();
    ::PerpcIce::BinaryStream data;
    try
    {
        ::Ice::Int __ret = GetKvmBitmapFile(index, data, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(data);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::NeedRetryLaterError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
PerpcIce::PeSession::___ReadDiskData(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string token;
    ::Ice::Long LBA;
    ::Ice::Int dwSectorCount;
    __is->read(token);
    __is->read(LBA);
    __is->read(dwSectorCount);
    __inS.endReadParams();
    ::PerpcIce::BinaryStream pBuf;
    try
    {
        ::Ice::Int __ret = ReadDiskData(token, LBA, dwSectorCount, pBuf, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(pBuf);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
PerpcIce::PeSession::___ReadKvmBootData(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Ice::Int threadIndex;
    ::Ice::Int blockIndex;
    __is->read(threadIndex);
    __is->read(blockIndex);
    __inS.endReadParams();
    bool isEnd;
    bool isSkip;
    ::std::string diskToken;
    ::Ice::Long LBA;
    ::Ice::Int dwSectorCount;
    ::PerpcIce::BinaryStream data;
    try
    {
        ::Ice::Int __ret = ReadKvmBootData(threadIndex, blockIndex, isEnd, isSkip, diskToken, LBA, dwSectorCount, data, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(isEnd);
        __os->write(isSkip);
        __os->write(diskToken);
        __os->write(LBA);
        __os->write(dwSectorCount);
        __os->write(data);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
PerpcIce::PeSession::___getUesdBlockBitmap(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string token;
    ::Ice::Int index;
    __is->read(token);
    __is->read(index);
    __inS.endReadParams();
    ::PerpcIce::BinaryStream bitmap;
    try
    {
        ::Ice::Int __ret = getUesdBlockBitmap(token, index, bitmap, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(bitmap);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
PerpcIce::PeSession::___Refresh(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Idempotent, __current.mode);
    __inS.readEmptyParams();
    Refresh(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
PerpcIce::PeSession::___StartKvm(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    StartKvm(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
PerpcIce::PeSession::___destroy(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    destroy(__current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __PerpcIce__PeSession_all[] =
{
    "GetBootList",
    "GetKvmBitmapFile",
    "GetPeHostIdent",
    "InitiatePeReceiver",
    "ReadDiskData",
    "ReadKvmBootData",
    "Refresh",
    "StartKvm",
    "UnInit",
    "destroy",
    "getUesdBlockBitmap",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
PerpcIce::PeSession::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__PerpcIce__PeSession_all, __PerpcIce__PeSession_all + 15, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __PerpcIce__PeSession_all)
    {
        case 0:
        {
            return ___GetBootList(in, current);
        }
        case 1:
        {
            return ___GetKvmBitmapFile(in, current);
        }
        case 2:
        {
            return ___GetPeHostIdent(in, current);
        }
        case 3:
        {
            return ___InitiatePeReceiver(in, current);
        }
        case 4:
        {
            return ___ReadDiskData(in, current);
        }
        case 5:
        {
            return ___ReadKvmBootData(in, current);
        }
        case 6:
        {
            return ___Refresh(in, current);
        }
        case 7:
        {
            return ___StartKvm(in, current);
        }
        case 8:
        {
            return ___UnInit(in, current);
        }
        case 9:
        {
            return ___destroy(in, current);
        }
        case 10:
        {
            return ___getUesdBlockBitmap(in, current);
        }
        case 11:
        {
            return ___ice_id(in, current);
        }
        case 12:
        {
            return ___ice_ids(in, current);
        }
        case 13:
        {
            return ___ice_isA(in, current);
        }
        case 14:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
PerpcIce::PeSession::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
PerpcIce::PeSession::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
PerpcIce::__patch(PeSessionPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::PerpcIce::PeSessionPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::PerpcIce::PeSession::ice_staticId(), v);
    }
}

::Ice::Object* PerpcIce::upCast(::PerpcIce::PeSessionFactory* p) { return p; }

namespace
{
const ::std::string __PerpcIce__PeSessionFactory_ids[2] =
{
    "::Ice::Object",
    "::PerpcIce::PeSessionFactory"
};

}

bool
PerpcIce::PeSessionFactory::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__PerpcIce__PeSessionFactory_ids, __PerpcIce__PeSessionFactory_ids + 2, _s);
}

::std::vector< ::std::string>
PerpcIce::PeSessionFactory::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__PerpcIce__PeSessionFactory_ids[0], &__PerpcIce__PeSessionFactory_ids[2]);
}

const ::std::string&
PerpcIce::PeSessionFactory::ice_id(const ::Ice::Current&) const
{
    return __PerpcIce__PeSessionFactory_ids[1];
}

const ::std::string&
PerpcIce::PeSessionFactory::ice_staticId()
{
    return __PerpcIce__PeSessionFactory_ids[1];
}

::Ice::DispatchStatus
PerpcIce::PeSessionFactory::___CreateSession(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::PerpcIce::PeGuestInfo guestInfo;
    ::Ice::Int kvmSocketCount;
    IceUtil::Optional< ::std::string> moreInfo;
    __is->read(guestInfo);
    __is->read(kvmSocketCount);
    __is->read(1, moreInfo);
    __inS.endReadParams();
    try
    {
        ::PerpcIce::PeSessionPrx __ret = CreateSession(guestInfo, kvmSocketCount, moreInfo, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Utils::SystemError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __PerpcIce__PeSessionFactory_all[] =
{
    "CreateSession",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
PerpcIce::PeSessionFactory::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__PerpcIce__PeSessionFactory_all, __PerpcIce__PeSessionFactory_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __PerpcIce__PeSessionFactory_all)
    {
        case 0:
        {
            return ___CreateSession(in, current);
        }
        case 1:
        {
            return ___ice_id(in, current);
        }
        case 2:
        {
            return ___ice_ids(in, current);
        }
        case 3:
        {
            return ___ice_isA(in, current);
        }
        case 4:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
PerpcIce::PeSessionFactory::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
PerpcIce::PeSessionFactory::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
PerpcIce::__patch(PeSessionFactoryPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::PerpcIce::PeSessionFactoryPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::PerpcIce::PeSessionFactory::ice_staticId(), v);
    }
}
