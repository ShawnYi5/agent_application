// **********************************************************************
//
// Copyright (c) 2003-2015 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.6.1
//
// <auto-generated>
//
// Generated from file `data_queuing.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef ____cpp_data_queuing_h__
#define ____cpp_data_queuing_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Proxy.h>
#include <Ice/GCObject.h>
#include <Ice/AsyncResult.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <IceUtil/Optional.h>
#include <Ice/StreamF.h>
#include <Ice/Identity.h>
#include <utils.h>
#include <img.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 306
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace DataQueuingIce
{

class DataCreator;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::DataQueuingIce::DataCreator>&);
::IceProxy::Ice::Object* upCast(::IceProxy::DataQueuingIce::DataCreator*);

class DataGuest;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::DataQueuingIce::DataGuest>&);
::IceProxy::Ice::Object* upCast(::IceProxy::DataQueuingIce::DataGuest*);

}

}

namespace DataQueuingIce
{

class DataCreator;
bool operator==(const DataCreator&, const DataCreator&);
bool operator<(const DataCreator&, const DataCreator&);
::Ice::Object* upCast(::DataQueuingIce::DataCreator*);
typedef ::IceInternal::Handle< ::DataQueuingIce::DataCreator> DataCreatorPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::DataQueuingIce::DataCreator> DataCreatorPrx;
void __patch(DataCreatorPtr&, const ::Ice::ObjectPtr&);

class DataGuest;
bool operator==(const DataGuest&, const DataGuest&);
bool operator<(const DataGuest&, const DataGuest&);
::Ice::Object* upCast(::DataQueuingIce::DataGuest*);
typedef ::IceInternal::Handle< ::DataQueuingIce::DataGuest> DataGuestPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::DataQueuingIce::DataGuest> DataGuestPrx;
void __patch(DataGuestPtr&, const ::Ice::ObjectPtr&);

}

namespace DataQueuingIce
{

typedef ::std::vector< ::Ice::Byte> BinaryStream;

struct DiskBitmap
{
    ::std::string token;
    ::DataQueuingIce::BinaryStream bitmap;
};

struct DiskBitmapv2
{
    ::std::string token;
    ::std::string bitmapPath;

    bool operator==(const DiskBitmapv2& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(token != __rhs.token)
        {
            return false;
        }
        if(bitmapPath != __rhs.bitmapPath)
        {
            return false;
        }
        return true;
    }

    bool operator<(const DiskBitmapv2& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(token < __rhs.token)
        {
            return true;
        }
        else if(__rhs.token < token)
        {
            return false;
        }
        if(bitmapPath < __rhs.bitmapPath)
        {
            return true;
        }
        else if(__rhs.bitmapPath < bitmapPath)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const DiskBitmapv2& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const DiskBitmapv2& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const DiskBitmapv2& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const DiskBitmapv2& __rhs) const
    {
        return !operator<(__rhs);
    }
};

typedef ::std::vector< ::DataQueuingIce::DiskBitmap> DiskBitmaps;

struct ExcludeRun
{
    ::Ice::Long byteOffset;
    ::Ice::Long bytes;

    bool operator==(const ExcludeRun& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(byteOffset != __rhs.byteOffset)
        {
            return false;
        }
        if(bytes != __rhs.bytes)
        {
            return false;
        }
        return true;
    }

    bool operator<(const ExcludeRun& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(byteOffset < __rhs.byteOffset)
        {
            return true;
        }
        else if(__rhs.byteOffset < byteOffset)
        {
            return false;
        }
        if(bytes < __rhs.bytes)
        {
            return true;
        }
        else if(__rhs.bytes < bytes)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const ExcludeRun& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const ExcludeRun& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const ExcludeRun& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const ExcludeRun& __rhs) const
    {
        return !operator<(__rhs);
    }
};

typedef ::std::vector< ::DataQueuingIce::ExcludeRun> ExcludeRuns;

enum WorkType
{
    noneWork = 0,
    cdpWork = 1,
    qemuWork = 2
};

}

namespace Ice
{
template<>
struct StreamableTraits< ::DataQueuingIce::DiskBitmap>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::DataQueuingIce::DiskBitmap, S>
{
    static void write(S* __os, const ::DataQueuingIce::DiskBitmap& v)
    {
        __os->write(v.token);
        __os->write(v.bitmap);
    }
};

template<class S>
struct StreamReader< ::DataQueuingIce::DiskBitmap, S>
{
    static void read(S* __is, ::DataQueuingIce::DiskBitmap& v)
    {
        __is->read(v.token);
        __is->read(v.bitmap);
    }
};

template<>
struct StreamableTraits< ::DataQueuingIce::DiskBitmapv2>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::DataQueuingIce::DiskBitmapv2, S>
{
    static void write(S* __os, const ::DataQueuingIce::DiskBitmapv2& v)
    {
        __os->write(v.token);
        __os->write(v.bitmapPath);
    }
};

template<class S>
struct StreamReader< ::DataQueuingIce::DiskBitmapv2, S>
{
    static void read(S* __is, ::DataQueuingIce::DiskBitmapv2& v)
    {
        __is->read(v.token);
        __is->read(v.bitmapPath);
    }
};

template<>
struct StreamableTraits< ::DataQueuingIce::ExcludeRun>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 16;
    static const bool fixedLength = true;
};

template<class S>
struct StreamWriter< ::DataQueuingIce::ExcludeRun, S>
{
    static void write(S* __os, const ::DataQueuingIce::ExcludeRun& v)
    {
        __os->write(v.byteOffset);
        __os->write(v.bytes);
    }
};

template<class S>
struct StreamReader< ::DataQueuingIce::ExcludeRun, S>
{
    static void read(S* __is, ::DataQueuingIce::ExcludeRun& v)
    {
        __is->read(v.byteOffset);
        __is->read(v.bytes);
    }
};

template<>
struct StreamableTraits< ::DataQueuingIce::WorkType>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

}

namespace DataQueuingIce
{

class Callback_DataCreator_StartCDPWork_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_DataCreator_StartCDPWork_Base> Callback_DataCreator_StartCDPWorkPtr;

class Callback_DataCreator_StartQemuWorkForBitmap_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_DataCreator_StartQemuWorkForBitmap_Base> Callback_DataCreator_StartQemuWorkForBitmapPtr;

class Callback_DataCreator_StartQemuWorkForBitmapv2_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_DataCreator_StartQemuWorkForBitmapv2_Base> Callback_DataCreator_StartQemuWorkForBitmapv2Ptr;

class Callback_DataCreator_StartQemuWork_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_DataCreator_StartQemuWork_Base> Callback_DataCreator_StartQemuWorkPtr;

class Callback_DataCreator_QueryQemuProgress_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_DataCreator_QueryQemuProgress_Base> Callback_DataCreator_QueryQemuProgressPtr;

class Callback_DataCreator_QueryCDPProgress_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_DataCreator_QueryCDPProgress_Base> Callback_DataCreator_QueryCDPProgressPtr;

class Callback_DataCreator_QueryWorkStatus_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_DataCreator_QueryWorkStatus_Base> Callback_DataCreator_QueryWorkStatusPtr;

class Callback_DataCreator_StopQemuWork_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_DataCreator_StopQemuWork_Base> Callback_DataCreator_StopQemuWorkPtr;

class Callback_DataCreator_StopQemuWorkv2_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_DataCreator_StopQemuWorkv2_Base> Callback_DataCreator_StopQemuWorkv2Ptr;

class Callback_DataCreator_StopCDPWork_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_DataCreator_StopCDPWork_Base> Callback_DataCreator_StopCDPWorkPtr;

class Callback_DataCreator_SetRestoreBitmap_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_DataCreator_SetRestoreBitmap_Base> Callback_DataCreator_SetRestoreBitmapPtr;

class Callback_DataCreator_SetRestoreBitmapv2_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_DataCreator_SetRestoreBitmapv2_Base> Callback_DataCreator_SetRestoreBitmapv2Ptr;

class Callback_DataCreator_EndTask_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_DataCreator_EndTask_Base> Callback_DataCreator_EndTaskPtr;

class Callback_DataCreator_CloseTask_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_DataCreator_CloseTask_Base> Callback_DataCreator_CloseTaskPtr;

class Callback_DataGuest_InitGuest_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_DataGuest_InitGuest_Base> Callback_DataGuest_InitGuestPtr;

class Callback_DataGuest_GetData_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_DataGuest_GetData_Base> Callback_DataGuest_GetDataPtr;

class Callback_DataGuest_GetDataEx_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_DataGuest_GetDataEx_Base> Callback_DataGuest_GetDataExPtr;

class Callback_DataGuest_DataCompleted_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_DataGuest_DataCompleted_Base> Callback_DataGuest_DataCompletedPtr;

class Callback_DataGuest_GetBitmapInfo_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_DataGuest_GetBitmapInfo_Base> Callback_DataGuest_GetBitmapInfoPtr;

class Callback_DataGuest_GetBitmapData_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_DataGuest_GetBitmapData_Base> Callback_DataGuest_GetBitmapDataPtr;

}

namespace IceProxy
{

namespace DataQueuingIce
{

class DataCreator : virtual public ::IceProxy::Ice::Object
{
public:

    ::Ice::Int StartCDPWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::std::string& __p_cdpFileName, const ::std::string& __p_startTime, bool __p_watch, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns)
    {
        return StartCDPWork(__p_task, __p_token, __p_cdpFileName, __p_startTime, __p_watch, __p_excludeRuns, 0);
    }
    ::Ice::Int StartCDPWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::std::string& __p_cdpFileName, const ::std::string& __p_startTime, bool __p_watch, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::Ice::Context& __ctx)
    {
        return StartCDPWork(__p_task, __p_token, __p_cdpFileName, __p_startTime, __p_watch, __p_excludeRuns, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_StartCDPWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::std::string& __p_cdpFileName, const ::std::string& __p_startTime, bool __p_watch, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_StartCDPWork(__p_task, __p_token, __p_cdpFileName, __p_startTime, __p_watch, __p_excludeRuns, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_StartCDPWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::std::string& __p_cdpFileName, const ::std::string& __p_startTime, bool __p_watch, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_StartCDPWork(__p_task, __p_token, __p_cdpFileName, __p_startTime, __p_watch, __p_excludeRuns, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_StartCDPWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::std::string& __p_cdpFileName, const ::std::string& __p_startTime, bool __p_watch, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_StartCDPWork(__p_task, __p_token, __p_cdpFileName, __p_startTime, __p_watch, __p_excludeRuns, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_StartCDPWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::std::string& __p_cdpFileName, const ::std::string& __p_startTime, bool __p_watch, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_StartCDPWork(__p_task, __p_token, __p_cdpFileName, __p_startTime, __p_watch, __p_excludeRuns, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_StartCDPWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::std::string& __p_cdpFileName, const ::std::string& __p_startTime, bool __p_watch, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_StartCDPWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::std::string& __p_cdpFileName, const ::std::string& __p_startTime, bool __p_watch, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns)
    {
        return begin_StartCDPWork(__p_task, __p_token, __p_cdpFileName, __p_startTime, __p_watch, __p_excludeRuns, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_StartCDPWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::std::string& __p_cdpFileName, const ::std::string& __p_startTime, bool __p_watch, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::Ice::Context& __ctx)
    {
        return begin_StartCDPWork(__p_task, __p_token, __p_cdpFileName, __p_startTime, __p_watch, __p_excludeRuns, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_StartCDPWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::std::string& __p_cdpFileName, const ::std::string& __p_startTime, bool __p_watch, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StartCDPWork(__p_task, __p_token, __p_cdpFileName, __p_startTime, __p_watch, __p_excludeRuns, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_StartCDPWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::std::string& __p_cdpFileName, const ::std::string& __p_startTime, bool __p_watch, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StartCDPWork(__p_task, __p_token, __p_cdpFileName, __p_startTime, __p_watch, __p_excludeRuns, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_StartCDPWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::std::string& __p_cdpFileName, const ::std::string& __p_startTime, bool __p_watch, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::DataQueuingIce::Callback_DataCreator_StartCDPWorkPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StartCDPWork(__p_task, __p_token, __p_cdpFileName, __p_startTime, __p_watch, __p_excludeRuns, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_StartCDPWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::std::string& __p_cdpFileName, const ::std::string& __p_startTime, bool __p_watch, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::Ice::Context& __ctx, const ::DataQueuingIce::Callback_DataCreator_StartCDPWorkPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StartCDPWork(__p_task, __p_token, __p_cdpFileName, __p_startTime, __p_watch, __p_excludeRuns, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_StartCDPWork(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int StartCDPWork(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, bool, const ::DataQueuingIce::ExcludeRuns&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_StartCDPWork(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, bool, const ::DataQueuingIce::ExcludeRuns&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int StartQemuWorkForBitmap(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::DataQueuingIce::BinaryStream& __p_bitmap, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns)
    {
        return StartQemuWorkForBitmap(__p_task, __p_token, __p_snapshot, __p_bitmap, __p_excludeRuns, 0);
    }
    ::Ice::Int StartQemuWorkForBitmap(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::DataQueuingIce::BinaryStream& __p_bitmap, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::Ice::Context& __ctx)
    {
        return StartQemuWorkForBitmap(__p_task, __p_token, __p_snapshot, __p_bitmap, __p_excludeRuns, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_StartQemuWorkForBitmap(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::DataQueuingIce::BinaryStream& __p_bitmap, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_StartQemuWorkForBitmap(__p_task, __p_token, __p_snapshot, __p_bitmap, __p_excludeRuns, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_StartQemuWorkForBitmap(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::DataQueuingIce::BinaryStream& __p_bitmap, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_StartQemuWorkForBitmap(__p_task, __p_token, __p_snapshot, __p_bitmap, __p_excludeRuns, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_StartQemuWorkForBitmap(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::DataQueuingIce::BinaryStream& __p_bitmap, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_StartQemuWorkForBitmap(__p_task, __p_token, __p_snapshot, __p_bitmap, __p_excludeRuns, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_StartQemuWorkForBitmap(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::DataQueuingIce::BinaryStream& __p_bitmap, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_StartQemuWorkForBitmap(__p_task, __p_token, __p_snapshot, __p_bitmap, __p_excludeRuns, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_StartQemuWorkForBitmap(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::DataQueuingIce::BinaryStream& __p_bitmap, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_StartQemuWorkForBitmap(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::DataQueuingIce::BinaryStream& __p_bitmap, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns)
    {
        return begin_StartQemuWorkForBitmap(__p_task, __p_token, __p_snapshot, __p_bitmap, __p_excludeRuns, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_StartQemuWorkForBitmap(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::DataQueuingIce::BinaryStream& __p_bitmap, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::Ice::Context& __ctx)
    {
        return begin_StartQemuWorkForBitmap(__p_task, __p_token, __p_snapshot, __p_bitmap, __p_excludeRuns, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_StartQemuWorkForBitmap(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::DataQueuingIce::BinaryStream& __p_bitmap, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StartQemuWorkForBitmap(__p_task, __p_token, __p_snapshot, __p_bitmap, __p_excludeRuns, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_StartQemuWorkForBitmap(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::DataQueuingIce::BinaryStream& __p_bitmap, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StartQemuWorkForBitmap(__p_task, __p_token, __p_snapshot, __p_bitmap, __p_excludeRuns, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_StartQemuWorkForBitmap(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::DataQueuingIce::BinaryStream& __p_bitmap, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::DataQueuingIce::Callback_DataCreator_StartQemuWorkForBitmapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StartQemuWorkForBitmap(__p_task, __p_token, __p_snapshot, __p_bitmap, __p_excludeRuns, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_StartQemuWorkForBitmap(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::DataQueuingIce::BinaryStream& __p_bitmap, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::Ice::Context& __ctx, const ::DataQueuingIce::Callback_DataCreator_StartQemuWorkForBitmapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StartQemuWorkForBitmap(__p_task, __p_token, __p_snapshot, __p_bitmap, __p_excludeRuns, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_StartQemuWorkForBitmap(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int StartQemuWorkForBitmap(const ::std::string&, const ::std::string&, const ::IMG::ImageSnapshotIdents&, const ::DataQueuingIce::BinaryStream&, const ::DataQueuingIce::ExcludeRuns&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_StartQemuWorkForBitmap(const ::std::string&, const ::std::string&, const ::IMG::ImageSnapshotIdents&, const ::DataQueuingIce::BinaryStream&, const ::DataQueuingIce::ExcludeRuns&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int StartQemuWorkForBitmapv2(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::std::string& __p_bitmapPath, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns)
    {
        return StartQemuWorkForBitmapv2(__p_task, __p_token, __p_snapshot, __p_bitmapPath, __p_excludeRuns, 0);
    }
    ::Ice::Int StartQemuWorkForBitmapv2(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::std::string& __p_bitmapPath, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::Ice::Context& __ctx)
    {
        return StartQemuWorkForBitmapv2(__p_task, __p_token, __p_snapshot, __p_bitmapPath, __p_excludeRuns, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_StartQemuWorkForBitmapv2(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::std::string& __p_bitmapPath, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_StartQemuWorkForBitmapv2(__p_task, __p_token, __p_snapshot, __p_bitmapPath, __p_excludeRuns, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_StartQemuWorkForBitmapv2(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::std::string& __p_bitmapPath, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_StartQemuWorkForBitmapv2(__p_task, __p_token, __p_snapshot, __p_bitmapPath, __p_excludeRuns, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_StartQemuWorkForBitmapv2(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::std::string& __p_bitmapPath, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_StartQemuWorkForBitmapv2(__p_task, __p_token, __p_snapshot, __p_bitmapPath, __p_excludeRuns, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_StartQemuWorkForBitmapv2(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::std::string& __p_bitmapPath, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_StartQemuWorkForBitmapv2(__p_task, __p_token, __p_snapshot, __p_bitmapPath, __p_excludeRuns, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_StartQemuWorkForBitmapv2(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::std::string& __p_bitmapPath, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_StartQemuWorkForBitmapv2(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::std::string& __p_bitmapPath, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns)
    {
        return begin_StartQemuWorkForBitmapv2(__p_task, __p_token, __p_snapshot, __p_bitmapPath, __p_excludeRuns, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_StartQemuWorkForBitmapv2(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::std::string& __p_bitmapPath, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::Ice::Context& __ctx)
    {
        return begin_StartQemuWorkForBitmapv2(__p_task, __p_token, __p_snapshot, __p_bitmapPath, __p_excludeRuns, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_StartQemuWorkForBitmapv2(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::std::string& __p_bitmapPath, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StartQemuWorkForBitmapv2(__p_task, __p_token, __p_snapshot, __p_bitmapPath, __p_excludeRuns, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_StartQemuWorkForBitmapv2(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::std::string& __p_bitmapPath, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StartQemuWorkForBitmapv2(__p_task, __p_token, __p_snapshot, __p_bitmapPath, __p_excludeRuns, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_StartQemuWorkForBitmapv2(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::std::string& __p_bitmapPath, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::DataQueuingIce::Callback_DataCreator_StartQemuWorkForBitmapv2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StartQemuWorkForBitmapv2(__p_task, __p_token, __p_snapshot, __p_bitmapPath, __p_excludeRuns, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_StartQemuWorkForBitmapv2(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::std::string& __p_bitmapPath, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::Ice::Context& __ctx, const ::DataQueuingIce::Callback_DataCreator_StartQemuWorkForBitmapv2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StartQemuWorkForBitmapv2(__p_task, __p_token, __p_snapshot, __p_bitmapPath, __p_excludeRuns, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_StartQemuWorkForBitmapv2(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int StartQemuWorkForBitmapv2(const ::std::string&, const ::std::string&, const ::IMG::ImageSnapshotIdents&, const ::std::string&, const ::DataQueuingIce::ExcludeRuns&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_StartQemuWorkForBitmapv2(const ::std::string&, const ::std::string&, const ::IMG::ImageSnapshotIdents&, const ::std::string&, const ::DataQueuingIce::ExcludeRuns&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int StartQemuWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns)
    {
        return StartQemuWork(__p_task, __p_token, __p_snapshot, __p_excludeRuns, 0);
    }
    ::Ice::Int StartQemuWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::Ice::Context& __ctx)
    {
        return StartQemuWork(__p_task, __p_token, __p_snapshot, __p_excludeRuns, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_StartQemuWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_StartQemuWork(__p_task, __p_token, __p_snapshot, __p_excludeRuns, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_StartQemuWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_StartQemuWork(__p_task, __p_token, __p_snapshot, __p_excludeRuns, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_StartQemuWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_StartQemuWork(__p_task, __p_token, __p_snapshot, __p_excludeRuns, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_StartQemuWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_StartQemuWork(__p_task, __p_token, __p_snapshot, __p_excludeRuns, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_StartQemuWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_StartQemuWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns)
    {
        return begin_StartQemuWork(__p_task, __p_token, __p_snapshot, __p_excludeRuns, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_StartQemuWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::Ice::Context& __ctx)
    {
        return begin_StartQemuWork(__p_task, __p_token, __p_snapshot, __p_excludeRuns, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_StartQemuWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StartQemuWork(__p_task, __p_token, __p_snapshot, __p_excludeRuns, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_StartQemuWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StartQemuWork(__p_task, __p_token, __p_snapshot, __p_excludeRuns, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_StartQemuWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::DataQueuingIce::Callback_DataCreator_StartQemuWorkPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StartQemuWork(__p_task, __p_token, __p_snapshot, __p_excludeRuns, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_StartQemuWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::IMG::ImageSnapshotIdents& __p_snapshot, const ::DataQueuingIce::ExcludeRuns& __p_excludeRuns, const ::Ice::Context& __ctx, const ::DataQueuingIce::Callback_DataCreator_StartQemuWorkPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StartQemuWork(__p_task, __p_token, __p_snapshot, __p_excludeRuns, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_StartQemuWork(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int StartQemuWork(const ::std::string&, const ::std::string&, const ::IMG::ImageSnapshotIdents&, const ::DataQueuingIce::ExcludeRuns&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_StartQemuWork(const ::std::string&, const ::std::string&, const ::IMG::ImageSnapshotIdents&, const ::DataQueuingIce::ExcludeRuns&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int QueryQemuProgress(const ::std::string& __p_task, const ::std::string& __p_token, ::Ice::Long& __p_totalBytes, ::Ice::Long& __p_completedBytes, ::Ice::Int& __p_queueLen)
    {
        return QueryQemuProgress(__p_task, __p_token, __p_totalBytes, __p_completedBytes, __p_queueLen, 0);
    }
    ::Ice::Int QueryQemuProgress(const ::std::string& __p_task, const ::std::string& __p_token, ::Ice::Long& __p_totalBytes, ::Ice::Long& __p_completedBytes, ::Ice::Int& __p_queueLen, const ::Ice::Context& __ctx)
    {
        return QueryQemuProgress(__p_task, __p_token, __p_totalBytes, __p_completedBytes, __p_queueLen, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_QueryQemuProgress(const ::std::string& __p_task, const ::std::string& __p_token, const ::IceInternal::Function<void (::Ice::Int, ::Ice::Long, ::Ice::Long, ::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_QueryQemuProgress(__p_task, __p_token, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_QueryQemuProgress(const ::std::string& __p_task, const ::std::string& __p_token, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_QueryQemuProgress(__p_task, __p_token, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_QueryQemuProgress(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int, ::Ice::Long, ::Ice::Long, ::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_QueryQemuProgress(__p_task, __p_token, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_QueryQemuProgress(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_QueryQemuProgress(__p_task, __p_token, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_QueryQemuProgress(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int, ::Ice::Long, ::Ice::Long, ::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_QueryQemuProgress(const ::std::string& __p_task, const ::std::string& __p_token)
    {
        return begin_QueryQemuProgress(__p_task, __p_token, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_QueryQemuProgress(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context& __ctx)
    {
        return begin_QueryQemuProgress(__p_task, __p_token, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_QueryQemuProgress(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_QueryQemuProgress(__p_task, __p_token, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_QueryQemuProgress(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_QueryQemuProgress(__p_task, __p_token, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_QueryQemuProgress(const ::std::string& __p_task, const ::std::string& __p_token, const ::DataQueuingIce::Callback_DataCreator_QueryQemuProgressPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_QueryQemuProgress(__p_task, __p_token, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_QueryQemuProgress(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::DataQueuingIce::Callback_DataCreator_QueryQemuProgressPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_QueryQemuProgress(__p_task, __p_token, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_QueryQemuProgress(::Ice::Long& __p_totalBytes, ::Ice::Long& __p_completedBytes, ::Ice::Int& __p_queueLen, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int QueryQemuProgress(const ::std::string&, const ::std::string&, ::Ice::Long&, ::Ice::Long&, ::Ice::Int&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_QueryQemuProgress(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int QueryCDPProgress(const ::std::string& __p_task, const ::std::string& __p_token, ::std::string& __p_lastTime, ::Ice::Int& __p_queueLen)
    {
        return QueryCDPProgress(__p_task, __p_token, __p_lastTime, __p_queueLen, 0);
    }
    ::Ice::Int QueryCDPProgress(const ::std::string& __p_task, const ::std::string& __p_token, ::std::string& __p_lastTime, ::Ice::Int& __p_queueLen, const ::Ice::Context& __ctx)
    {
        return QueryCDPProgress(__p_task, __p_token, __p_lastTime, __p_queueLen, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_QueryCDPProgress(const ::std::string& __p_task, const ::std::string& __p_token, const ::IceInternal::Function<void (::Ice::Int, const ::std::string&, ::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_QueryCDPProgress(__p_task, __p_token, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_QueryCDPProgress(const ::std::string& __p_task, const ::std::string& __p_token, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_QueryCDPProgress(__p_task, __p_token, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_QueryCDPProgress(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int, const ::std::string&, ::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_QueryCDPProgress(__p_task, __p_token, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_QueryCDPProgress(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_QueryCDPProgress(__p_task, __p_token, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_QueryCDPProgress(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int, const ::std::string&, ::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_QueryCDPProgress(const ::std::string& __p_task, const ::std::string& __p_token)
    {
        return begin_QueryCDPProgress(__p_task, __p_token, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_QueryCDPProgress(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context& __ctx)
    {
        return begin_QueryCDPProgress(__p_task, __p_token, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_QueryCDPProgress(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_QueryCDPProgress(__p_task, __p_token, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_QueryCDPProgress(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_QueryCDPProgress(__p_task, __p_token, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_QueryCDPProgress(const ::std::string& __p_task, const ::std::string& __p_token, const ::DataQueuingIce::Callback_DataCreator_QueryCDPProgressPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_QueryCDPProgress(__p_task, __p_token, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_QueryCDPProgress(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::DataQueuingIce::Callback_DataCreator_QueryCDPProgressPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_QueryCDPProgress(__p_task, __p_token, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_QueryCDPProgress(::std::string& __p_lastTime, ::Ice::Int& __p_queueLen, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int QueryCDPProgress(const ::std::string&, const ::std::string&, ::std::string&, ::Ice::Int&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_QueryCDPProgress(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int QueryWorkStatus(const ::std::string& __p_task, const ::std::string& __p_token, ::DataQueuingIce::WorkType& __p_workType)
    {
        return QueryWorkStatus(__p_task, __p_token, __p_workType, 0);
    }
    ::Ice::Int QueryWorkStatus(const ::std::string& __p_task, const ::std::string& __p_token, ::DataQueuingIce::WorkType& __p_workType, const ::Ice::Context& __ctx)
    {
        return QueryWorkStatus(__p_task, __p_token, __p_workType, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_QueryWorkStatus(const ::std::string& __p_task, const ::std::string& __p_token, const ::IceInternal::Function<void (::Ice::Int, ::DataQueuingIce::WorkType)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_QueryWorkStatus(__p_task, __p_token, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_QueryWorkStatus(const ::std::string& __p_task, const ::std::string& __p_token, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_QueryWorkStatus(__p_task, __p_token, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_QueryWorkStatus(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int, ::DataQueuingIce::WorkType)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_QueryWorkStatus(__p_task, __p_token, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_QueryWorkStatus(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_QueryWorkStatus(__p_task, __p_token, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_QueryWorkStatus(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int, ::DataQueuingIce::WorkType)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_QueryWorkStatus(const ::std::string& __p_task, const ::std::string& __p_token)
    {
        return begin_QueryWorkStatus(__p_task, __p_token, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_QueryWorkStatus(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context& __ctx)
    {
        return begin_QueryWorkStatus(__p_task, __p_token, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_QueryWorkStatus(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_QueryWorkStatus(__p_task, __p_token, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_QueryWorkStatus(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_QueryWorkStatus(__p_task, __p_token, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_QueryWorkStatus(const ::std::string& __p_task, const ::std::string& __p_token, const ::DataQueuingIce::Callback_DataCreator_QueryWorkStatusPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_QueryWorkStatus(__p_task, __p_token, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_QueryWorkStatus(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::DataQueuingIce::Callback_DataCreator_QueryWorkStatusPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_QueryWorkStatus(__p_task, __p_token, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_QueryWorkStatus(::DataQueuingIce::WorkType& __p_workType, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int QueryWorkStatus(const ::std::string&, const ::std::string&, ::DataQueuingIce::WorkType&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_QueryWorkStatus(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int StopQemuWork(const ::std::string& __p_task, const ::std::string& __p_token, ::DataQueuingIce::BinaryStream& __p_bitmap)
    {
        return StopQemuWork(__p_task, __p_token, __p_bitmap, 0);
    }
    ::Ice::Int StopQemuWork(const ::std::string& __p_task, const ::std::string& __p_token, ::DataQueuingIce::BinaryStream& __p_bitmap, const ::Ice::Context& __ctx)
    {
        return StopQemuWork(__p_task, __p_token, __p_bitmap, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_StopQemuWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::IceInternal::Function<void (::Ice::Int, const ::DataQueuingIce::BinaryStream&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_StopQemuWork(__p_task, __p_token, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_StopQemuWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_StopQemuWork(__p_task, __p_token, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_StopQemuWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int, const ::DataQueuingIce::BinaryStream&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_StopQemuWork(__p_task, __p_token, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_StopQemuWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_StopQemuWork(__p_task, __p_token, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_StopQemuWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int, const ::DataQueuingIce::BinaryStream&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_StopQemuWork(const ::std::string& __p_task, const ::std::string& __p_token)
    {
        return begin_StopQemuWork(__p_task, __p_token, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_StopQemuWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context& __ctx)
    {
        return begin_StopQemuWork(__p_task, __p_token, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_StopQemuWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StopQemuWork(__p_task, __p_token, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_StopQemuWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StopQemuWork(__p_task, __p_token, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_StopQemuWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::DataQueuingIce::Callback_DataCreator_StopQemuWorkPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StopQemuWork(__p_task, __p_token, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_StopQemuWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::DataQueuingIce::Callback_DataCreator_StopQemuWorkPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StopQemuWork(__p_task, __p_token, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_StopQemuWork(::DataQueuingIce::BinaryStream& __p_bitmap, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int StopQemuWork(const ::std::string&, const ::std::string&, ::DataQueuingIce::BinaryStream&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_StopQemuWork(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int StopQemuWorkv2(const ::std::string& __p_task, const ::std::string& __p_token)
    {
        return StopQemuWorkv2(__p_task, __p_token, 0);
    }
    ::Ice::Int StopQemuWorkv2(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context& __ctx)
    {
        return StopQemuWorkv2(__p_task, __p_token, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_StopQemuWorkv2(const ::std::string& __p_task, const ::std::string& __p_token, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_StopQemuWorkv2(__p_task, __p_token, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_StopQemuWorkv2(const ::std::string& __p_task, const ::std::string& __p_token, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_StopQemuWorkv2(__p_task, __p_token, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_StopQemuWorkv2(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_StopQemuWorkv2(__p_task, __p_token, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_StopQemuWorkv2(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_StopQemuWorkv2(__p_task, __p_token, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_StopQemuWorkv2(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_StopQemuWorkv2(const ::std::string& __p_task, const ::std::string& __p_token)
    {
        return begin_StopQemuWorkv2(__p_task, __p_token, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_StopQemuWorkv2(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context& __ctx)
    {
        return begin_StopQemuWorkv2(__p_task, __p_token, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_StopQemuWorkv2(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StopQemuWorkv2(__p_task, __p_token, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_StopQemuWorkv2(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StopQemuWorkv2(__p_task, __p_token, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_StopQemuWorkv2(const ::std::string& __p_task, const ::std::string& __p_token, const ::DataQueuingIce::Callback_DataCreator_StopQemuWorkv2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StopQemuWorkv2(__p_task, __p_token, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_StopQemuWorkv2(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::DataQueuingIce::Callback_DataCreator_StopQemuWorkv2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StopQemuWorkv2(__p_task, __p_token, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_StopQemuWorkv2(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int StopQemuWorkv2(const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_StopQemuWorkv2(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int StopCDPWork(const ::std::string& __p_task, const ::std::string& __p_token, ::std::string& __p_lastTime)
    {
        return StopCDPWork(__p_task, __p_token, __p_lastTime, 0);
    }
    ::Ice::Int StopCDPWork(const ::std::string& __p_task, const ::std::string& __p_token, ::std::string& __p_lastTime, const ::Ice::Context& __ctx)
    {
        return StopCDPWork(__p_task, __p_token, __p_lastTime, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_StopCDPWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::IceInternal::Function<void (::Ice::Int, const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_StopCDPWork(__p_task, __p_token, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_StopCDPWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_StopCDPWork(__p_task, __p_token, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_StopCDPWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int, const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_StopCDPWork(__p_task, __p_token, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_StopCDPWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_StopCDPWork(__p_task, __p_token, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_StopCDPWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int, const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_StopCDPWork(const ::std::string& __p_task, const ::std::string& __p_token)
    {
        return begin_StopCDPWork(__p_task, __p_token, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_StopCDPWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context& __ctx)
    {
        return begin_StopCDPWork(__p_task, __p_token, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_StopCDPWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StopCDPWork(__p_task, __p_token, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_StopCDPWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StopCDPWork(__p_task, __p_token, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_StopCDPWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::DataQueuingIce::Callback_DataCreator_StopCDPWorkPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StopCDPWork(__p_task, __p_token, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_StopCDPWork(const ::std::string& __p_task, const ::std::string& __p_token, const ::Ice::Context& __ctx, const ::DataQueuingIce::Callback_DataCreator_StopCDPWorkPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_StopCDPWork(__p_task, __p_token, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_StopCDPWork(::std::string& __p_lastTime, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int StopCDPWork(const ::std::string&, const ::std::string&, ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_StopCDPWork(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int SetRestoreBitmap(const ::std::string& __p_task, const ::DataQueuingIce::DiskBitmap& __p_diskBitmap)
    {
        return SetRestoreBitmap(__p_task, __p_diskBitmap, 0);
    }
    ::Ice::Int SetRestoreBitmap(const ::std::string& __p_task, const ::DataQueuingIce::DiskBitmap& __p_diskBitmap, const ::Ice::Context& __ctx)
    {
        return SetRestoreBitmap(__p_task, __p_diskBitmap, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_SetRestoreBitmap(const ::std::string& __p_task, const ::DataQueuingIce::DiskBitmap& __p_diskBitmap, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_SetRestoreBitmap(__p_task, __p_diskBitmap, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_SetRestoreBitmap(const ::std::string& __p_task, const ::DataQueuingIce::DiskBitmap& __p_diskBitmap, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_SetRestoreBitmap(__p_task, __p_diskBitmap, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_SetRestoreBitmap(const ::std::string& __p_task, const ::DataQueuingIce::DiskBitmap& __p_diskBitmap, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_SetRestoreBitmap(__p_task, __p_diskBitmap, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_SetRestoreBitmap(const ::std::string& __p_task, const ::DataQueuingIce::DiskBitmap& __p_diskBitmap, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_SetRestoreBitmap(__p_task, __p_diskBitmap, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_SetRestoreBitmap(const ::std::string& __p_task, const ::DataQueuingIce::DiskBitmap& __p_diskBitmap, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_SetRestoreBitmap(const ::std::string& __p_task, const ::DataQueuingIce::DiskBitmap& __p_diskBitmap)
    {
        return begin_SetRestoreBitmap(__p_task, __p_diskBitmap, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SetRestoreBitmap(const ::std::string& __p_task, const ::DataQueuingIce::DiskBitmap& __p_diskBitmap, const ::Ice::Context& __ctx)
    {
        return begin_SetRestoreBitmap(__p_task, __p_diskBitmap, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SetRestoreBitmap(const ::std::string& __p_task, const ::DataQueuingIce::DiskBitmap& __p_diskBitmap, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SetRestoreBitmap(__p_task, __p_diskBitmap, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SetRestoreBitmap(const ::std::string& __p_task, const ::DataQueuingIce::DiskBitmap& __p_diskBitmap, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SetRestoreBitmap(__p_task, __p_diskBitmap, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SetRestoreBitmap(const ::std::string& __p_task, const ::DataQueuingIce::DiskBitmap& __p_diskBitmap, const ::DataQueuingIce::Callback_DataCreator_SetRestoreBitmapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SetRestoreBitmap(__p_task, __p_diskBitmap, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SetRestoreBitmap(const ::std::string& __p_task, const ::DataQueuingIce::DiskBitmap& __p_diskBitmap, const ::Ice::Context& __ctx, const ::DataQueuingIce::Callback_DataCreator_SetRestoreBitmapPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SetRestoreBitmap(__p_task, __p_diskBitmap, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_SetRestoreBitmap(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int SetRestoreBitmap(const ::std::string&, const ::DataQueuingIce::DiskBitmap&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_SetRestoreBitmap(const ::std::string&, const ::DataQueuingIce::DiskBitmap&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int SetRestoreBitmapv2(const ::std::string& __p_task, const ::DataQueuingIce::DiskBitmapv2& __p_diskBitmap)
    {
        return SetRestoreBitmapv2(__p_task, __p_diskBitmap, 0);
    }
    ::Ice::Int SetRestoreBitmapv2(const ::std::string& __p_task, const ::DataQueuingIce::DiskBitmapv2& __p_diskBitmap, const ::Ice::Context& __ctx)
    {
        return SetRestoreBitmapv2(__p_task, __p_diskBitmap, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_SetRestoreBitmapv2(const ::std::string& __p_task, const ::DataQueuingIce::DiskBitmapv2& __p_diskBitmap, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_SetRestoreBitmapv2(__p_task, __p_diskBitmap, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_SetRestoreBitmapv2(const ::std::string& __p_task, const ::DataQueuingIce::DiskBitmapv2& __p_diskBitmap, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_SetRestoreBitmapv2(__p_task, __p_diskBitmap, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_SetRestoreBitmapv2(const ::std::string& __p_task, const ::DataQueuingIce::DiskBitmapv2& __p_diskBitmap, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_SetRestoreBitmapv2(__p_task, __p_diskBitmap, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_SetRestoreBitmapv2(const ::std::string& __p_task, const ::DataQueuingIce::DiskBitmapv2& __p_diskBitmap, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_SetRestoreBitmapv2(__p_task, __p_diskBitmap, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_SetRestoreBitmapv2(const ::std::string& __p_task, const ::DataQueuingIce::DiskBitmapv2& __p_diskBitmap, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_SetRestoreBitmapv2(const ::std::string& __p_task, const ::DataQueuingIce::DiskBitmapv2& __p_diskBitmap)
    {
        return begin_SetRestoreBitmapv2(__p_task, __p_diskBitmap, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SetRestoreBitmapv2(const ::std::string& __p_task, const ::DataQueuingIce::DiskBitmapv2& __p_diskBitmap, const ::Ice::Context& __ctx)
    {
        return begin_SetRestoreBitmapv2(__p_task, __p_diskBitmap, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SetRestoreBitmapv2(const ::std::string& __p_task, const ::DataQueuingIce::DiskBitmapv2& __p_diskBitmap, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SetRestoreBitmapv2(__p_task, __p_diskBitmap, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SetRestoreBitmapv2(const ::std::string& __p_task, const ::DataQueuingIce::DiskBitmapv2& __p_diskBitmap, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SetRestoreBitmapv2(__p_task, __p_diskBitmap, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SetRestoreBitmapv2(const ::std::string& __p_task, const ::DataQueuingIce::DiskBitmapv2& __p_diskBitmap, const ::DataQueuingIce::Callback_DataCreator_SetRestoreBitmapv2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SetRestoreBitmapv2(__p_task, __p_diskBitmap, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_SetRestoreBitmapv2(const ::std::string& __p_task, const ::DataQueuingIce::DiskBitmapv2& __p_diskBitmap, const ::Ice::Context& __ctx, const ::DataQueuingIce::Callback_DataCreator_SetRestoreBitmapv2Ptr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_SetRestoreBitmapv2(__p_task, __p_diskBitmap, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_SetRestoreBitmapv2(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int SetRestoreBitmapv2(const ::std::string&, const ::DataQueuingIce::DiskBitmapv2&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_SetRestoreBitmapv2(const ::std::string&, const ::DataQueuingIce::DiskBitmapv2&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int EndTask(const ::std::string& __p_task)
    {
        return EndTask(__p_task, 0);
    }
    ::Ice::Int EndTask(const ::std::string& __p_task, const ::Ice::Context& __ctx)
    {
        return EndTask(__p_task, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_EndTask(const ::std::string& __p_task, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_EndTask(__p_task, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_EndTask(const ::std::string& __p_task, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_EndTask(__p_task, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_EndTask(const ::std::string& __p_task, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_EndTask(__p_task, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_EndTask(const ::std::string& __p_task, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_EndTask(__p_task, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_EndTask(const ::std::string& __p_task, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_EndTask(const ::std::string& __p_task)
    {
        return begin_EndTask(__p_task, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_EndTask(const ::std::string& __p_task, const ::Ice::Context& __ctx)
    {
        return begin_EndTask(__p_task, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_EndTask(const ::std::string& __p_task, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_EndTask(__p_task, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_EndTask(const ::std::string& __p_task, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_EndTask(__p_task, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_EndTask(const ::std::string& __p_task, const ::DataQueuingIce::Callback_DataCreator_EndTaskPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_EndTask(__p_task, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_EndTask(const ::std::string& __p_task, const ::Ice::Context& __ctx, const ::DataQueuingIce::Callback_DataCreator_EndTaskPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_EndTask(__p_task, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_EndTask(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int EndTask(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_EndTask(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int CloseTask(const ::std::string& __p_task)
    {
        return CloseTask(__p_task, 0);
    }
    ::Ice::Int CloseTask(const ::std::string& __p_task, const ::Ice::Context& __ctx)
    {
        return CloseTask(__p_task, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_CloseTask(const ::std::string& __p_task, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_CloseTask(__p_task, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_CloseTask(const ::std::string& __p_task, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_CloseTask(__p_task, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_CloseTask(const ::std::string& __p_task, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_CloseTask(__p_task, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_CloseTask(const ::std::string& __p_task, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_CloseTask(__p_task, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_CloseTask(const ::std::string& __p_task, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_CloseTask(const ::std::string& __p_task)
    {
        return begin_CloseTask(__p_task, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_CloseTask(const ::std::string& __p_task, const ::Ice::Context& __ctx)
    {
        return begin_CloseTask(__p_task, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_CloseTask(const ::std::string& __p_task, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_CloseTask(__p_task, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_CloseTask(const ::std::string& __p_task, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_CloseTask(__p_task, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_CloseTask(const ::std::string& __p_task, const ::DataQueuingIce::Callback_DataCreator_CloseTaskPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_CloseTask(__p_task, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_CloseTask(const ::std::string& __p_task, const ::Ice::Context& __ctx, const ::DataQueuingIce::Callback_DataCreator_CloseTaskPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_CloseTask(__p_task, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_CloseTask(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int CloseTask(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_CloseTask(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<DataCreator> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<DataCreator*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<DataCreator> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<DataCreator*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<DataCreator> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<DataCreator*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<DataCreator> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<DataCreator*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<DataCreator> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<DataCreator*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<DataCreator> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<DataCreator*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<DataCreator> ice_secure(bool __secure) const
    {
        return dynamic_cast<DataCreator*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<DataCreator> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<DataCreator*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<DataCreator> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<DataCreator*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<DataCreator> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<DataCreator*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<DataCreator> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<DataCreator*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<DataCreator> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<DataCreator*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<DataCreator> ice_twoway() const
    {
        return dynamic_cast<DataCreator*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<DataCreator> ice_oneway() const
    {
        return dynamic_cast<DataCreator*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<DataCreator> ice_batchOneway() const
    {
        return dynamic_cast<DataCreator*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<DataCreator> ice_datagram() const
    {
        return dynamic_cast<DataCreator*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<DataCreator> ice_batchDatagram() const
    {
        return dynamic_cast<DataCreator*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<DataCreator> ice_compress(bool __compress) const
    {
        return dynamic_cast<DataCreator*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<DataCreator> ice_timeout(int __timeout) const
    {
        return dynamic_cast<DataCreator*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<DataCreator> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<DataCreator*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<DataCreator> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<DataCreator*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class DataGuest : virtual public ::IceProxy::Ice::Object
{
public:

    ::Ice::Int InitGuest(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent)
    {
        return InitGuest(__p_task, __p_QueueIdent, 0);
    }
    ::Ice::Int InitGuest(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, const ::Ice::Context& __ctx)
    {
        return InitGuest(__p_task, __p_QueueIdent, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_InitGuest(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_InitGuest(__p_task, __p_QueueIdent, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_InitGuest(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_InitGuest(__p_task, __p_QueueIdent, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_InitGuest(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_InitGuest(__p_task, __p_QueueIdent, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_InitGuest(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_InitGuest(__p_task, __p_QueueIdent, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_InitGuest(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_InitGuest(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent)
    {
        return begin_InitGuest(__p_task, __p_QueueIdent, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_InitGuest(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, const ::Ice::Context& __ctx)
    {
        return begin_InitGuest(__p_task, __p_QueueIdent, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_InitGuest(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_InitGuest(__p_task, __p_QueueIdent, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_InitGuest(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_InitGuest(__p_task, __p_QueueIdent, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_InitGuest(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, const ::DataQueuingIce::Callback_DataGuest_InitGuestPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_InitGuest(__p_task, __p_QueueIdent, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_InitGuest(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, const ::Ice::Context& __ctx, const ::DataQueuingIce::Callback_DataGuest_InitGuestPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_InitGuest(__p_task, __p_QueueIdent, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_InitGuest(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int InitGuest(const ::std::string&, ::Ice::Int, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_InitGuest(const ::std::string&, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int GetData(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, ::Ice::Long& __p_DataIdent, ::std::string& __p_token, ::Ice::Long& __p_Lba, ::Ice::Int& __p_secs, ::DataQueuingIce::BinaryStream& __p_data, bool& __p_isEnd)
    {
        return GetData(__p_task, __p_QueueIdent, __p_DataIdent, __p_token, __p_Lba, __p_secs, __p_data, __p_isEnd, 0);
    }
    ::Ice::Int GetData(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, ::Ice::Long& __p_DataIdent, ::std::string& __p_token, ::Ice::Long& __p_Lba, ::Ice::Int& __p_secs, ::DataQueuingIce::BinaryStream& __p_data, bool& __p_isEnd, const ::Ice::Context& __ctx)
    {
        return GetData(__p_task, __p_QueueIdent, __p_DataIdent, __p_token, __p_Lba, __p_secs, __p_data, __p_isEnd, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_GetData(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, const ::IceInternal::Function<void (::Ice::Int, ::Ice::Long, const ::std::string&, ::Ice::Long, ::Ice::Int, const ::DataQueuingIce::BinaryStream&, bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_GetData(__p_task, __p_QueueIdent, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_GetData(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_GetData(__p_task, __p_QueueIdent, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_GetData(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int, ::Ice::Long, const ::std::string&, ::Ice::Long, ::Ice::Int, const ::DataQueuingIce::BinaryStream&, bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_GetData(__p_task, __p_QueueIdent, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_GetData(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_GetData(__p_task, __p_QueueIdent, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_GetData(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int, ::Ice::Long, const ::std::string&, ::Ice::Long, ::Ice::Int, const ::DataQueuingIce::BinaryStream&, bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_GetData(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent)
    {
        return begin_GetData(__p_task, __p_QueueIdent, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetData(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, const ::Ice::Context& __ctx)
    {
        return begin_GetData(__p_task, __p_QueueIdent, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetData(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetData(__p_task, __p_QueueIdent, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetData(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetData(__p_task, __p_QueueIdent, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetData(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, const ::DataQueuingIce::Callback_DataGuest_GetDataPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetData(__p_task, __p_QueueIdent, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetData(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, const ::Ice::Context& __ctx, const ::DataQueuingIce::Callback_DataGuest_GetDataPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetData(__p_task, __p_QueueIdent, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_GetData(::Ice::Long& __p_DataIdent, ::std::string& __p_token, ::Ice::Long& __p_Lba, ::Ice::Int& __p_secs, ::DataQueuingIce::BinaryStream& __p_data, bool& __p_isEnd, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int GetData(const ::std::string&, ::Ice::Int, ::Ice::Long&, ::std::string&, ::Ice::Long&, ::Ice::Int&, ::DataQueuingIce::BinaryStream&, bool&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_GetData(const ::std::string&, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int GetDataEx(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, ::Ice::Long __p_CompletedDataIdent, ::Ice::Long& __p_DataIdent, ::std::string& __p_token, ::Ice::Long& __p_Lba, ::Ice::Int& __p_secs, ::DataQueuingIce::BinaryStream& __p_data, bool& __p_isEnd, ::Ice::Long& __p_sn, ::Ice::Long& __p_TimeSeconds, ::Ice::Int& __p_TimeMicroseconds, ::Ice::Int& __p_crc, ::Ice::Int& __p_dataType, ::Ice::Int& __p_fragmentTotals, ::Ice::Int& __p_fragmentIndex)
    {
        return GetDataEx(__p_task, __p_QueueIdent, __p_CompletedDataIdent, __p_DataIdent, __p_token, __p_Lba, __p_secs, __p_data, __p_isEnd, __p_sn, __p_TimeSeconds, __p_TimeMicroseconds, __p_crc, __p_dataType, __p_fragmentTotals, __p_fragmentIndex, 0);
    }
    ::Ice::Int GetDataEx(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, ::Ice::Long __p_CompletedDataIdent, ::Ice::Long& __p_DataIdent, ::std::string& __p_token, ::Ice::Long& __p_Lba, ::Ice::Int& __p_secs, ::DataQueuingIce::BinaryStream& __p_data, bool& __p_isEnd, ::Ice::Long& __p_sn, ::Ice::Long& __p_TimeSeconds, ::Ice::Int& __p_TimeMicroseconds, ::Ice::Int& __p_crc, ::Ice::Int& __p_dataType, ::Ice::Int& __p_fragmentTotals, ::Ice::Int& __p_fragmentIndex, const ::Ice::Context& __ctx)
    {
        return GetDataEx(__p_task, __p_QueueIdent, __p_CompletedDataIdent, __p_DataIdent, __p_token, __p_Lba, __p_secs, __p_data, __p_isEnd, __p_sn, __p_TimeSeconds, __p_TimeMicroseconds, __p_crc, __p_dataType, __p_fragmentTotals, __p_fragmentIndex, &__ctx);
    }
#ifdef ICE_CPP11
#if !defined(_MSC_VER) || _MSC_VER > 1700
    //
    // COMPILERFIX VC compilers up to VC110 don't support more than 10 parameters with
    // std::function due to lack of variadic templates.
    //
    ::Ice::AsyncResultPtr
    begin_GetDataEx(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, ::Ice::Long __p_CompletedDataIdent, const ::IceInternal::Function<void (::Ice::Int, ::Ice::Long, const ::std::string&, ::Ice::Long, ::Ice::Int, const ::DataQueuingIce::BinaryStream&, bool, ::Ice::Long, ::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_GetDataEx(__p_task, __p_QueueIdent, __p_CompletedDataIdent, 0, __response, __exception, __sent);
    }
#endif
    ::Ice::AsyncResultPtr
    begin_GetDataEx(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, ::Ice::Long __p_CompletedDataIdent, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_GetDataEx(__p_task, __p_QueueIdent, __p_CompletedDataIdent, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
#if !defined(_MSC_VER) || _MSC_VER > 1700
    //
    // COMPILERFIX VC compilers up to VC110 don't support more than 10 parameters with
    // std::function due to lack of variadic templates.
    //
    ::Ice::AsyncResultPtr
    begin_GetDataEx(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, ::Ice::Long __p_CompletedDataIdent, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int, ::Ice::Long, const ::std::string&, ::Ice::Long, ::Ice::Int, const ::DataQueuingIce::BinaryStream&, bool, ::Ice::Long, ::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_GetDataEx(__p_task, __p_QueueIdent, __p_CompletedDataIdent, &__ctx, __response, __exception, __sent);
    }
#endif
    ::Ice::AsyncResultPtr
    begin_GetDataEx(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, ::Ice::Long __p_CompletedDataIdent, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_GetDataEx(__p_task, __p_QueueIdent, __p_CompletedDataIdent, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#if !defined(_MSC_VER) || _MSC_VER > 1700
    //
    // COMPILERFIX VC compilers up to VC110 don't support more than 10 parameters with
    // std::function due to lack of variadic templates.
    //
    
private:

    ::Ice::AsyncResultPtr __begin_GetDataEx(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, ::Ice::Long __p_CompletedDataIdent, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int, ::Ice::Long, const ::std::string&, ::Ice::Long, ::Ice::Int, const ::DataQueuingIce::BinaryStream&, bool, ::Ice::Long, ::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif
#endif

    ::Ice::AsyncResultPtr begin_GetDataEx(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, ::Ice::Long __p_CompletedDataIdent)
    {
        return begin_GetDataEx(__p_task, __p_QueueIdent, __p_CompletedDataIdent, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetDataEx(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, ::Ice::Long __p_CompletedDataIdent, const ::Ice::Context& __ctx)
    {
        return begin_GetDataEx(__p_task, __p_QueueIdent, __p_CompletedDataIdent, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetDataEx(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, ::Ice::Long __p_CompletedDataIdent, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetDataEx(__p_task, __p_QueueIdent, __p_CompletedDataIdent, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetDataEx(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, ::Ice::Long __p_CompletedDataIdent, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetDataEx(__p_task, __p_QueueIdent, __p_CompletedDataIdent, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetDataEx(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, ::Ice::Long __p_CompletedDataIdent, const ::DataQueuingIce::Callback_DataGuest_GetDataExPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetDataEx(__p_task, __p_QueueIdent, __p_CompletedDataIdent, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetDataEx(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, ::Ice::Long __p_CompletedDataIdent, const ::Ice::Context& __ctx, const ::DataQueuingIce::Callback_DataGuest_GetDataExPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetDataEx(__p_task, __p_QueueIdent, __p_CompletedDataIdent, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_GetDataEx(::Ice::Long& __p_DataIdent, ::std::string& __p_token, ::Ice::Long& __p_Lba, ::Ice::Int& __p_secs, ::DataQueuingIce::BinaryStream& __p_data, bool& __p_isEnd, ::Ice::Long& __p_sn, ::Ice::Long& __p_TimeSeconds, ::Ice::Int& __p_TimeMicroseconds, ::Ice::Int& __p_crc, ::Ice::Int& __p_dataType, ::Ice::Int& __p_fragmentTotals, ::Ice::Int& __p_fragmentIndex, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int GetDataEx(const ::std::string&, ::Ice::Int, ::Ice::Long, ::Ice::Long&, ::std::string&, ::Ice::Long&, ::Ice::Int&, ::DataQueuingIce::BinaryStream&, bool&, ::Ice::Long&, ::Ice::Long&, ::Ice::Int&, ::Ice::Int&, ::Ice::Int&, ::Ice::Int&, ::Ice::Int&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_GetDataEx(const ::std::string&, ::Ice::Int, ::Ice::Long, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int DataCompleted(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, ::Ice::Long __p_DataIdent)
    {
        return DataCompleted(__p_task, __p_QueueIdent, __p_DataIdent, 0);
    }
    ::Ice::Int DataCompleted(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, ::Ice::Long __p_DataIdent, const ::Ice::Context& __ctx)
    {
        return DataCompleted(__p_task, __p_QueueIdent, __p_DataIdent, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_DataCompleted(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, ::Ice::Long __p_DataIdent, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_DataCompleted(__p_task, __p_QueueIdent, __p_DataIdent, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_DataCompleted(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, ::Ice::Long __p_DataIdent, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_DataCompleted(__p_task, __p_QueueIdent, __p_DataIdent, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_DataCompleted(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, ::Ice::Long __p_DataIdent, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_DataCompleted(__p_task, __p_QueueIdent, __p_DataIdent, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_DataCompleted(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, ::Ice::Long __p_DataIdent, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_DataCompleted(__p_task, __p_QueueIdent, __p_DataIdent, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_DataCompleted(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, ::Ice::Long __p_DataIdent, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_DataCompleted(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, ::Ice::Long __p_DataIdent)
    {
        return begin_DataCompleted(__p_task, __p_QueueIdent, __p_DataIdent, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_DataCompleted(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, ::Ice::Long __p_DataIdent, const ::Ice::Context& __ctx)
    {
        return begin_DataCompleted(__p_task, __p_QueueIdent, __p_DataIdent, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_DataCompleted(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, ::Ice::Long __p_DataIdent, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_DataCompleted(__p_task, __p_QueueIdent, __p_DataIdent, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_DataCompleted(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, ::Ice::Long __p_DataIdent, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_DataCompleted(__p_task, __p_QueueIdent, __p_DataIdent, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_DataCompleted(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, ::Ice::Long __p_DataIdent, const ::DataQueuingIce::Callback_DataGuest_DataCompletedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_DataCompleted(__p_task, __p_QueueIdent, __p_DataIdent, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_DataCompleted(const ::std::string& __p_task, ::Ice::Int __p_QueueIdent, ::Ice::Long __p_DataIdent, const ::Ice::Context& __ctx, const ::DataQueuingIce::Callback_DataGuest_DataCompletedPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_DataCompleted(__p_task, __p_QueueIdent, __p_DataIdent, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_DataCompleted(const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int DataCompleted(const ::std::string&, ::Ice::Int, ::Ice::Long, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_DataCompleted(const ::std::string&, ::Ice::Int, ::Ice::Long, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int GetBitmapInfo(const ::std::string& __p_task, ::Ice::Int& __p_bitmapCount)
    {
        return GetBitmapInfo(__p_task, __p_bitmapCount, 0);
    }
    ::Ice::Int GetBitmapInfo(const ::std::string& __p_task, ::Ice::Int& __p_bitmapCount, const ::Ice::Context& __ctx)
    {
        return GetBitmapInfo(__p_task, __p_bitmapCount, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_GetBitmapInfo(const ::std::string& __p_task, const ::IceInternal::Function<void (::Ice::Int, ::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_GetBitmapInfo(__p_task, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_GetBitmapInfo(const ::std::string& __p_task, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_GetBitmapInfo(__p_task, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_GetBitmapInfo(const ::std::string& __p_task, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int, ::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_GetBitmapInfo(__p_task, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_GetBitmapInfo(const ::std::string& __p_task, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_GetBitmapInfo(__p_task, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_GetBitmapInfo(const ::std::string& __p_task, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int, ::Ice::Int)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_GetBitmapInfo(const ::std::string& __p_task)
    {
        return begin_GetBitmapInfo(__p_task, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetBitmapInfo(const ::std::string& __p_task, const ::Ice::Context& __ctx)
    {
        return begin_GetBitmapInfo(__p_task, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetBitmapInfo(const ::std::string& __p_task, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetBitmapInfo(__p_task, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetBitmapInfo(const ::std::string& __p_task, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetBitmapInfo(__p_task, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetBitmapInfo(const ::std::string& __p_task, const ::DataQueuingIce::Callback_DataGuest_GetBitmapInfoPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetBitmapInfo(__p_task, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetBitmapInfo(const ::std::string& __p_task, const ::Ice::Context& __ctx, const ::DataQueuingIce::Callback_DataGuest_GetBitmapInfoPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetBitmapInfo(__p_task, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_GetBitmapInfo(::Ice::Int& __p_bitmapCount, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int GetBitmapInfo(const ::std::string&, ::Ice::Int&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_GetBitmapInfo(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Ice::Int GetBitmapData(const ::std::string& __p_task, ::Ice::Int __p_bitmapId, ::Ice::Int __p_bitmapOffset, ::Ice::Int __p_maxbytes, ::std::string& __p_token, ::DataQueuingIce::BinaryStream& __p_data, bool& __p_isEnd)
    {
        return GetBitmapData(__p_task, __p_bitmapId, __p_bitmapOffset, __p_maxbytes, __p_token, __p_data, __p_isEnd, 0);
    }
    ::Ice::Int GetBitmapData(const ::std::string& __p_task, ::Ice::Int __p_bitmapId, ::Ice::Int __p_bitmapOffset, ::Ice::Int __p_maxbytes, ::std::string& __p_token, ::DataQueuingIce::BinaryStream& __p_data, bool& __p_isEnd, const ::Ice::Context& __ctx)
    {
        return GetBitmapData(__p_task, __p_bitmapId, __p_bitmapOffset, __p_maxbytes, __p_token, __p_data, __p_isEnd, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_GetBitmapData(const ::std::string& __p_task, ::Ice::Int __p_bitmapId, ::Ice::Int __p_bitmapOffset, ::Ice::Int __p_maxbytes, const ::IceInternal::Function<void (::Ice::Int, const ::std::string&, const ::DataQueuingIce::BinaryStream&, bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_GetBitmapData(__p_task, __p_bitmapId, __p_bitmapOffset, __p_maxbytes, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_GetBitmapData(const ::std::string& __p_task, ::Ice::Int __p_bitmapId, ::Ice::Int __p_bitmapOffset, ::Ice::Int __p_maxbytes, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_GetBitmapData(__p_task, __p_bitmapId, __p_bitmapOffset, __p_maxbytes, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_GetBitmapData(const ::std::string& __p_task, ::Ice::Int __p_bitmapId, ::Ice::Int __p_bitmapOffset, ::Ice::Int __p_maxbytes, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (::Ice::Int, const ::std::string&, const ::DataQueuingIce::BinaryStream&, bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_GetBitmapData(__p_task, __p_bitmapId, __p_bitmapOffset, __p_maxbytes, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_GetBitmapData(const ::std::string& __p_task, ::Ice::Int __p_bitmapId, ::Ice::Int __p_bitmapOffset, ::Ice::Int __p_maxbytes, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_GetBitmapData(__p_task, __p_bitmapId, __p_bitmapOffset, __p_maxbytes, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_GetBitmapData(const ::std::string& __p_task, ::Ice::Int __p_bitmapId, ::Ice::Int __p_bitmapOffset, ::Ice::Int __p_maxbytes, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (::Ice::Int, const ::std::string&, const ::DataQueuingIce::BinaryStream&, bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent);
    
public:
#endif

    ::Ice::AsyncResultPtr begin_GetBitmapData(const ::std::string& __p_task, ::Ice::Int __p_bitmapId, ::Ice::Int __p_bitmapOffset, ::Ice::Int __p_maxbytes)
    {
        return begin_GetBitmapData(__p_task, __p_bitmapId, __p_bitmapOffset, __p_maxbytes, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetBitmapData(const ::std::string& __p_task, ::Ice::Int __p_bitmapId, ::Ice::Int __p_bitmapOffset, ::Ice::Int __p_maxbytes, const ::Ice::Context& __ctx)
    {
        return begin_GetBitmapData(__p_task, __p_bitmapId, __p_bitmapOffset, __p_maxbytes, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetBitmapData(const ::std::string& __p_task, ::Ice::Int __p_bitmapId, ::Ice::Int __p_bitmapOffset, ::Ice::Int __p_maxbytes, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetBitmapData(__p_task, __p_bitmapId, __p_bitmapOffset, __p_maxbytes, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetBitmapData(const ::std::string& __p_task, ::Ice::Int __p_bitmapId, ::Ice::Int __p_bitmapOffset, ::Ice::Int __p_maxbytes, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetBitmapData(__p_task, __p_bitmapId, __p_bitmapOffset, __p_maxbytes, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetBitmapData(const ::std::string& __p_task, ::Ice::Int __p_bitmapId, ::Ice::Int __p_bitmapOffset, ::Ice::Int __p_maxbytes, const ::DataQueuingIce::Callback_DataGuest_GetBitmapDataPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetBitmapData(__p_task, __p_bitmapId, __p_bitmapOffset, __p_maxbytes, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_GetBitmapData(const ::std::string& __p_task, ::Ice::Int __p_bitmapId, ::Ice::Int __p_bitmapOffset, ::Ice::Int __p_maxbytes, const ::Ice::Context& __ctx, const ::DataQueuingIce::Callback_DataGuest_GetBitmapDataPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_GetBitmapData(__p_task, __p_bitmapId, __p_bitmapOffset, __p_maxbytes, &__ctx, __del, __cookie);
    }

    ::Ice::Int end_GetBitmapData(::std::string& __p_token, ::DataQueuingIce::BinaryStream& __p_data, bool& __p_isEnd, const ::Ice::AsyncResultPtr&);
    
private:

    ::Ice::Int GetBitmapData(const ::std::string&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::std::string&, ::DataQueuingIce::BinaryStream&, bool&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_GetBitmapData(const ::std::string&, ::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<DataGuest> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<DataGuest*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<DataGuest> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<DataGuest*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<DataGuest> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<DataGuest*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<DataGuest> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<DataGuest*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<DataGuest> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<DataGuest*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<DataGuest> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<DataGuest*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<DataGuest> ice_secure(bool __secure) const
    {
        return dynamic_cast<DataGuest*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<DataGuest> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<DataGuest*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<DataGuest> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<DataGuest*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<DataGuest> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<DataGuest*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<DataGuest> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<DataGuest*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<DataGuest> ice_invocationTimeout(int __timeout) const
    {
        return dynamic_cast<DataGuest*>(::IceProxy::Ice::Object::ice_invocationTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<DataGuest> ice_twoway() const
    {
        return dynamic_cast<DataGuest*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<DataGuest> ice_oneway() const
    {
        return dynamic_cast<DataGuest*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<DataGuest> ice_batchOneway() const
    {
        return dynamic_cast<DataGuest*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<DataGuest> ice_datagram() const
    {
        return dynamic_cast<DataGuest*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<DataGuest> ice_batchDatagram() const
    {
        return dynamic_cast<DataGuest*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<DataGuest> ice_compress(bool __compress) const
    {
        return dynamic_cast<DataGuest*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<DataGuest> ice_timeout(int __timeout) const
    {
        return dynamic_cast<DataGuest*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<DataGuest> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<DataGuest*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<DataGuest> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<DataGuest*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

namespace DataQueuingIce
{

class DataCreator : virtual public ::Ice::Object
{
public:

    typedef DataCreatorPrx ProxyType;
    typedef DataCreatorPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::Ice::Int StartCDPWork(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, bool, const ::DataQueuingIce::ExcludeRuns&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___StartCDPWork(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int StartQemuWorkForBitmap(const ::std::string&, const ::std::string&, const ::IMG::ImageSnapshotIdents&, const ::DataQueuingIce::BinaryStream&, const ::DataQueuingIce::ExcludeRuns&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___StartQemuWorkForBitmap(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int StartQemuWorkForBitmapv2(const ::std::string&, const ::std::string&, const ::IMG::ImageSnapshotIdents&, const ::std::string&, const ::DataQueuingIce::ExcludeRuns&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___StartQemuWorkForBitmapv2(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int StartQemuWork(const ::std::string&, const ::std::string&, const ::IMG::ImageSnapshotIdents&, const ::DataQueuingIce::ExcludeRuns&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___StartQemuWork(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int QueryQemuProgress(const ::std::string&, const ::std::string&, ::Ice::Long&, ::Ice::Long&, ::Ice::Int&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___QueryQemuProgress(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int QueryCDPProgress(const ::std::string&, const ::std::string&, ::std::string&, ::Ice::Int&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___QueryCDPProgress(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int QueryWorkStatus(const ::std::string&, const ::std::string&, ::DataQueuingIce::WorkType&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___QueryWorkStatus(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int StopQemuWork(const ::std::string&, const ::std::string&, ::DataQueuingIce::BinaryStream&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___StopQemuWork(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int StopQemuWorkv2(const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___StopQemuWorkv2(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int StopCDPWork(const ::std::string&, const ::std::string&, ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___StopCDPWork(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int SetRestoreBitmap(const ::std::string&, const ::DataQueuingIce::DiskBitmap&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___SetRestoreBitmap(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int SetRestoreBitmapv2(const ::std::string&, const ::DataQueuingIce::DiskBitmapv2&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___SetRestoreBitmapv2(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int EndTask(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___EndTask(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int CloseTask(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___CloseTask(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
};

inline bool operator==(const DataCreator& l, const DataCreator& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const DataCreator& l, const DataCreator& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class DataGuest : virtual public ::Ice::Object
{
public:

    typedef DataGuestPrx ProxyType;
    typedef DataGuestPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::Ice::Int InitGuest(const ::std::string&, ::Ice::Int, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___InitGuest(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int GetData(const ::std::string&, ::Ice::Int, ::Ice::Long&, ::std::string&, ::Ice::Long&, ::Ice::Int&, ::DataQueuingIce::BinaryStream&, bool&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___GetData(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int GetDataEx(const ::std::string&, ::Ice::Int, ::Ice::Long, ::Ice::Long&, ::std::string&, ::Ice::Long&, ::Ice::Int&, ::DataQueuingIce::BinaryStream&, bool&, ::Ice::Long&, ::Ice::Long&, ::Ice::Int&, ::Ice::Int&, ::Ice::Int&, ::Ice::Int&, ::Ice::Int&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___GetDataEx(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int DataCompleted(const ::std::string&, ::Ice::Int, ::Ice::Long, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___DataCompleted(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int GetBitmapInfo(const ::std::string&, ::Ice::Int&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___GetBitmapInfo(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::Int GetBitmapData(const ::std::string&, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::std::string&, ::DataQueuingIce::BinaryStream&, bool&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___GetBitmapData(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
};

inline bool operator==(const DataGuest& l, const DataGuest& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const DataGuest& l, const DataGuest& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace DataQueuingIce
{

template<class T>
class CallbackNC_DataCreator_StartCDPWork : public Callback_DataCreator_StartCDPWork_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_DataCreator_StartCDPWork(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataCreatorPrx __proxy = ::DataQueuingIce::DataCreatorPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_StartCDPWork(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_DataCreator_StartCDPWorkPtr
newCallback_DataCreator_StartCDPWork(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataCreator_StartCDPWork<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DataCreator_StartCDPWorkPtr
newCallback_DataCreator_StartCDPWork(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataCreator_StartCDPWork<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_DataCreator_StartCDPWork : public Callback_DataCreator_StartCDPWork_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_DataCreator_StartCDPWork(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataCreatorPrx __proxy = ::DataQueuingIce::DataCreatorPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_StartCDPWork(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_DataCreator_StartCDPWorkPtr
newCallback_DataCreator_StartCDPWork(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataCreator_StartCDPWork<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DataCreator_StartCDPWorkPtr
newCallback_DataCreator_StartCDPWork(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataCreator_StartCDPWork<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_DataCreator_StartQemuWorkForBitmap : public Callback_DataCreator_StartQemuWorkForBitmap_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_DataCreator_StartQemuWorkForBitmap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataCreatorPrx __proxy = ::DataQueuingIce::DataCreatorPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_StartQemuWorkForBitmap(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_DataCreator_StartQemuWorkForBitmapPtr
newCallback_DataCreator_StartQemuWorkForBitmap(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataCreator_StartQemuWorkForBitmap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DataCreator_StartQemuWorkForBitmapPtr
newCallback_DataCreator_StartQemuWorkForBitmap(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataCreator_StartQemuWorkForBitmap<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_DataCreator_StartQemuWorkForBitmap : public Callback_DataCreator_StartQemuWorkForBitmap_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_DataCreator_StartQemuWorkForBitmap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataCreatorPrx __proxy = ::DataQueuingIce::DataCreatorPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_StartQemuWorkForBitmap(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_DataCreator_StartQemuWorkForBitmapPtr
newCallback_DataCreator_StartQemuWorkForBitmap(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataCreator_StartQemuWorkForBitmap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DataCreator_StartQemuWorkForBitmapPtr
newCallback_DataCreator_StartQemuWorkForBitmap(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataCreator_StartQemuWorkForBitmap<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_DataCreator_StartQemuWorkForBitmapv2 : public Callback_DataCreator_StartQemuWorkForBitmapv2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_DataCreator_StartQemuWorkForBitmapv2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataCreatorPrx __proxy = ::DataQueuingIce::DataCreatorPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_StartQemuWorkForBitmapv2(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_DataCreator_StartQemuWorkForBitmapv2Ptr
newCallback_DataCreator_StartQemuWorkForBitmapv2(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataCreator_StartQemuWorkForBitmapv2<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DataCreator_StartQemuWorkForBitmapv2Ptr
newCallback_DataCreator_StartQemuWorkForBitmapv2(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataCreator_StartQemuWorkForBitmapv2<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_DataCreator_StartQemuWorkForBitmapv2 : public Callback_DataCreator_StartQemuWorkForBitmapv2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_DataCreator_StartQemuWorkForBitmapv2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataCreatorPrx __proxy = ::DataQueuingIce::DataCreatorPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_StartQemuWorkForBitmapv2(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_DataCreator_StartQemuWorkForBitmapv2Ptr
newCallback_DataCreator_StartQemuWorkForBitmapv2(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataCreator_StartQemuWorkForBitmapv2<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DataCreator_StartQemuWorkForBitmapv2Ptr
newCallback_DataCreator_StartQemuWorkForBitmapv2(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataCreator_StartQemuWorkForBitmapv2<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_DataCreator_StartQemuWork : public Callback_DataCreator_StartQemuWork_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_DataCreator_StartQemuWork(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataCreatorPrx __proxy = ::DataQueuingIce::DataCreatorPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_StartQemuWork(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_DataCreator_StartQemuWorkPtr
newCallback_DataCreator_StartQemuWork(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataCreator_StartQemuWork<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DataCreator_StartQemuWorkPtr
newCallback_DataCreator_StartQemuWork(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataCreator_StartQemuWork<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_DataCreator_StartQemuWork : public Callback_DataCreator_StartQemuWork_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_DataCreator_StartQemuWork(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataCreatorPrx __proxy = ::DataQueuingIce::DataCreatorPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_StartQemuWork(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_DataCreator_StartQemuWorkPtr
newCallback_DataCreator_StartQemuWork(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataCreator_StartQemuWork<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DataCreator_StartQemuWorkPtr
newCallback_DataCreator_StartQemuWork(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataCreator_StartQemuWork<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_DataCreator_QueryQemuProgress : public Callback_DataCreator_QueryQemuProgress_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, ::Ice::Long, ::Ice::Long, ::Ice::Int);

    CallbackNC_DataCreator_QueryQemuProgress(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataCreatorPrx __proxy = ::DataQueuingIce::DataCreatorPrx::uncheckedCast(__result->getProxy());
        ::Ice::Long totalBytes;
        ::Ice::Long completedBytes;
        ::Ice::Int queueLen;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_QueryQemuProgress(totalBytes, completedBytes, queueLen, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, totalBytes, completedBytes, queueLen);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_DataCreator_QueryQemuProgressPtr
newCallback_DataCreator_QueryQemuProgress(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, ::Ice::Long, ::Ice::Long, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataCreator_QueryQemuProgress<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DataCreator_QueryQemuProgressPtr
newCallback_DataCreator_QueryQemuProgress(T* instance, void (T::*cb)(::Ice::Int, ::Ice::Long, ::Ice::Long, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataCreator_QueryQemuProgress<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_DataCreator_QueryQemuProgress : public Callback_DataCreator_QueryQemuProgress_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, ::Ice::Long, ::Ice::Long, ::Ice::Int, const CT&);

    Callback_DataCreator_QueryQemuProgress(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataCreatorPrx __proxy = ::DataQueuingIce::DataCreatorPrx::uncheckedCast(__result->getProxy());
        ::Ice::Long totalBytes;
        ::Ice::Long completedBytes;
        ::Ice::Int queueLen;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_QueryQemuProgress(totalBytes, completedBytes, queueLen, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, totalBytes, completedBytes, queueLen, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_DataCreator_QueryQemuProgressPtr
newCallback_DataCreator_QueryQemuProgress(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, ::Ice::Long, ::Ice::Long, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataCreator_QueryQemuProgress<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DataCreator_QueryQemuProgressPtr
newCallback_DataCreator_QueryQemuProgress(T* instance, void (T::*cb)(::Ice::Int, ::Ice::Long, ::Ice::Long, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataCreator_QueryQemuProgress<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_DataCreator_QueryCDPProgress : public Callback_DataCreator_QueryCDPProgress_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, const ::std::string&, ::Ice::Int);

    CallbackNC_DataCreator_QueryCDPProgress(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataCreatorPrx __proxy = ::DataQueuingIce::DataCreatorPrx::uncheckedCast(__result->getProxy());
        ::std::string lastTime;
        ::Ice::Int queueLen;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_QueryCDPProgress(lastTime, queueLen, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, lastTime, queueLen);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_DataCreator_QueryCDPProgressPtr
newCallback_DataCreator_QueryCDPProgress(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::std::string&, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataCreator_QueryCDPProgress<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DataCreator_QueryCDPProgressPtr
newCallback_DataCreator_QueryCDPProgress(T* instance, void (T::*cb)(::Ice::Int, const ::std::string&, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataCreator_QueryCDPProgress<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_DataCreator_QueryCDPProgress : public Callback_DataCreator_QueryCDPProgress_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const ::std::string&, ::Ice::Int, const CT&);

    Callback_DataCreator_QueryCDPProgress(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataCreatorPrx __proxy = ::DataQueuingIce::DataCreatorPrx::uncheckedCast(__result->getProxy());
        ::std::string lastTime;
        ::Ice::Int queueLen;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_QueryCDPProgress(lastTime, queueLen, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, lastTime, queueLen, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_DataCreator_QueryCDPProgressPtr
newCallback_DataCreator_QueryCDPProgress(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::std::string&, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataCreator_QueryCDPProgress<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DataCreator_QueryCDPProgressPtr
newCallback_DataCreator_QueryCDPProgress(T* instance, void (T::*cb)(::Ice::Int, const ::std::string&, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataCreator_QueryCDPProgress<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_DataCreator_QueryWorkStatus : public Callback_DataCreator_QueryWorkStatus_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, ::DataQueuingIce::WorkType);

    CallbackNC_DataCreator_QueryWorkStatus(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataCreatorPrx __proxy = ::DataQueuingIce::DataCreatorPrx::uncheckedCast(__result->getProxy());
        ::DataQueuingIce::WorkType workType;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_QueryWorkStatus(workType, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, workType);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_DataCreator_QueryWorkStatusPtr
newCallback_DataCreator_QueryWorkStatus(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, ::DataQueuingIce::WorkType), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataCreator_QueryWorkStatus<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DataCreator_QueryWorkStatusPtr
newCallback_DataCreator_QueryWorkStatus(T* instance, void (T::*cb)(::Ice::Int, ::DataQueuingIce::WorkType), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataCreator_QueryWorkStatus<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_DataCreator_QueryWorkStatus : public Callback_DataCreator_QueryWorkStatus_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, ::DataQueuingIce::WorkType, const CT&);

    Callback_DataCreator_QueryWorkStatus(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataCreatorPrx __proxy = ::DataQueuingIce::DataCreatorPrx::uncheckedCast(__result->getProxy());
        ::DataQueuingIce::WorkType workType;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_QueryWorkStatus(workType, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, workType, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_DataCreator_QueryWorkStatusPtr
newCallback_DataCreator_QueryWorkStatus(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, ::DataQueuingIce::WorkType, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataCreator_QueryWorkStatus<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DataCreator_QueryWorkStatusPtr
newCallback_DataCreator_QueryWorkStatus(T* instance, void (T::*cb)(::Ice::Int, ::DataQueuingIce::WorkType, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataCreator_QueryWorkStatus<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_DataCreator_StopQemuWork : public Callback_DataCreator_StopQemuWork_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, const ::DataQueuingIce::BinaryStream&);

    CallbackNC_DataCreator_StopQemuWork(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataCreatorPrx __proxy = ::DataQueuingIce::DataCreatorPrx::uncheckedCast(__result->getProxy());
        ::DataQueuingIce::BinaryStream bitmap;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_StopQemuWork(bitmap, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, bitmap);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_DataCreator_StopQemuWorkPtr
newCallback_DataCreator_StopQemuWork(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::DataQueuingIce::BinaryStream&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataCreator_StopQemuWork<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DataCreator_StopQemuWorkPtr
newCallback_DataCreator_StopQemuWork(T* instance, void (T::*cb)(::Ice::Int, const ::DataQueuingIce::BinaryStream&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataCreator_StopQemuWork<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_DataCreator_StopQemuWork : public Callback_DataCreator_StopQemuWork_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const ::DataQueuingIce::BinaryStream&, const CT&);

    Callback_DataCreator_StopQemuWork(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataCreatorPrx __proxy = ::DataQueuingIce::DataCreatorPrx::uncheckedCast(__result->getProxy());
        ::DataQueuingIce::BinaryStream bitmap;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_StopQemuWork(bitmap, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, bitmap, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_DataCreator_StopQemuWorkPtr
newCallback_DataCreator_StopQemuWork(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::DataQueuingIce::BinaryStream&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataCreator_StopQemuWork<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DataCreator_StopQemuWorkPtr
newCallback_DataCreator_StopQemuWork(T* instance, void (T::*cb)(::Ice::Int, const ::DataQueuingIce::BinaryStream&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataCreator_StopQemuWork<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_DataCreator_StopQemuWorkv2 : public Callback_DataCreator_StopQemuWorkv2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_DataCreator_StopQemuWorkv2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataCreatorPrx __proxy = ::DataQueuingIce::DataCreatorPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_StopQemuWorkv2(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_DataCreator_StopQemuWorkv2Ptr
newCallback_DataCreator_StopQemuWorkv2(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataCreator_StopQemuWorkv2<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DataCreator_StopQemuWorkv2Ptr
newCallback_DataCreator_StopQemuWorkv2(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataCreator_StopQemuWorkv2<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_DataCreator_StopQemuWorkv2 : public Callback_DataCreator_StopQemuWorkv2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_DataCreator_StopQemuWorkv2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataCreatorPrx __proxy = ::DataQueuingIce::DataCreatorPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_StopQemuWorkv2(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_DataCreator_StopQemuWorkv2Ptr
newCallback_DataCreator_StopQemuWorkv2(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataCreator_StopQemuWorkv2<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DataCreator_StopQemuWorkv2Ptr
newCallback_DataCreator_StopQemuWorkv2(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataCreator_StopQemuWorkv2<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_DataCreator_StopCDPWork : public Callback_DataCreator_StopCDPWork_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, const ::std::string&);

    CallbackNC_DataCreator_StopCDPWork(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataCreatorPrx __proxy = ::DataQueuingIce::DataCreatorPrx::uncheckedCast(__result->getProxy());
        ::std::string lastTime;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_StopCDPWork(lastTime, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, lastTime);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_DataCreator_StopCDPWorkPtr
newCallback_DataCreator_StopCDPWork(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataCreator_StopCDPWork<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DataCreator_StopCDPWorkPtr
newCallback_DataCreator_StopCDPWork(T* instance, void (T::*cb)(::Ice::Int, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataCreator_StopCDPWork<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_DataCreator_StopCDPWork : public Callback_DataCreator_StopCDPWork_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const ::std::string&, const CT&);

    Callback_DataCreator_StopCDPWork(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataCreatorPrx __proxy = ::DataQueuingIce::DataCreatorPrx::uncheckedCast(__result->getProxy());
        ::std::string lastTime;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_StopCDPWork(lastTime, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, lastTime, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_DataCreator_StopCDPWorkPtr
newCallback_DataCreator_StopCDPWork(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataCreator_StopCDPWork<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DataCreator_StopCDPWorkPtr
newCallback_DataCreator_StopCDPWork(T* instance, void (T::*cb)(::Ice::Int, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataCreator_StopCDPWork<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_DataCreator_SetRestoreBitmap : public Callback_DataCreator_SetRestoreBitmap_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_DataCreator_SetRestoreBitmap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataCreatorPrx __proxy = ::DataQueuingIce::DataCreatorPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_SetRestoreBitmap(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_DataCreator_SetRestoreBitmapPtr
newCallback_DataCreator_SetRestoreBitmap(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataCreator_SetRestoreBitmap<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DataCreator_SetRestoreBitmapPtr
newCallback_DataCreator_SetRestoreBitmap(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataCreator_SetRestoreBitmap<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_DataCreator_SetRestoreBitmap : public Callback_DataCreator_SetRestoreBitmap_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_DataCreator_SetRestoreBitmap(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataCreatorPrx __proxy = ::DataQueuingIce::DataCreatorPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_SetRestoreBitmap(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_DataCreator_SetRestoreBitmapPtr
newCallback_DataCreator_SetRestoreBitmap(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataCreator_SetRestoreBitmap<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DataCreator_SetRestoreBitmapPtr
newCallback_DataCreator_SetRestoreBitmap(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataCreator_SetRestoreBitmap<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_DataCreator_SetRestoreBitmapv2 : public Callback_DataCreator_SetRestoreBitmapv2_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_DataCreator_SetRestoreBitmapv2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataCreatorPrx __proxy = ::DataQueuingIce::DataCreatorPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_SetRestoreBitmapv2(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_DataCreator_SetRestoreBitmapv2Ptr
newCallback_DataCreator_SetRestoreBitmapv2(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataCreator_SetRestoreBitmapv2<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DataCreator_SetRestoreBitmapv2Ptr
newCallback_DataCreator_SetRestoreBitmapv2(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataCreator_SetRestoreBitmapv2<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_DataCreator_SetRestoreBitmapv2 : public Callback_DataCreator_SetRestoreBitmapv2_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_DataCreator_SetRestoreBitmapv2(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataCreatorPrx __proxy = ::DataQueuingIce::DataCreatorPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_SetRestoreBitmapv2(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_DataCreator_SetRestoreBitmapv2Ptr
newCallback_DataCreator_SetRestoreBitmapv2(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataCreator_SetRestoreBitmapv2<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DataCreator_SetRestoreBitmapv2Ptr
newCallback_DataCreator_SetRestoreBitmapv2(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataCreator_SetRestoreBitmapv2<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_DataCreator_EndTask : public Callback_DataCreator_EndTask_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_DataCreator_EndTask(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataCreatorPrx __proxy = ::DataQueuingIce::DataCreatorPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_EndTask(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_DataCreator_EndTaskPtr
newCallback_DataCreator_EndTask(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataCreator_EndTask<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DataCreator_EndTaskPtr
newCallback_DataCreator_EndTask(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataCreator_EndTask<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_DataCreator_EndTask : public Callback_DataCreator_EndTask_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_DataCreator_EndTask(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataCreatorPrx __proxy = ::DataQueuingIce::DataCreatorPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_EndTask(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_DataCreator_EndTaskPtr
newCallback_DataCreator_EndTask(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataCreator_EndTask<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DataCreator_EndTaskPtr
newCallback_DataCreator_EndTask(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataCreator_EndTask<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_DataCreator_CloseTask : public Callback_DataCreator_CloseTask_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_DataCreator_CloseTask(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataCreatorPrx __proxy = ::DataQueuingIce::DataCreatorPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_CloseTask(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_DataCreator_CloseTaskPtr
newCallback_DataCreator_CloseTask(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataCreator_CloseTask<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DataCreator_CloseTaskPtr
newCallback_DataCreator_CloseTask(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataCreator_CloseTask<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_DataCreator_CloseTask : public Callback_DataCreator_CloseTask_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_DataCreator_CloseTask(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataCreatorPrx __proxy = ::DataQueuingIce::DataCreatorPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_CloseTask(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_DataCreator_CloseTaskPtr
newCallback_DataCreator_CloseTask(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataCreator_CloseTask<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DataCreator_CloseTaskPtr
newCallback_DataCreator_CloseTask(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataCreator_CloseTask<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_DataGuest_InitGuest : public Callback_DataGuest_InitGuest_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_DataGuest_InitGuest(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataGuestPrx __proxy = ::DataQueuingIce::DataGuestPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_InitGuest(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_DataGuest_InitGuestPtr
newCallback_DataGuest_InitGuest(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataGuest_InitGuest<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DataGuest_InitGuestPtr
newCallback_DataGuest_InitGuest(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataGuest_InitGuest<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_DataGuest_InitGuest : public Callback_DataGuest_InitGuest_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_DataGuest_InitGuest(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataGuestPrx __proxy = ::DataQueuingIce::DataGuestPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_InitGuest(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_DataGuest_InitGuestPtr
newCallback_DataGuest_InitGuest(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataGuest_InitGuest<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DataGuest_InitGuestPtr
newCallback_DataGuest_InitGuest(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataGuest_InitGuest<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_DataGuest_GetData : public Callback_DataGuest_GetData_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, ::Ice::Long, const ::std::string&, ::Ice::Long, ::Ice::Int, const ::DataQueuingIce::BinaryStream&, bool);

    CallbackNC_DataGuest_GetData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataGuestPrx __proxy = ::DataQueuingIce::DataGuestPrx::uncheckedCast(__result->getProxy());
        ::Ice::Long DataIdent;
        ::std::string token;
        ::Ice::Long Lba;
        ::Ice::Int secs;
        ::DataQueuingIce::BinaryStream data;
        bool isEnd;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_GetData(DataIdent, token, Lba, secs, data, isEnd, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, DataIdent, token, Lba, secs, data, isEnd);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_DataGuest_GetDataPtr
newCallback_DataGuest_GetData(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, ::Ice::Long, const ::std::string&, ::Ice::Long, ::Ice::Int, const ::DataQueuingIce::BinaryStream&, bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataGuest_GetData<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DataGuest_GetDataPtr
newCallback_DataGuest_GetData(T* instance, void (T::*cb)(::Ice::Int, ::Ice::Long, const ::std::string&, ::Ice::Long, ::Ice::Int, const ::DataQueuingIce::BinaryStream&, bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataGuest_GetData<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_DataGuest_GetData : public Callback_DataGuest_GetData_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, ::Ice::Long, const ::std::string&, ::Ice::Long, ::Ice::Int, const ::DataQueuingIce::BinaryStream&, bool, const CT&);

    Callback_DataGuest_GetData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataGuestPrx __proxy = ::DataQueuingIce::DataGuestPrx::uncheckedCast(__result->getProxy());
        ::Ice::Long DataIdent;
        ::std::string token;
        ::Ice::Long Lba;
        ::Ice::Int secs;
        ::DataQueuingIce::BinaryStream data;
        bool isEnd;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_GetData(DataIdent, token, Lba, secs, data, isEnd, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, DataIdent, token, Lba, secs, data, isEnd, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_DataGuest_GetDataPtr
newCallback_DataGuest_GetData(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, ::Ice::Long, const ::std::string&, ::Ice::Long, ::Ice::Int, const ::DataQueuingIce::BinaryStream&, bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataGuest_GetData<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DataGuest_GetDataPtr
newCallback_DataGuest_GetData(T* instance, void (T::*cb)(::Ice::Int, ::Ice::Long, const ::std::string&, ::Ice::Long, ::Ice::Int, const ::DataQueuingIce::BinaryStream&, bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataGuest_GetData<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_DataGuest_GetDataEx : public Callback_DataGuest_GetDataEx_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, ::Ice::Long, const ::std::string&, ::Ice::Long, ::Ice::Int, const ::DataQueuingIce::BinaryStream&, bool, ::Ice::Long, ::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int);

    CallbackNC_DataGuest_GetDataEx(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataGuestPrx __proxy = ::DataQueuingIce::DataGuestPrx::uncheckedCast(__result->getProxy());
        ::Ice::Long DataIdent;
        ::std::string token;
        ::Ice::Long Lba;
        ::Ice::Int secs;
        ::DataQueuingIce::BinaryStream data;
        bool isEnd;
        ::Ice::Long sn;
        ::Ice::Long TimeSeconds;
        ::Ice::Int TimeMicroseconds;
        ::Ice::Int crc;
        ::Ice::Int dataType;
        ::Ice::Int fragmentTotals;
        ::Ice::Int fragmentIndex;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_GetDataEx(DataIdent, token, Lba, secs, data, isEnd, sn, TimeSeconds, TimeMicroseconds, crc, dataType, fragmentTotals, fragmentIndex, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, DataIdent, token, Lba, secs, data, isEnd, sn, TimeSeconds, TimeMicroseconds, crc, dataType, fragmentTotals, fragmentIndex);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_DataGuest_GetDataExPtr
newCallback_DataGuest_GetDataEx(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, ::Ice::Long, const ::std::string&, ::Ice::Long, ::Ice::Int, const ::DataQueuingIce::BinaryStream&, bool, ::Ice::Long, ::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataGuest_GetDataEx<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DataGuest_GetDataExPtr
newCallback_DataGuest_GetDataEx(T* instance, void (T::*cb)(::Ice::Int, ::Ice::Long, const ::std::string&, ::Ice::Long, ::Ice::Int, const ::DataQueuingIce::BinaryStream&, bool, ::Ice::Long, ::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataGuest_GetDataEx<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_DataGuest_GetDataEx : public Callback_DataGuest_GetDataEx_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, ::Ice::Long, const ::std::string&, ::Ice::Long, ::Ice::Int, const ::DataQueuingIce::BinaryStream&, bool, ::Ice::Long, ::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const CT&);

    Callback_DataGuest_GetDataEx(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataGuestPrx __proxy = ::DataQueuingIce::DataGuestPrx::uncheckedCast(__result->getProxy());
        ::Ice::Long DataIdent;
        ::std::string token;
        ::Ice::Long Lba;
        ::Ice::Int secs;
        ::DataQueuingIce::BinaryStream data;
        bool isEnd;
        ::Ice::Long sn;
        ::Ice::Long TimeSeconds;
        ::Ice::Int TimeMicroseconds;
        ::Ice::Int crc;
        ::Ice::Int dataType;
        ::Ice::Int fragmentTotals;
        ::Ice::Int fragmentIndex;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_GetDataEx(DataIdent, token, Lba, secs, data, isEnd, sn, TimeSeconds, TimeMicroseconds, crc, dataType, fragmentTotals, fragmentIndex, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, DataIdent, token, Lba, secs, data, isEnd, sn, TimeSeconds, TimeMicroseconds, crc, dataType, fragmentTotals, fragmentIndex, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_DataGuest_GetDataExPtr
newCallback_DataGuest_GetDataEx(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, ::Ice::Long, const ::std::string&, ::Ice::Long, ::Ice::Int, const ::DataQueuingIce::BinaryStream&, bool, ::Ice::Long, ::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataGuest_GetDataEx<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DataGuest_GetDataExPtr
newCallback_DataGuest_GetDataEx(T* instance, void (T::*cb)(::Ice::Int, ::Ice::Long, const ::std::string&, ::Ice::Long, ::Ice::Int, const ::DataQueuingIce::BinaryStream&, bool, ::Ice::Long, ::Ice::Long, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataGuest_GetDataEx<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_DataGuest_DataCompleted : public Callback_DataGuest_DataCompleted_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_DataGuest_DataCompleted(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataGuestPrx __proxy = ::DataQueuingIce::DataGuestPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_DataCompleted(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_DataGuest_DataCompletedPtr
newCallback_DataGuest_DataCompleted(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataGuest_DataCompleted<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DataGuest_DataCompletedPtr
newCallback_DataGuest_DataCompleted(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataGuest_DataCompleted<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_DataGuest_DataCompleted : public Callback_DataGuest_DataCompleted_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_DataGuest_DataCompleted(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataGuestPrx __proxy = ::DataQueuingIce::DataGuestPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_DataCompleted(__result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_DataGuest_DataCompletedPtr
newCallback_DataGuest_DataCompleted(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataGuest_DataCompleted<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DataGuest_DataCompletedPtr
newCallback_DataGuest_DataCompleted(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataGuest_DataCompleted<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_DataGuest_GetBitmapInfo : public Callback_DataGuest_GetBitmapInfo_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, ::Ice::Int);

    CallbackNC_DataGuest_GetBitmapInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataGuestPrx __proxy = ::DataQueuingIce::DataGuestPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int bitmapCount;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_GetBitmapInfo(bitmapCount, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, bitmapCount);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_DataGuest_GetBitmapInfoPtr
newCallback_DataGuest_GetBitmapInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataGuest_GetBitmapInfo<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DataGuest_GetBitmapInfoPtr
newCallback_DataGuest_GetBitmapInfo(T* instance, void (T::*cb)(::Ice::Int, ::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataGuest_GetBitmapInfo<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_DataGuest_GetBitmapInfo : public Callback_DataGuest_GetBitmapInfo_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, ::Ice::Int, const CT&);

    Callback_DataGuest_GetBitmapInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataGuestPrx __proxy = ::DataQueuingIce::DataGuestPrx::uncheckedCast(__result->getProxy());
        ::Ice::Int bitmapCount;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_GetBitmapInfo(bitmapCount, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, bitmapCount, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_DataGuest_GetBitmapInfoPtr
newCallback_DataGuest_GetBitmapInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataGuest_GetBitmapInfo<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DataGuest_GetBitmapInfoPtr
newCallback_DataGuest_GetBitmapInfo(T* instance, void (T::*cb)(::Ice::Int, ::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataGuest_GetBitmapInfo<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_DataGuest_GetBitmapData : public Callback_DataGuest_GetBitmapData_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int, const ::std::string&, const ::DataQueuingIce::BinaryStream&, bool);

    CallbackNC_DataGuest_GetBitmapData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataGuestPrx __proxy = ::DataQueuingIce::DataGuestPrx::uncheckedCast(__result->getProxy());
        ::std::string token;
        ::DataQueuingIce::BinaryStream data;
        bool isEnd;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_GetBitmapData(token, data, isEnd, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(__ret, token, data, isEnd);
        }
    }

    private:

    Response _response;
};

template<class T> Callback_DataGuest_GetBitmapDataPtr
newCallback_DataGuest_GetBitmapData(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::std::string&, const ::DataQueuingIce::BinaryStream&, bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataGuest_GetBitmapData<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_DataGuest_GetBitmapDataPtr
newCallback_DataGuest_GetBitmapData(T* instance, void (T::*cb)(::Ice::Int, const ::std::string&, const ::DataQueuingIce::BinaryStream&, bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_DataGuest_GetBitmapData<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_DataGuest_GetBitmapData : public Callback_DataGuest_GetBitmapData_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const ::std::string&, const ::DataQueuingIce::BinaryStream&, bool, const CT&);

    Callback_DataGuest_GetBitmapData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::DataQueuingIce::DataGuestPrx __proxy = ::DataQueuingIce::DataGuestPrx::uncheckedCast(__result->getProxy());
        ::std::string token;
        ::DataQueuingIce::BinaryStream data;
        bool isEnd;
        ::Ice::Int __ret;
        try
        {
            __ret = __proxy->end_GetBitmapData(token, data, isEnd, __result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(__result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(__ret, token, data, isEnd, CT::dynamicCast(__result->getCookie()));
        }
    }

    private:

    Response _response;
};

template<class T, typename CT> Callback_DataGuest_GetBitmapDataPtr
newCallback_DataGuest_GetBitmapData(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const ::std::string&, const ::DataQueuingIce::BinaryStream&, bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataGuest_GetBitmapData<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_DataGuest_GetBitmapDataPtr
newCallback_DataGuest_GetBitmapData(T* instance, void (T::*cb)(::Ice::Int, const ::std::string&, const ::DataQueuingIce::BinaryStream&, bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_DataGuest_GetBitmapData<T, CT>(instance, cb, excb, sentcb);
}

}

#include <IceUtil/PopDisableWarnings.h>
#endif
