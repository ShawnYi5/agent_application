# -*- coding: utf-8 -*-
# **********************************************************************
#
# Copyright (c) 2003-2017 ZeroC, Inc. All rights reserved.
#
# This copy of Ice is licensed to you under the terms described in the
# ICE_LICENSE file included in this distribution.
#
# **********************************************************************
#
# Ice version 3.6.4
#
# <auto-generated>
#
# Generated from file `img.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

from sys import version_info as _version_info_
import Ice, IcePy
import utils_ice

# Included module Utils
_M_Utils = Ice.openModule('Utils')

# Start of module IMG
_M_IMG = Ice.openModule('IMG')
__name__ = 'IMG'

if '_t_BinaryStream' not in _M_IMG.__dict__:
    _M_IMG._t_BinaryStream = IcePy.defineSequence('::IMG::BinaryStream', (), IcePy._t_byte)

if 'DuplicateFileSector' not in _M_IMG.__dict__:
    _M_IMG.DuplicateFileSector = Ice.createTempClass()
    class DuplicateFileSector(object):
        def __init__(self, diskByteOffset=0, diskBytes=0, fileByteOffset=0, fileIdent=''):
            self.diskByteOffset = diskByteOffset
            self.diskBytes = diskBytes
            self.fileByteOffset = fileByteOffset
            self.fileIdent = fileIdent

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.diskByteOffset)
            _h = 5 * _h + Ice.getHash(self.diskBytes)
            _h = 5 * _h + Ice.getHash(self.fileByteOffset)
            _h = 5 * _h + Ice.getHash(self.fileIdent)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_IMG.DuplicateFileSector):
                return NotImplemented
            else:
                if self.diskByteOffset is None or other.diskByteOffset is None:
                    if self.diskByteOffset != other.diskByteOffset:
                        return (-1 if self.diskByteOffset is None else 1)
                else:
                    if self.diskByteOffset < other.diskByteOffset:
                        return -1
                    elif self.diskByteOffset > other.diskByteOffset:
                        return 1
                if self.diskBytes is None or other.diskBytes is None:
                    if self.diskBytes != other.diskBytes:
                        return (-1 if self.diskBytes is None else 1)
                else:
                    if self.diskBytes < other.diskBytes:
                        return -1
                    elif self.diskBytes > other.diskBytes:
                        return 1
                if self.fileByteOffset is None or other.fileByteOffset is None:
                    if self.fileByteOffset != other.fileByteOffset:
                        return (-1 if self.fileByteOffset is None else 1)
                else:
                    if self.fileByteOffset < other.fileByteOffset:
                        return -1
                    elif self.fileByteOffset > other.fileByteOffset:
                        return 1
                if self.fileIdent is None or other.fileIdent is None:
                    if self.fileIdent != other.fileIdent:
                        return (-1 if self.fileIdent is None else 1)
                else:
                    if self.fileIdent < other.fileIdent:
                        return -1
                    elif self.fileIdent > other.fileIdent:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_IMG._t_DuplicateFileSector)

        __repr__ = __str__

    _M_IMG._t_DuplicateFileSector = IcePy.defineStruct('::IMG::DuplicateFileSector', DuplicateFileSector, (), (
        ('diskByteOffset', (), IcePy._t_long),
        ('diskBytes', (), IcePy._t_long),
        ('fileByteOffset', (), IcePy._t_long),
        ('fileIdent', (), IcePy._t_string)
    ))

    _M_IMG.DuplicateFileSector = DuplicateFileSector
    del DuplicateFileSector

if '_t_DuplicateFileSectors' not in _M_IMG.__dict__:
    _M_IMG._t_DuplicateFileSectors = IcePy.defineSequence('::IMG::DuplicateFileSectors', (), _M_IMG._t_DuplicateFileSector)

if 'FileSector' not in _M_IMG.__dict__:
    _M_IMG.FileSector = Ice.createTempClass()
    class FileSector(object):
        def __init__(self, diskByteOffset=0, diskBytes=0):
            self.diskByteOffset = diskByteOffset
            self.diskBytes = diskBytes

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.diskByteOffset)
            _h = 5 * _h + Ice.getHash(self.diskBytes)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_IMG.FileSector):
                return NotImplemented
            else:
                if self.diskByteOffset is None or other.diskByteOffset is None:
                    if self.diskByteOffset != other.diskByteOffset:
                        return (-1 if self.diskByteOffset is None else 1)
                else:
                    if self.diskByteOffset < other.diskByteOffset:
                        return -1
                    elif self.diskByteOffset > other.diskByteOffset:
                        return 1
                if self.diskBytes is None or other.diskBytes is None:
                    if self.diskBytes != other.diskBytes:
                        return (-1 if self.diskBytes is None else 1)
                else:
                    if self.diskBytes < other.diskBytes:
                        return -1
                    elif self.diskBytes > other.diskBytes:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_IMG._t_FileSector)

        __repr__ = __str__

    _M_IMG._t_FileSector = IcePy.defineStruct('::IMG::FileSector', FileSector, (), (
        ('diskByteOffset', (), IcePy._t_long),
        ('diskBytes', (), IcePy._t_long)
    ))

    _M_IMG.FileSector = FileSector
    del FileSector

if '_t_FileSectors' not in _M_IMG.__dict__:
    _M_IMG._t_FileSectors = IcePy.defineSequence('::IMG::FileSectors', (), _M_IMG._t_FileSector)

if 'ImageSnapshotIdent' not in _M_IMG.__dict__:
    _M_IMG.ImageSnapshotIdent = Ice.createTempClass()
    class ImageSnapshotIdent(object):
        def __init__(self, path='', snapshot=''):
            self.path = path
            self.snapshot = snapshot

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.path)
            _h = 5 * _h + Ice.getHash(self.snapshot)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_IMG.ImageSnapshotIdent):
                return NotImplemented
            else:
                if self.path is None or other.path is None:
                    if self.path != other.path:
                        return (-1 if self.path is None else 1)
                else:
                    if self.path < other.path:
                        return -1
                    elif self.path > other.path:
                        return 1
                if self.snapshot is None or other.snapshot is None:
                    if self.snapshot != other.snapshot:
                        return (-1 if self.snapshot is None else 1)
                else:
                    if self.snapshot < other.snapshot:
                        return -1
                    elif self.snapshot > other.snapshot:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_IMG._t_ImageSnapshotIdent)

        __repr__ = __str__

    _M_IMG._t_ImageSnapshotIdent = IcePy.defineStruct('::IMG::ImageSnapshotIdent', ImageSnapshotIdent, (), (
        ('path', (), IcePy._t_string),
        ('snapshot', (), IcePy._t_string)
    ))

    _M_IMG.ImageSnapshotIdent = ImageSnapshotIdent
    del ImageSnapshotIdent

if '_t_ImageSnapshotIdents' not in _M_IMG.__dict__:
    _M_IMG._t_ImageSnapshotIdents = IcePy.defineSequence('::IMG::ImageSnapshotIdents', (), _M_IMG._t_ImageSnapshotIdent)

if '_t_BlockIndexes' not in _M_IMG.__dict__:
    _M_IMG._t_BlockIndexes = IcePy.defineSequence('::IMG::BlockIndexes', (), IcePy._t_long)

if 'ImgService' not in _M_IMG.__dict__:
    _M_IMG.ImgService = Ice.createTempClass()
    class ImgService(Ice.Object):
        def __init__(self):
            if Ice.getType(self) == _M_IMG.ImgService:
                raise RuntimeError('IMG.ImgService is an abstract class')

        def ice_ids(self, current=None):
            return ('::IMG::ImgService', '::Ice::Object')

        def ice_id(self, current=None):
            return '::IMG::ImgService'

        def ice_staticId():
            return '::IMG::ImgService'
        ice_staticId = staticmethod(ice_staticId)

        def create(self, ident, lastSnapshot, diskByteSize, flag, current=None):
            pass

        def setUsedBlockBitmap(self, handle, bitmap, completed, current=None):
            pass

        def cleanUsedBlockBitmap(self, handle, indexes, current=None):
            pass

        def setDuplicateFileSectors(self, handle, sectors, completed, current=None):
            pass

        def open(self, ident, flag, current=None):
            pass

        def getTotalUesdBlockBitmap(self, handle, index, current=None):
            pass

        def getAllFileSectors(self, handle, index, current=None):
            pass

        def read(self, handle, byteOffset, byteSize, current=None):
            pass

        def readEx(self, handle, byteOffset, byteSize, current=None):
            pass

        def write(self, handle, byteOffset, data, current=None):
            pass

        def writeCdp(self, handle, byteOffset, data, enableTime, timeSeconds, timeMicroseconds, IgnoreQuota, current=None):
            pass

        def writeCdpByIndex(self, handle, byteOffset, data, index, rev1, rev2, current=None):
            pass

        def writeCdpByTmeAndIndex(self, handle, byteOffset, data, enableTime, timeSeconds, timeMicroseconds, IgnoreQuota, index, rev1, rev2, current=None):
            pass

        def close(self, handle, success, current=None):
            pass

        def GetSnSize(self, handle, current=None):
            pass

        def DelSnaport(self, ident, current=None):
            pass

        def RenameSnapshot(self, ident, newSnapshot, current=None):
            pass

        def GetOnSnMapFile(self, ident, current=None):
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_IMG._t_ImgService)

        __repr__ = __str__

    _M_IMG.ImgServicePrx = Ice.createTempClass()
    class ImgServicePrx(Ice.ObjectPrx):

        def create(self, ident, lastSnapshot, diskByteSize, flag, _ctx=None):
            return _M_IMG.ImgService._op_create.invoke(self, ((ident, lastSnapshot, diskByteSize, flag), _ctx))

        def begin_create(self, ident, lastSnapshot, diskByteSize, flag, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IMG.ImgService._op_create.begin(self, ((ident, lastSnapshot, diskByteSize, flag), _response, _ex, _sent, _ctx))

        def end_create(self, _r):
            return _M_IMG.ImgService._op_create.end(self, _r)

        def setUsedBlockBitmap(self, handle, bitmap, completed, _ctx=None):
            return _M_IMG.ImgService._op_setUsedBlockBitmap.invoke(self, ((handle, bitmap, completed), _ctx))

        def begin_setUsedBlockBitmap(self, handle, bitmap, completed, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IMG.ImgService._op_setUsedBlockBitmap.begin(self, ((handle, bitmap, completed), _response, _ex, _sent, _ctx))

        def end_setUsedBlockBitmap(self, _r):
            return _M_IMG.ImgService._op_setUsedBlockBitmap.end(self, _r)

        def cleanUsedBlockBitmap(self, handle, indexes, _ctx=None):
            return _M_IMG.ImgService._op_cleanUsedBlockBitmap.invoke(self, ((handle, indexes), _ctx))

        def begin_cleanUsedBlockBitmap(self, handle, indexes, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IMG.ImgService._op_cleanUsedBlockBitmap.begin(self, ((handle, indexes), _response, _ex, _sent, _ctx))

        def end_cleanUsedBlockBitmap(self, _r):
            return _M_IMG.ImgService._op_cleanUsedBlockBitmap.end(self, _r)

        def setDuplicateFileSectors(self, handle, sectors, completed, _ctx=None):
            return _M_IMG.ImgService._op_setDuplicateFileSectors.invoke(self, ((handle, sectors, completed), _ctx))

        def begin_setDuplicateFileSectors(self, handle, sectors, completed, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IMG.ImgService._op_setDuplicateFileSectors.begin(self, ((handle, sectors, completed), _response, _ex, _sent, _ctx))

        def end_setDuplicateFileSectors(self, _r):
            return _M_IMG.ImgService._op_setDuplicateFileSectors.end(self, _r)

        def open(self, ident, flag, _ctx=None):
            return _M_IMG.ImgService._op_open.invoke(self, ((ident, flag), _ctx))

        def begin_open(self, ident, flag, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IMG.ImgService._op_open.begin(self, ((ident, flag), _response, _ex, _sent, _ctx))

        def end_open(self, _r):
            return _M_IMG.ImgService._op_open.end(self, _r)

        def getTotalUesdBlockBitmap(self, handle, index, _ctx=None):
            return _M_IMG.ImgService._op_getTotalUesdBlockBitmap.invoke(self, ((handle, index), _ctx))

        def begin_getTotalUesdBlockBitmap(self, handle, index, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IMG.ImgService._op_getTotalUesdBlockBitmap.begin(self, ((handle, index), _response, _ex, _sent, _ctx))

        def end_getTotalUesdBlockBitmap(self, _r):
            return _M_IMG.ImgService._op_getTotalUesdBlockBitmap.end(self, _r)

        def getAllFileSectors(self, handle, index, _ctx=None):
            return _M_IMG.ImgService._op_getAllFileSectors.invoke(self, ((handle, index), _ctx))

        def begin_getAllFileSectors(self, handle, index, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IMG.ImgService._op_getAllFileSectors.begin(self, ((handle, index), _response, _ex, _sent, _ctx))

        def end_getAllFileSectors(self, _r):
            return _M_IMG.ImgService._op_getAllFileSectors.end(self, _r)

        def read(self, handle, byteOffset, byteSize, _ctx=None):
            return _M_IMG.ImgService._op_read.invoke(self, ((handle, byteOffset, byteSize), _ctx))

        def begin_read(self, handle, byteOffset, byteSize, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IMG.ImgService._op_read.begin(self, ((handle, byteOffset, byteSize), _response, _ex, _sent, _ctx))

        def end_read(self, _r):
            return _M_IMG.ImgService._op_read.end(self, _r)

        def readEx(self, handle, byteOffset, byteSize, _ctx=None):
            return _M_IMG.ImgService._op_readEx.invoke(self, ((handle, byteOffset, byteSize), _ctx))

        def begin_readEx(self, handle, byteOffset, byteSize, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IMG.ImgService._op_readEx.begin(self, ((handle, byteOffset, byteSize), _response, _ex, _sent, _ctx))

        def end_readEx(self, _r):
            return _M_IMG.ImgService._op_readEx.end(self, _r)

        def write(self, handle, byteOffset, data, _ctx=None):
            return _M_IMG.ImgService._op_write.invoke(self, ((handle, byteOffset, data), _ctx))

        def begin_write(self, handle, byteOffset, data, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IMG.ImgService._op_write.begin(self, ((handle, byteOffset, data), _response, _ex, _sent, _ctx))

        def end_write(self, _r):
            return _M_IMG.ImgService._op_write.end(self, _r)

        def writeCdp(self, handle, byteOffset, data, enableTime, timeSeconds, timeMicroseconds, IgnoreQuota, _ctx=None):
            return _M_IMG.ImgService._op_writeCdp.invoke(self, ((handle, byteOffset, data, enableTime, timeSeconds, timeMicroseconds, IgnoreQuota), _ctx))

        def begin_writeCdp(self, handle, byteOffset, data, enableTime, timeSeconds, timeMicroseconds, IgnoreQuota, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IMG.ImgService._op_writeCdp.begin(self, ((handle, byteOffset, data, enableTime, timeSeconds, timeMicroseconds, IgnoreQuota), _response, _ex, _sent, _ctx))

        def end_writeCdp(self, _r):
            return _M_IMG.ImgService._op_writeCdp.end(self, _r)

        def writeCdpByIndex(self, handle, byteOffset, data, index, rev1, rev2, _ctx=None):
            return _M_IMG.ImgService._op_writeCdpByIndex.invoke(self, ((handle, byteOffset, data, index, rev1, rev2), _ctx))

        def begin_writeCdpByIndex(self, handle, byteOffset, data, index, rev1, rev2, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IMG.ImgService._op_writeCdpByIndex.begin(self, ((handle, byteOffset, data, index, rev1, rev2), _response, _ex, _sent, _ctx))

        def end_writeCdpByIndex(self, _r):
            return _M_IMG.ImgService._op_writeCdpByIndex.end(self, _r)

        def writeCdpByTmeAndIndex(self, handle, byteOffset, data, enableTime, timeSeconds, timeMicroseconds, IgnoreQuota, index, rev1, rev2, _ctx=None):
            return _M_IMG.ImgService._op_writeCdpByTmeAndIndex.invoke(self, ((handle, byteOffset, data, enableTime, timeSeconds, timeMicroseconds, IgnoreQuota, index, rev1, rev2), _ctx))

        def begin_writeCdpByTmeAndIndex(self, handle, byteOffset, data, enableTime, timeSeconds, timeMicroseconds, IgnoreQuota, index, rev1, rev2, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IMG.ImgService._op_writeCdpByTmeAndIndex.begin(self, ((handle, byteOffset, data, enableTime, timeSeconds, timeMicroseconds, IgnoreQuota, index, rev1, rev2), _response, _ex, _sent, _ctx))

        def end_writeCdpByTmeAndIndex(self, _r):
            return _M_IMG.ImgService._op_writeCdpByTmeAndIndex.end(self, _r)

        def close(self, handle, success, _ctx=None):
            return _M_IMG.ImgService._op_close.invoke(self, ((handle, success), _ctx))

        def begin_close(self, handle, success, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IMG.ImgService._op_close.begin(self, ((handle, success), _response, _ex, _sent, _ctx))

        def end_close(self, _r):
            return _M_IMG.ImgService._op_close.end(self, _r)

        def GetSnSize(self, handle, _ctx=None):
            return _M_IMG.ImgService._op_GetSnSize.invoke(self, ((handle, ), _ctx))

        def begin_GetSnSize(self, handle, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IMG.ImgService._op_GetSnSize.begin(self, ((handle, ), _response, _ex, _sent, _ctx))

        def end_GetSnSize(self, _r):
            return _M_IMG.ImgService._op_GetSnSize.end(self, _r)

        def DelSnaport(self, ident, _ctx=None):
            return _M_IMG.ImgService._op_DelSnaport.invoke(self, ((ident, ), _ctx))

        def begin_DelSnaport(self, ident, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IMG.ImgService._op_DelSnaport.begin(self, ((ident, ), _response, _ex, _sent, _ctx))

        def end_DelSnaport(self, _r):
            return _M_IMG.ImgService._op_DelSnaport.end(self, _r)

        def RenameSnapshot(self, ident, newSnapshot, _ctx=None):
            return _M_IMG.ImgService._op_RenameSnapshot.invoke(self, ((ident, newSnapshot), _ctx))

        def begin_RenameSnapshot(self, ident, newSnapshot, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IMG.ImgService._op_RenameSnapshot.begin(self, ((ident, newSnapshot), _response, _ex, _sent, _ctx))

        def end_RenameSnapshot(self, _r):
            return _M_IMG.ImgService._op_RenameSnapshot.end(self, _r)

        def GetOnSnMapFile(self, ident, _ctx=None):
            return _M_IMG.ImgService._op_GetOnSnMapFile.invoke(self, ((ident, ), _ctx))

        def begin_GetOnSnMapFile(self, ident, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_IMG.ImgService._op_GetOnSnMapFile.begin(self, ((ident, ), _response, _ex, _sent, _ctx))

        def end_GetOnSnMapFile(self, _r):
            return _M_IMG.ImgService._op_GetOnSnMapFile.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_IMG.ImgServicePrx.ice_checkedCast(proxy, '::IMG::ImgService', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_IMG.ImgServicePrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

        def ice_staticId():
            return '::IMG::ImgService'
        ice_staticId = staticmethod(ice_staticId)

    _M_IMG._t_ImgServicePrx = IcePy.defineProxy('::IMG::ImgService', ImgServicePrx)

    _M_IMG._t_ImgService = IcePy.defineClass('::IMG::ImgService', ImgService, -1, (), True, False, None, (), ())
    ImgService._ice_type = _M_IMG._t_ImgService

    ImgService._op_create = IcePy.Operation('create', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_IMG._t_ImageSnapshotIdent, False, 0), ((), _M_IMG._t_ImageSnapshotIdents, False, 0), ((), IcePy._t_long, False, 0), ((), IcePy._t_string, False, 0)), (), ((), IcePy._t_long, False, 0), (_M_Utils._t_SystemError,))
    ImgService._op_setUsedBlockBitmap = IcePy.Operation('setUsedBlockBitmap', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_long, False, 0), ((), _M_IMG._t_BinaryStream, False, 0), ((), IcePy._t_bool, False, 0)), (), ((), IcePy._t_int, False, 0), (_M_Utils._t_SystemError,))
    ImgService._op_cleanUsedBlockBitmap = IcePy.Operation('cleanUsedBlockBitmap', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_long, False, 0), ((), _M_IMG._t_BlockIndexes, False, 0)), (), ((), IcePy._t_int, False, 0), (_M_Utils._t_SystemError,))
    ImgService._op_setDuplicateFileSectors = IcePy.Operation('setDuplicateFileSectors', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_long, False, 0), ((), _M_IMG._t_DuplicateFileSectors, False, 0), ((), IcePy._t_bool, False, 0)), (), ((), IcePy._t_int, False, 0), (_M_Utils._t_SystemError,))
    ImgService._op_open = IcePy.Operation('open', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_IMG._t_ImageSnapshotIdents, False, 0), ((), IcePy._t_string, False, 0)), (), ((), IcePy._t_long, False, 0), (_M_Utils._t_SystemError,))
    ImgService._op_getTotalUesdBlockBitmap = IcePy.Operation('getTotalUesdBlockBitmap', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_long, False, 0), ((), IcePy._t_int, False, 0)), (((), _M_IMG._t_BinaryStream, False, 0), ((), IcePy._t_bool, False, 0)), ((), IcePy._t_int, False, 0), (_M_Utils._t_SystemError,))
    ImgService._op_getAllFileSectors = IcePy.Operation('getAllFileSectors', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_long, False, 0), ((), IcePy._t_long, False, 0)), (((), _M_IMG._t_FileSectors, False, 0), ((), IcePy._t_bool, False, 0)), ((), IcePy._t_long, False, 0), (_M_Utils._t_SystemError,))
    ImgService._op_read = IcePy.Operation('read', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_long, False, 0), ((), IcePy._t_long, False, 0), ((), IcePy._t_int, False, 0)), (((), _M_IMG._t_BinaryStream, False, 0),), ((), IcePy._t_int, False, 0), (_M_Utils._t_SystemError,))
    ImgService._op_readEx = IcePy.Operation('readEx', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_long, False, 0), ((), IcePy._t_long, False, 0), ((), IcePy._t_int, False, 0)), (((), _M_IMG._t_BinaryStream, False, 0),), ((), IcePy._t_int, False, 0), (_M_Utils._t_SystemError,))
    ImgService._op_write = IcePy.Operation('write', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_long, False, 0), ((), IcePy._t_long, False, 0), ((), _M_IMG._t_BinaryStream, False, 0)), (), ((), IcePy._t_int, False, 0), (_M_Utils._t_SystemError,))
    ImgService._op_writeCdp = IcePy.Operation('writeCdp', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_long, False, 0), ((), IcePy._t_long, False, 0), ((), _M_IMG._t_BinaryStream, False, 0), ((), IcePy._t_bool, False, 0), ((), IcePy._t_long, False, 0), ((), IcePy._t_int, False, 0), ((), IcePy._t_bool, False, 0)), (), ((), IcePy._t_int, False, 0), (_M_Utils._t_SystemError,))
    ImgService._op_writeCdpByIndex = IcePy.Operation('writeCdpByIndex', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_long, False, 0), ((), IcePy._t_long, False, 0), ((), _M_IMG._t_BinaryStream, False, 0), ((), IcePy._t_long, False, 0), ((), IcePy._t_long, False, 0), ((), IcePy._t_long, False, 0)), (), ((), IcePy._t_int, False, 0), (_M_Utils._t_SystemError,))
    ImgService._op_writeCdpByTmeAndIndex = IcePy.Operation('writeCdpByTmeAndIndex', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_long, False, 0), ((), IcePy._t_long, False, 0), ((), _M_IMG._t_BinaryStream, False, 0), ((), IcePy._t_bool, False, 0), ((), IcePy._t_long, False, 0), ((), IcePy._t_int, False, 0), ((), IcePy._t_bool, False, 0), ((), IcePy._t_long, False, 0), ((), IcePy._t_long, False, 0), ((), IcePy._t_long, False, 0)), (), ((), IcePy._t_int, False, 0), (_M_Utils._t_SystemError,))
    ImgService._op_close = IcePy.Operation('close', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_long, False, 0), ((), IcePy._t_bool, False, 0)), (), None, (_M_Utils._t_SystemError,))
    ImgService._op_GetSnSize = IcePy.Operation('GetSnSize', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_long, False, 0),), (), ((), IcePy._t_long, False, 0), (_M_Utils._t_SystemError,))
    ImgService._op_DelSnaport = IcePy.Operation('DelSnaport', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_IMG._t_ImageSnapshotIdent, False, 0),), (), ((), IcePy._t_int, False, 0), (_M_Utils._t_SystemError,))
    ImgService._op_RenameSnapshot = IcePy.Operation('RenameSnapshot', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_IMG._t_ImageSnapshotIdent, False, 0), ((), IcePy._t_string, False, 0)), (), ((), IcePy._t_int, False, 0), (_M_Utils._t_SystemError,))
    ImgService._op_GetOnSnMapFile = IcePy.Operation('GetOnSnMapFile', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_IMG._t_ImageSnapshotIdent, False, 0),), (), ((), IcePy._t_string, False, 0), (_M_Utils._t_SystemError,))

    _M_IMG.ImgService = ImgService
    del ImgService

    _M_IMG.ImgServicePrx = ImgServicePrx
    del ImgServicePrx

# End of module IMG
